<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC]]></title>
    <url>%2F2020%2F04%2F02%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC概念 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。 使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。 入门执行步骤 第一步：环境搭建 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;!--版本锁定--&gt; &lt;spring.version&gt;5.2.4.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--sping ioc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet api--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第二步：在web.xml配置文件中核心控制器DispatcherServlet 123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--配置Servlet的初始化参数 读取springmvc的配置文件，创建Spring容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--配置servlet 启动时加载对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 第三步：编写springmvc.xml的配置文件 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--配置spring创建容器要扫描的包--&gt; &lt;context:component-scan base-package="com.nogizaka"&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置spring开启注解mvc的支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 第四步：编写index.jsp和HelloController控制器类 第五步：在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面 第六步：启动Tomcat服务器，进行测试 执行流程 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件 开启了注解扫描，那么HelloController对象就会被创建 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 Tomcat服务器渲染页面，做出响应 组件分析 前端控制器（DispatcherServlet）；用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器（HandlerMapping）：HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等 处理器（Handler）：它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 处理器适配器（HandlAdapter）：通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 视图解析器（View Resolver）：View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图（View）：SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 &lt;mvc:annotation-driven&gt;说明 在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven&gt;自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter（处理适配器），可用在SpringMVC.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。 1234567891011121314&lt;!-- 上面的标签相当于 如下配置--&gt; &lt;!-- Begin --&gt; &lt;!-- HandlerMapping --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- HandlerAdapter --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- HadnlerExceptionResolvers --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"&gt;&lt;/bean&gt; &lt;!-- End --&gt; @RequestMapping注解 RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系 RequestMapping注解可以作用在方法和类上 作用在类上：第一级的访问目录 作用在方法上：第二级的访问目录 细节：路径可以不编写/表示应用的根目录开始 细节：${ pageContext.request.contextPath}也可以省略不写，但是路径上不能写 / RequestMapping的属性 path：指定请求路径的url value ：value属性和path属性是一样的 method： 指定该方法的请求方式 headers ：发送的请求中必须包含的请求头 params ：指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样. 例如： params = {“accountName”}，表示请求参数必须有 accountName params = {“moeny!100”}，表示请求参数中 money 不能是 100。 请求参数的绑定绑定的机制 绑定机制 表单提交的数据都是k=v格式的 username=haha&amp;password=123 SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 要求：提交表单的name和参数的名称是相同的 支持的数据类型 基本数据类型和字符串类型 实体类型（JavaBean） 集合数据类型（List、map集合等） 支持的数据类型 基本数据类型：基本类型和String 提交表单的name和参数的名称是相同的 区分大小写 POJO类型参数：实体类以及关联的实体类 提交表单的name和JavaBean中的属性名称需要一致 如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：address.name 数组和集合类型参数：包括List结构和Map结构的集合 JSP页面编写方式：list[0].属性 请求参数中文乱码 在web.xml中配置Spring提供的过滤器类 1234567891011121314&lt;!--配置解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--指定字符集--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注意如果出现控制台中文乱码，检查当前编码输出格式：System.out.println(System.getProperty(&quot;file.encoding&quot;)); 自定义类型转换器 定义一个类，实现Converter接口，该接口有两个泛型 在 spring 配置文件中配置类型转换器。 在 annotation-driven 标签中引用配置的类型转换服务 1234567891011&lt;!--配置自定义类型转换器--&gt;&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="com.nogizaka.utils.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--配置spring开启注解mvc的支持 添加类型转换器--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"&gt;&lt;/mvc:annotation-driven&gt; 使用 ServletAPI 对象作为方法参数 直接写在Controller控制的方法参数中使用 1234567@RequestMapping("/testServletAPI")public String testServletAPI(HttpServletRequest request,HttpServletResponse response,HttpSession session) &#123; System.out.println(request); System.out.println(response); System.out.println(session); return "success";&#125; 常用注解@RequestParam 作用：把请求中指定名称的参数给控制器中的形参赋值。 属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 示例代码： 123456@RequestMapping(path="/hello")public String sayHello(@RequestParam(value="username",required=false)String name) &#123; System.out.println("aaaa"); System.out.println(name); return "success";&#125; @RequestBody 作用：用于获取请求体内容。直接使用得到是key=value&amp;key=value..结构的数据。get请求方式不适用。 属性： required：是否必须有请求体。默认值是:true。当取值为true时,get请求方式会报错。如果取值为false，get请求得到是null。 示例代码： 123456@RequestMapping(path="/hello")public String sayHello(@RequestBody String body) &#123; System.out.println("aaaa"); System.out.println(body); return "success";&#125; @ResponseBody 作用：将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据 注意：在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。 @PathVariable 作用：拥有绑定url中的 的。例如：url中有/delete/{id}，{id}就是占位符 属性： value:指定url中的占位符名称 Restful风格的URL 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 restful风格的URL优点 结构清晰 符合标准 易于理解 扩展方便 示例代码： 12345@RequestMapping(path="/hello/&#123;id&#125;")public String sayHello(@PathVariable(value="id") String id) &#123; System.out.println(id); return "success";&#125; @RequestHeader 作用：获取指定请求头的值 属性： value：请求头的名称 示例代码： 12345@RequestMapping(path="/hello")public String sayHello(@RequestHeader(value="Accept") String header) &#123; System.out.println(header); return "success";&#125; @CookieValue 作用：用于获取指定cookie的名称的值 属性： value：cookie的名称 示例代码： 12345@RequestMapping(path="/hello")public String sayHello(@CookieValue(value="JSESSIONID") String cookieValue) &#123; System.out.println(cookieValue); return "success";&#125; @ModelAttribute 作用： 出现在方法上：表示当前方法会在控制器方法执行前先执行 出现在参数上：获取指定的数据给参数赋值 应用场景： 当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 作用在方法，先执行* @param name* @return*/@ModelAttributepublic User showUser(String name) &#123;System.out.println("showUser执行了..."); // 模拟从数据库中查询对象 User user = new User(); user.setName("哈哈"); user.setPassword("123"); user.setMoney(100d); return user;&#125; /*** 修改用户的方法* @param cookieValue* @return*/@RequestMapping(path="/updateUser")public String updateUser(User user) &#123; System.out.println(user); return "success";&#125;//Model修饰方法不带返回值@ModelAttributepublic void showModel(String username,Map&lt;String,User&gt; map) &#123;//模拟去数据库查询 User user = findUserByName(username); System.out.println("执行了 showModel 方法"+user); map.put("abc",user);&#125;/*** 模拟修改用户方法* @param user* @return*/@RequestMapping("/updateUser")public String testModelAttribute(@ModelAttribute("abc")User user) &#123; System.out.println("控制器中处理请求的方法：修改用户："+user); return "success";&#125; @SessionAttribute 作用：用于多次执行控制器方法间参数共享，只能作用在类上 属性： value：指定存入属性的名称 Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940@Controller@RequestMapping("/anno")@SessionAttributes(value = &#123;"msg"&#125;)//把msg=飞鸟存入到session域对象中public class AnnoComtroller &#123; @RequestMapping("/testRequestParam") public String testRequestParam(@RequestParam(name = "name") String username)&#123; System.out.println("执行了"); System.out.println(username); return "success"; &#125; // 使用Model对象 将数据存入request域 @RequestMapping("/testSessionAttributes") public String testSessionAttributes(Model model)&#123; System.out.println("sessionAttributes执行了"); //底层会存储到Request域对象中 model.addAttribute("msg","飞鸟"); return "success"; &#125; // 获取session中的值 @RequestMapping("/getSessionAttributes") public String getSessionAttributes(ModelMap modelMap)&#123; System.out.println("getsessionAttributes执行了"); //底层会存储到request域对象中 Object msg = modelMap.get("msg"); System.out.println(msg); return "success"; &#125; // 删除session中的值 @RequestMapping("/delSessionAttributes") public String delSessionAttributes(SessionStatus status)&#123; System.out.println("delsessionAttributes执行了"); //底层会存储到request域对象中 status.setComplete(); return "success"; &#125; 响应数据和结果视图返回值分类String Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。 示例代码： 123456789101112131415/** * 返回字符串 * @param model * @return */@RequestMapping("/testString")public String testString(Model model)&#123; System.out.println("testString方法执行了"); //模拟从数据库中获取数据 User user = new User(); user.setUname("斋藤飞鸟"); user.setUage("20"); model.addAttribute("user",user); return "success";&#125; Void 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。 默认会跳转到@RequestMapping(value=&quot;/initUpdate&quot;) initUpdate的页面。 可以使用请求转发或者重定向或者直接响应跳转到指定的页面 示例代码： 12345678910111213141516171819202122/** * 返回void * 默认跳转testVoid.jsp * 请求转发一次请求，不用编写项目的名称 * @param */ @RequestMapping("/testVoid") public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println("testVoid方法执行了"); //编写请求转发的程序 //request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); // 编写重定向 //response.sendRedirect(request.getContextPath()+"/index.jsp"); // 设置中文乱码 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); // 直接进行响应 response.getWriter().print("你好"); return; &#125; ModelAndView ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图 示例代码： 123456789101112131415161718/** * 返回ModelAndView * @return */@RequestMapping("/testModelAndView")public ModelAndView testModelAndView()&#123; // 创建ModelAndView对象,由spring mvc提供 ModelAndView mv = new ModelAndView(); //模拟从数据库中获取数据 User user = new User(); user.setUname("白石麻衣"); user.setUage("26"); //把user对象存储到mv对象中，也会把user对象存入request域对象中 mv.addObject("user",user); // 跳转到哪个页面 mv.setViewName("success"); return mv;&#125; 转发和重定向 使用forward关键字进行请求转发 使用redirect关键字进行重定向 示例代码： 1234567891011121314 /** * 使用关键字的方式进行转发或重定向 * @return */@RequestMapping("/testForwardOrRedirect")public String testForwardOrRedirect()&#123; System.out.println("testForwardOrRedirect方法执行了"); //请求的转发 return "forward:/WEB-INF/pages/success.jsp"; //重定向,框架默认添加了项目名称request.getContextPath() return "redirect:/index.jsp";&#125; ResponseBody响应json数据 DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 使用webjars，进行如下配置（WebJars是打包到JAR（Java Archive）文件中的客户端Web库（例如jQuery和Bootstrap）。） 12345&lt;!--前端控制器 设置静态资源不过滤--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。--&gt;&lt;!--&lt;mvc:resources mapping="/webjars/**" location="classpath:/META-INF/resources/webjars/"/&gt;--&gt;&lt;!--&lt;mvc:resources mapping="/webjars/**" location="/webjars/"/&gt;--&gt; location:表示webapp目录下（即服务器根目录）的static包下的所有文件 mapping:表示以/static开头的所有请求路径，如/static/a或者/static/a/b； 作用：DispatcherServlet不会拦截以/static开头的所有请求路径，并当作静态资源交由Servlet处理； 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location="/js/" mapping="/js/**"/&gt; &lt;!-- javascript --&gt; 异步请求12345678910111213141516171819202122232425&lt;%--引入jquery资源--%&gt;&lt;script src="webjars/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 页面加载 绑定单击事件 $(function () &#123; $("#btn").click(function () &#123; /*alert("hello btn!!!!!");*/ $.ajax(&#123; //编写json格式，设置属性和值 url:"user/testAjax", contentType:"application/json;charset=UTF-8", data:'&#123;"uname":"乃木坂","uage":8&#125;', dataType:"json", type:"post", success:function (data) &#123; // data服务器端响应的json数据，进行解析 alert(data); alert(data.uname); alert(data.uage); &#125; &#125;); &#125;); &#125;);&lt;/script&gt; 使用@RequestBody注解把json的字符串转换为javabean对象 json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包 1234567891011121314151617&lt;!--jackson将json数据封装到javabean--&gt; &lt;!--spring默认用MappingJacksonHttpMessageConverter对json数据转换--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; 使用@ResponseBody注解把javabean对象转换为json字符串12345678910111213/** * 模拟异步请求和响应 */@RequestMapping("/testAjax")public @ResponseBody User testAjax(@RequestBody User user)&#123; System.out.println("testAjax方法执行了。。。"); /*客户端发送ajax请求，传json字符串，后端把json字符串封装到user对象中*/ System.out.println(user); /*响应。模拟查询数据库*/ user.setUname("飞鸟"); user.setUage("20"); return user;&#125; SpringMVC实现文件上传文件上传前提 form表单的enctype(表单请求正文的类型)取值必须是：multipart/form-data(默认值是：application/x-www-form-urlencoded) method属性取值必须是：POST 提供一个文件选择域：&lt;input type=&quot;file&quot;/&gt; 借助第三方组件实现文件上传：Commons-fileupload 传统方式文件上传 使用 Commons-fileupload 组件实现文件上传，需要导入该组件相应的支撑 jar 包：Commons-fileupload 和commons-io。commons-io 不属于文件上传组件的开发 jar 文件，但Commons-fileupload 组件从 1.1 版本开始，它工作时需要 commons-io 包的支持。 导入文件上传的Commons组件 1234567891011&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 文件上传 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 文件上传 */@RequestMapping("/testFileUpload")public String testFileUpload(HttpServletRequest request) throws Exception &#123; System.out.println("testFileUpload方法执行了。。。"); // 使用fileupload组件完成上传 // 指定上传位置 String path = request.getSession().getServletContext().getRealPath("/uploads"); // 判断 该路径是否存在 File file = new File(path); if(!file.exists())&#123; //创建该文件夹 file.mkdirs(); System.out.println("文件夹创建成功"); &#125; //解析request对象，获取上传文件项 //创建磁盘文件项工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); //解析request List&lt;FileItem&gt; items = upload.parseRequest(request); //遍历 for (FileItem item : items) &#123; // 进行判断，当前item对象是否是上传文件项 if(item.isFormField())&#123; //说明普通表单项 &#125;else &#123; //说明上传文件项 // 获取上传文件名称 String name = item.getName(); // 把文件的名称设置唯一值,uuid String uuid = UUID.randomUUID().toString().replace("-", ""); name=uuid+"_"+name; // 完成文件上传 item.write(new File(path,name)); // 删除临时文件 item.delete(); &#125; &#125; System.out.println("文件上传成功"); return "success";&#125; SpringMVC传统方式文件上传 SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的name属性名称相同。 原理：上传-&gt;前端控制器-&gt;文件解析器-&gt;前端控制器-&gt;Controller文件上传方法（参数绑定MultipartFile） 配置文件解析器 1234&lt;!--配置文件解析器对象 要求Id必须是multipartResolver--&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10*1024*1024"/&gt;&lt;/bean&gt; 代码： 12345678910111213141516171819202122232425/** * springmvc文件上传 */@RequestMapping("/SpringFileUpload")public String SpringFileUpload(HttpServletRequest request,MultipartFile upload) throws Exception &#123; System.out.println("springmvc文件上传。。"); // 指定上传位置 String path = request.getSession().getServletContext().getRealPath("/uploads"); // 判断 该路径是否存在 File file = new File(path); if(!file.exists())&#123; //创建该文件夹 file.mkdirs(); System.out.println("文件夹创建成功"); &#125; //获取上传文件名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值,uuid String uuid = UUID.randomUUID().toString().replace("-", ""); filename=uuid+"_"+filename; // 完成文件上传 upload.transferTo(new File(path,filename)); return "success";&#125; SpringMVC跨服务器方式文件上传 在实际开发中，我们会有很多处理不同功能的服务器 应用服务器：负责部署我们的应用 数据库服务器：运行我们的数据库 缓存和消息服务器：负责处理大并发访问的缓存和消息 文件服务器：负责存储用户上传文件的服务器。 SpringMVC的异常处理 异常处理思路 Controller调用Service，Service调用Dao，异常都是向上抛出的，最终由DispatcherServlet招异常处理器进行异常的处理 SpringMVC的异常处理 异常处理 第一步：自定义异常类 12345678910111213141516171819202122232425/** * Created with IntelliJ IDEA. * * @author: MR.WU * @date: 2020/4/2 17:16 * @desc: 自定义异常类 */public class MyException extends Exception&#123; // 存储提示信息 private String message; public MyException(String message) &#123; this.message = message; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 第二步：自定义异常处理器 123456789101112131415161718192021222324252627282930313233/** * Created with IntelliJ IDEA. * * @author: MR.WU * @date: 2020/4/2 17:22 * @desc: 异常处理器 */public class MyExceptionResolver implements HandlerExceptionResolver &#123; /** * 处理异常业务逻辑 * @param httpServletRequest * @param httpServletResponse * @param o * @param e * @return */ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; // 获取异常对象 MyException me = null; if(e instanceof MyException)&#123; e = (MyException)me; &#125;else &#123; e = new MyException("系统正在维护"); &#125; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); mv.addObject("errorMsg",e.getMessage()); mv.setViewName("error"); return mv; &#125;&#125; 第三步：配置异常处理器 12&lt;!--配置异常处理器--&gt; &lt;bean id="myExceptionResolver" class="com.nogizaka.exception.MyExceptionResolver"&gt;&lt;/bean&gt; SpringMVC中的拦截器 Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 自定义拦截器：实现HandlerInterceptor接口 拦截器的实现 第一步：编写拦截器类：实现HandlerInterceptor接口 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion方法是在JSP执行后执行 request或者response不能再跳转页面了 第二步：配置拦截器 123456789101112&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--配置拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path="/user/*"/&gt; &lt;!--不要拦截的方法 &lt;mvc:exclude-mapping path=""/&gt;--&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class="com.nogizaka.interceptor.MyInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;]]></content>
      <tags>
        <tag>spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2020%2F04%2F02%2FSpring%2F</url>
    <content type="text"><![CDATA[SpringSpring概述 Spring是分层的JavaSE/EE应用full-stack轻量级开源框架，以IoC和AOP为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。 Spring的优点 方便解耦，简化开发 AOP编程支持 声明式事务支持 方便程序的测试 方便集成各种优秀的框架 降低JavaEE API的使用难度 Spring体系结构 核心容器：Beans、Core、Context、SpEL Spring Bean：被Spring IoC容器初始化、装配、管理的Java对象 程序耦合及解耦 耦合（Coupling）：模块及关联程度的度量。程序之间的依赖性。 内聚：同一个模块内的各个元素之间彼此结合的紧密程度 （1）内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 （2）公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 （3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 （4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合 （5）标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。 （6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 （7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 解耦的思路 使用反射来创建对象，避免使用new关键字 通过读取配置文件，获取要创建对象的全限定类名 工厂模式解耦： IoC Inverse Of Control：控制反转，把创建对象的权利交给框架。它包括依赖注入和依赖查找。 IoC：可以消减计算机程序的耦合 Spring快速入门 第一步：配置依赖坐标 第二步：在类的跟路径创建xml配置文件 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 第三步：让spring管理资源 bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中 id 属性：对象的唯一标识。 class 属性：指定要创建对象的全限定类名 12&lt;bean id="accountService" class="com.nogizaka.service.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;bean id="accountDao" class="com.nogizaka.dao.AccountDaoImpl"&gt;&lt;/bean&gt; 第四步：从容器中获取对象 获取Spring的IoC核心容器，并根据id获取对象 12345// 1. 获取核心容器ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");// 2. 获取Bean对象AccountService accountService = ac.getBean("accountService", AccountService.class);AccountDao accountDao = (AccountDao) ac.getBean("accountDao"); ApplicationContext接口的实现类 ApplicationContext三个常用实现类 ClassPathXmlApplicationContext：可以加载类路径下的配置文件，要求配置文件必须在类路径下，不在的化，加载不了 FileSystemXmlApplicationContext：可以加载磁盘任意路径下的配置文件（必须有访问权限） AnnotationConfigApplicationContext；用于读取注解，创建容器。 BeanFactory 和 ApplicationContext 的区别 BeanFactory：是Spring容器中的顶层接口。 它在构建核心容器时，创建对象采取的策略是延迟加载的方式，什么时候用什么时候创建 适用多例对象 ApplicationContext：是BeanFactory的子接口。 它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。即只要一读取配置文件，默认情况下就会创建对象。 适用单例对象 Spring对Bean的管理 bean标签 作用：用于配置对象让spring来创建 属性： id：给对象在容器中提供一个唯一表示符，用于获取对象 class：指定类的全限定类名，用于反射创建对象，默认情况下调用无参构造函数 scope：指定对象的作用范围 singleton：默认值，单例的 prototype：多例的 request：Web项目中，Spring创建一个Bean的对象，将对象存入到request域中 session：Web项目中，Spring创建一个Bean的对象，将对象存入到session域中 global session：WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session. init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 创建bean的三种方式 第一种：使用默认构造函数创建，在spring的配置文件中使用bean标签，配以id和class属性之后，且没用其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。 第二种：使用普通工厂中的方法创建对象（实例工厂） 先把工厂的创建交给 spring 来管理。 然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。 factory-method 属性：用于指定实例工厂中创建对象的方法。 12&lt;bean id="工厂类" class="工厂类全限定类名"&gt;&lt;/bean&gt; &lt;bean id="要被工厂创建的对象" factory-bean="工厂类" factory-method="工厂类的生产方法"&gt;&lt;/bean&gt; 第三种：使用工厂中的静态方法创建对象（静态工厂） 1&lt;bean id="要被工厂创建的对象" class="工厂类全限定类名" factory-method="生产对象的静态方法"&gt;&lt;/bean&gt; bean对象的作用范围 bean标签的scope属性：用于指定bean的作用范围 singleton：单例的，默认值 prototype：多例的 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围） bean对象的生命周期 单例对象 出生：当容器创建时对象出生（加载完配置文件立即创建） 活着：只要容器在，对象存活 死亡：容器销毁，对象消亡 单例对象的生命周期和容器相同 多例对象 出生：当我们使用对象时spring框架创建 活着：对象只要时在使用过程就一直存活。 死亡：当对象长时间不用，且没用别的对象引用时。由Java的垃圾回收器回收 依赖注入 概念：Dependency Injection 。它是 spring 框架核心 ioc 的具体实现。 我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，当前类需要用到其他类的对象时，由spring为我们提供，我们只需要在配置文件中说明。 ioc 解耦只是降低他们的依赖关系，但不会消除。 依赖关系的维护，称为依赖注入 例子：在Spring框架下，当Bean实例 A运行过程中需要引用另外一个Bean实例B时，Spring框架会创建Bean的实例B，并将实例B通过实例A的构造函数、set方法、自动装配和注解方式注入到实例A，这种注入实例Bean到另外一个实例Bean的过程称为依赖注入。 能注入的数据： 基本类型和String 其他bean类型（在配置文件或注解配置过的bean） 复杂类型/集合类型 注入的方式： 第一种：使用构造函数注入 第二种：使用set方法注入 第三种：使用注解注入 构造函数注入 使用的标签：constructor-arg 标签出现的位置；bean标签内部 标签中的属性： type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：指定要注入的数据在构造函数参数列表的索引位置 name：指定要注入的数据在构造函数中的名称 value：用于提供基本类型和String 类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的IoC核心容器中出现过的bean对象 优势：在注入数据时，注入数据是必须的操作，否则对象无法创建成功（因为没用无参构造函数） 缺点：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，为了创建对象，也必须提供 123456&lt;bean id="accountService" class="com.nogizaka.service.AccountServiceImpl"&gt; &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; set方法注入 使用的标签：property 标签出现的位置；bean标签内部 标签中的属性： name：指定要注入时所调用的set方法名称（属性名） value：用于提供基本类型和String 类型的数据 ref：用于指定其他的bean类型数据。 优点：创建对象时没用明确的限制，可以直接使用默认构造函数 缺点：如果由某个成员必须有值，则获取对象时有可能set方法没有执行。 123456&lt;bean id="accountService" class="com.nogizaka.service.AccountServiceImpl"&gt; &lt;property name="name" value="张三"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 复杂类型/集合的注入 用于给List结构集合注入的标签：list array set 用于给Map结构集合注入的标签：map props 在注入集合数据时，只要结构相同，标签可以互换 12345678910&lt;bean id="accountService" class="com.nogizaka.service.AccountServiceImpl"&gt; &lt;property name="myStrs"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; Spring注解Spring IoC的常用注解1234&lt;!--xml配置--&gt;&lt;bean id="" class="全限定类名" scope="作用范围" init-method="" destroy-method=""&gt; &lt;property name="" value="" | ref=""&gt;&lt;/property&gt;&lt;/bean&gt; 创建对象：和XML配置文件中编写一个&lt;bean&gt;标签实现的功能一样 注入数据：和在XML配置文件中的bean标签中写一个&lt;property&gt;标签的作用一样 改变作用范围：和在bean标签中使用scope属性实现功能一样 生命周期：和在bean标签中使用init-method和destroy-method的作用一样 使用注解准备12345678910111213&lt;!--使用注解时，需要告诉spring在创建容器时需要扫描的保，配置所需要的标签不是在beans的约束中，而是在一个名称为context名称空间和约束中--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="要扫描的全限定包名"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 一、创建对象的注解@Component 作用：用于把当前类对象存入spring容器中。相当于在 xml 中配置一个 bean。 属性： value：用于指定bean的id。不写时默认是当前类名（首字母小写） @Controller、@Service、@Repository 功能和属性和@Component一样，可相互替换 @Controller：一般用在表现层 @Service：一般用在业务层 @Repository：一般用在持久层 二、依赖注入的注解@Autowired 作用：自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。 当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 出现位置：可以是变量上，也可以是方法上 注意：在使用注解注入时，set方法就不是必需。如果IoC容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 @Qualifier 作用：在按照类型注入的基础之上，再按照名称注入。它给类成员注入时不能单独使用（配合@Autowired使用）。但是在给方法参数注入时可以单独使用。 属性： value：指定注入bean的id @Resource 作用：直接按照bean的id注入。可以独立使用 属性： name：用于指定bean的id 注意： 省略name： 注解标注set方法时省略name属性，如setXXX()，则name值默认为xXX，去掉“set”，首字母小写。 注解直接标注变量时省略name属性，则那么name值默认与所标注变量名相同。 如@Resource省略name属性后，按其默认规则没有找到所需要注入的Bean时，则采用byType的方式寻找，即寻找与所标注set方法参数类型或所标注变量类型相匹配的Bean，如有唯一匹配则直接注入，如有多个匹配，则抛出异常。 @Autowired、@Qulifier、@Resource只能注入其他bean类型的数据，基本数据类型和String类型的数据无法使用该注解。集合类型的注解只能由XML配置文件实现。 @Value 作用：用于注入基本类型和String类型的数据 属性： value：用于指定数据的值，它可以使用Spring中的SpEL(Spring的EL表达式${表达式}) 三、作用范围的注解@Scope 作用：用于指定bean的作用范围 位置：类上、方法上 属性： value；指定范围的取值。常用取值：singleton、prototype 四、生命周期的注解@PostConstruct 作用：用于指定初始化方法 @PreDestroy 作用：用于指定销毁方法 新注解@Configuration 作用：指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration 注解的类.class) 位置：类上 属性： value：用于指定配置类的字节码 @ComponentScan 作用：用于通过注解指定spring在创建容器时要扫描的包 位置：类上 属性： value：它和basePackages的作用一样，都是用于指定创建容器时要扫描的包。 等价于：&lt;context:component-scan base-package=&quot;com.noizaka&quot;/&gt; @Bean 作用：用于把当前方法的返回值作为bean对象存入spring的IoC容器中 位置；方法上 属性： name：用于指定bean的id,当不屑时，默认值时当前方法的名称 当我们使用注解配置时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象，查找的方式和Autowired注解的作用一样 @Import 作用：用于导入其他的配置类 属性： value：用于指定其他配置类的字节码，当我们使用Import的注解后，有Import注解的累就是父配置类，导入的都是子配置类 @PropertySource 作用：用于指定properties文件的位置 属性： value：指定文件的名称和路径。关键字：classpath，表示类路径下@PropertySource(&quot;classpath:jdbcConfig.properties&quot;) Spring整合Junit 导入spring整合junit坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的（@RunWith(SpringJuni4ClassRunner.class)） 告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置 @ContextConfiguration locations：指定xml文件的位置，加上classpath关键字，表示在类路径下 classes：指定注解类所在地位置 AOP概念 AOP：Aspect Oriented Programming。面向切面编程 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 作用及优势 作用：在程序运行期间，不修改源码对已有方法进行增强 优势： 减少重复代码 提高开发效率 维护方便 AOP的实现 两种动态代理技术 开发阶段（我们做的） 编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求 把公用代码抽取出来，制作成通知。（开发阶段最后再做） 在配置文件中，声明切入点与通知间的关系，即切面。 运行阶段（Spring 框架完成的） Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 动态代理 特点：字节码随用随创建，随用随加载 作用：不修改源码的基础上对方法的增强 分类 基于接口的动态代理 基于子类的动态代理 基于接口的动态代理 涉及的类：Proxy 提供者：JDK官方 如何创建代理对象 使用Proxy类中的newProxyInstance方法 创建代理对象的要求：被代理类最少实现一个接口，如果没有则不能使用 newProxyInstance方法的参数： ClassLoader：类加载器。用于加载代理对象字节码，和被代理对象使用相同的类加载器。被代理对象.getClass().getInterfaces() Class[]：字节码数组。它是让代理对象和被代理对象有相同的方法。被代理对象.getClass().getInterfaces() InvocationHandler：提供增强的代码。它是让我们写如何代理。一般都是一个该接口的实现类，通常情况下是匿名内部类，但不是必须。 invoke方法：执行被代理对象的任何接口方法都会经过该方法 proxy：代理对象的引用 method：当前执行的方法 args：当前执行方法所需的参数 return：和被代理对象有相同的返回值 匿名内部类访问外部成员，外部成员必须被final修饰 基于子类的动态代理 涉及的类：Enhancer 提供者：第三方CGLib库 如何创建代理对象 使用Enhancer类中的create方法 创建代理对象的要求：被代理类不能是最终类 create方法的参数： Class：字节码。它是用于指定被代理对象的字节码 Callback：用于提供增强的代码。我们一般写的都是该接口的子接口实现类：MethodInterceptor(方法拦截器) intercept方法：执行被代理对象的任何方法都会经过该方法 proxy：代理对象的引用 method：当前执行的方法 args：当前执行方法所需的参数 methodProxy：当前执行方法的代理对象 Spring中的AOP 代理的选择：在Spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。使用了接口，则用Proxy,没有使用接口，则用Cglib库 术语 Joinpoint：连接点。指那些被拦截到的点，在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。 Pointcut：切入点。指我们要对哪些Joinpoint进行拦截的定义 Advice：通知/增强。指拦截到Joinpoint之后所要做的事情就是通知 通知的类型： 前置通知：在某个方法之前执行 实现MethodBeforeAdvice接口 后置通知：在某个方法之后执行 实现AfterReturningAdvice接口 异常通知：在某个方法发生异常时执行 实现ThrowsAdvice接口 环绕通知：可以在方法之前、之后、发生异常时执行！MethodInterceptor接口 最终通知：不论目标方法是否发生异常都会执行 Introduction：引介，引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field Target：目标对象。代理的目标对象，即被代理的对象 Weaving：织入。把增强应用到目标对象来创建新的代理对象的过程 Spring采用动态代理织入，而AspectJ采用编译器织入和类装载期织入 Proxy：代理。一个类被AOP织入增强后，就产生一个结果代理类。 Aspect：切面。是切入点和通知（引介）的结合 基于XML的AOP配置 第一步：导入依赖坐标 123456789101112&lt;!--spring--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--解析切入点表达式--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 第二步：创建业务接口 第三步：实现业务接口实现类 第四步：创建通知类 第五步：配置xml 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; spring中基于XML的AOP配置步骤 把通知的Bean也交给spring管理 使用aop:config标签表明开始AOP的配置 使用aop:aspect标签表明配置切面 id ： 给切面提供一个唯一标志 ref ： 指定通知类bean的id 在aop:aspect标签的内部使用对应的标签来配置通知的类型 aop:before ： 表示配置前置通知 method属性 ： 指定哪个方法使用前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution(表达式） 标准表达式：访问修饰符 返回值 全类名.方法名(参数列表) 全通配写法：* *..*.*(..) 访问修饰符可以省略 返回值可以使用通配符，表示任意返回值 包名可以使用通配符，表示任意包。但是，有几级包，就需要写几个*. 包名可以使用..表示当前包及其子包 类名和方法名都可以使用通配符 参数列表： 基本类型直接写名称 引用类型写包名.类名的方式 可以使用通配符表示任意类型，但必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 实际项目中一般切入到业务层实现类下的所有方法* com.nogillc.service.impl.*.*(.. ) 12345678910111213&lt;!--配置Spring的IOC。把Service对象配置进来--&gt;&lt;bean id="accountService" class="com.nogillc.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!--配置logger类--&gt;&lt;bean id="logger" class="com.nogillc.utils.Logger"&gt;&lt;/bean&gt;&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!--配置通知的类型，并且建立通知的方法和切入点方法的关联--&gt; &lt;aop:before method="printLog" pointcut="execution(public void com.nogillc.service.impl.AccountServiceImpl.saveAccount())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 其他几种通知类型 前置通知：&lt;aop:before&gt; 后置通知：&lt;aop:returning&gt; 异常通知：&lt;aop:throwing&gt; 最终通知：&lt;aop:after&gt; 环绕通知：&lt;aop:around&gt; 通用化切入点表达式 配置切入点表达式 id属性用于指定表达式唯一的标识，expression属性用于指定表达式内容 此标签写在aop:aspect标签内部，只能当前切面使用 它还可以写在aop:aspect标签外部（但必须在aop:aspect切面标签之前），此时就变成了所有切面可用 1234567&lt;!--配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!--配置通知的类型，并且建立通知的方法和切入点方法的关联--&gt; &lt;aop:before method="printLog" pointcut-ref="pc"&gt;&lt;/aop:before&gt; &lt;!--配置切入点表达式 id属性用于指定表达式唯一的标识，expression属性用于指定表达式内容--&gt; &lt;aop:pointcut id="pc" expression="execution(public void com.nogillc.service.impl.AccountServiceImpl.saveAccount())"/&gt; &lt;/aop:aspect&gt; 环绕通知 aop:around：作用：用于配置环绕通知属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用说明：它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意：通常情况下，环绕通知都是独立使用的 spring 框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。 在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。 基于注解的AOP配置 配置spring创建容器要扫描的包 配置spring开启注解AOP的支持 1234&lt;!--配置spring创建容器要扫描的包--&gt;&lt;context:component-scan base-package="com.nogillc"&gt;&lt;/context:component-scan&gt;&lt;!--配置spring开启注解AOP的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; @Aspect ：声明当前类是一个切面类 @Before 作用：把当前方法看成是前置通知。 属性：value：用于指定切入点表达式，还可以指定切入点表达式的引用。 @AfterReturning 作用：把当前方法看成是后置通知。 属性：value：用于指定切入点表达式，还可以指定切入点表达式的引用。 @AfterThrowing 作用：把当前方法看成是异常通知。 属性：value：用于指r定切入点表达式，还可以指定切入点表达式的引用 @After 作用：把当前方法看成是最终通知。 属性：value：用于指定切入点表达式，还可以指定切入点表达式的引用 @Around 作用：把当前方法看成是环绕通知。 属性：value：用于指定切入点表达式，还可以指定切入点表达式的引用 @Pointcut 作用：指定切入点表达式 属性：指定表达式的内容 123456789101112131415161718192021222324252627@Pointcut("execution(* com.nogillc.service.impl.*.*(..))")private void pt1() &#123;&#125;/*环绕通知*/@Around("pt1()")//注意：千万别忘了写括号public Object transactionAround(ProceedingJoinPoint pjp) &#123;//定义返回值Object rtValue = null;try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit();&#125;catch(Throwable e) &#123;//异常通知：回滚事务rollback();e.printStackTrace();&#125;finally &#123;//最终通知：释放资源release();&#125;return rtValue; 不使用 XML 的配置方式 @EnableAspectJAutoProxypublic 1234@Configuration@ComponentScan(basePackages="com.nogillc")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125; Spring中的JdbcTemplate 作用：用于和数据库交互，实现对表的CRUD操作 常用方法： 查询：query 更新：update 环境搭建 导入坐标 12345678910111213&lt;!--spring jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring tx事务管理--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置xml 使用spring内置数据源 123456789101112131415161718&lt;!--配置账户的持久层--&gt;&lt;bean id="accountDao" class="com.nogibingo.dao.impl.AccountDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--jdbc template--&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--dataSource spring内置数据源--&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/demo"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt; 抽取持久层重复代码方法一：在Dao类中定义JdbcTemplate 将JdbcTemplate声明为私有变量，然后进行自动注入 该方法适合注解配置，用xml进行配置较为麻烦 方法二：让Dao类继承JdbcDaoSupport JdbcDaoSupport 是 spring 框架为我们提供的一个类，该类中定义了一个 JdbcTemplate 对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源 包：import org.springframework.jdbc.core.support.JdbcDaoSupport; 该方法不适合注解配置，适合xml配置 Spring中的事务控制 JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计业务层的事务处理解决方案。 spring 框架为我们提供了一组事务控制的接口。这组接口是在spring-tx中。 spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。 事务控制API PlatformTransactionManager 获取事务状态信息：TransactionStatus getTransaction(TransactionDefinition definition) 提交事务：void commit(TransactionStatus status) 回滚事务：void rollback(TransactionStatus status) 在开发种使用它的实现类 DataSourceTransactionManager：使用SpringJDBC或iBatis进行持久化数据 HibernateTransactionManager：使用Hibernate进行持久化数据 TransactionDefinition 获取事务对象名称：String getName() 获取事务隔离级别：int getIsolationLevel() 获取事务传播行为：int getPropagationBehavior() 获取事务超时时间：int getTimeout() 获取事务是否只读：boolean isReadOnly() 事务隔离级别：默认使用数据库的隔离级别，4种 读未提交 读已提交，解决脏读 重复读，解决脏读、不可重复读 串行化，解决脏读、不可重复读、幻读 事务的传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUES_NEW：新建事务，如果当前在事务中，把当前事务挂起 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 是否是只读事务：建议查询时设置为只读。 TransactionStatus：此接口提供的是事务具体的运行状态 刷新事务：void flush() 获取是否存在存储点：boolean hasSavepoint() 获取事务是否完成：boolean isCompleted() 获取事务是否为新的事务：boolean isNewTransaction() 获取事务是否回滚：boolean isRollbackOnly() 设置事务回滚：void setRollbackOnly() 基于XML的AOP实现事务控制 配置事务管理器 配置事务通知：导入事务的约束xmlns:tx,同时也需要xmlns:aop 使用tx:advice标签配置事务通知 属性： id：事务通知的唯一标识 transaction-manager:给事务通知提供一个事务管理器引用 配置AOP中的通用切入点表达式 建立事务通知h和切入点表达式的对应关系 配置事务的属性：是在事务的通知tx:advice标签内部 1234567891011121314151617181920212223242526&lt;!--配置事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置事务的通知--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!--事务的属性 isolation： 指定事务的隔离级别 默认值是DEFAULT.表示使用数据库的默认隔离级别 propagation（传播）： 用于指定事务的传播行为。默认值是REQUIRED,表示一定会有事务，增删改的选择。查询可以用SUPPORTS read-only：用于指定事务是否只读。只有查询方法才能设置为true,默认值是false，表示读写 timeout：用于指定事务的超时时间，默认值-1，永不超时 rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值，表示任何异常都回滚 no-rollback-for ：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，表示任何异常都回滚 --&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.nogillc.service.impl.*.*(..))"/&gt; &lt;!--建立切入点表达式h和事务通知的对应关系--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 基于注解的AOP实现事务控制 导入约束 xmlns:aop xmlns:tx xmlns:context 配置事务管理器 开启Spring对注解事务的支持 在需要事务支持的地方使用@Transactional 123456&lt;!--配置事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--开启spring对注解事务的支持--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"&gt;&lt;/tx:annotation-driven&gt; 不使用xml的配置 1234567@Configuration//注解类@ComponentScan("com.nogi")//要扫描的包@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;)//导入其他类@PropertySource("jdbcConfig.properties")//指定配置文件@EnableTransactionManagement//开启事务注解支持public class SpringConfiguration &#123;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决IDEA 2019.3 maven pom.xml依赖无法自动提示]]></title>
    <url>%2F2020%2F03%2F23%2F%E8%A7%A3%E5%86%B3Maven%E7%9A%84POM-xml%E6%97%A0%E6%B3%95%E6%8F%90%E7%A4%BA%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[问题原因 Maven本地仓库无法索引，更新远程仓库失败。 下图为正常更新后状态 解决方法第一步 查看本地Maven的配置文件是否配置了镜像（一般大家会配置阿里云镜像） 如果你配置的地址是&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;，修改该url地址（此url访问阿里云的镜像下的 .index 目录为错误路径） 正确镜像配置如下 123456 &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 第二步 执行完第一步后，先进行update测试，如果update成功。则无需后面步骤。（Update时，） 如果不成功，则是网络问题，此时需要使用代理网络（这里不提供科学上网工具） 第三步 打开科学上网工具，设置为全局Global模式 打开IE浏览器的Internet选项 打开局域网设置 查看代理设置端口号（第一个是主机ip，端口号是根据你的科学上网工具决定的，也就是代理端口，也可以直接通过你的代理工具查到该信息） 下图是使用代理工具也可以查询到端口 第四步 获取代理的IP和端口后，打开IDEA的maven设置。找到Importing 添加使用代理配置。 主机号为127.0.0.1 和 端口号设为你在第三步查到的数据即可 1-DproxySet=true -DproxyHost=127.0.0.1 -DproxyPort=7890 第五步 重启IDEA 在开启全局代理上网的情况下，再更新一次Maven远程索引 执行上述步骤，本人测试更新成功，如有其他问题可以进行讨论，如遇Jar包无法下载，可以将DproxySet设置为false，或回滚上述所有步骤可解决]]></content>
      <tags>
        <tag>maven</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F2020%2F03%2F09%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis概念框架 是软件开发过程中的一套解决方案，不同的框架解决不同的问题 优点：框架封装了很多细节，使开发者可以使用极简的方式实现功能，大大提高开发效率 三层架构 表现层：用于展示数据，Spring MVC 业务层：处理业务需求，Spring 持久层：操作数据库，Mybatis 持久层技术解决方案 JDBC技术： Connection PreparedStatement ResultSet Spring的JdbcTemplate：Spring中对JDBC的简单封装 Apache的DBUtils：对JDBC的简单封装 JDBC是规范，以上这些只是工具类 Mybatis Mybatis是一个优秀的基于java的持久层框架，它内部封装了JDBC，使开发者只需要关注SQL语句本身，而不需要花费精力去加载驱动、创建连接、创建Statement等复杂的过程。 Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由Mybatis框架执行SQL并将结果映射为Java对象并返回 采用 ORM 思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 ORM思想:Object Relational Mapping 对象关系映射，把数据库表和实体类及实体类的属性对应起来，通过操作实体类完成数据库表操作 Mybatis入门Mybatis环境搭建 第一步：创建maven工程并导入坐标 123456 &lt;!--Mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt; 第二步：创建实体类和dao的接口 第三步：创建Mybatis的主配置文件SqlMapConfig.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- Mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置Mysql的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis_demo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/nogizaka/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 第四步：创建映射配置文件UserDao.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.nogizaka.dao.UserDao"&gt;&lt;!-- 配置查询所有 --&gt;&lt;!-- id 对应 查询方法名称--&gt;&lt;!-- resultType 对应 查询结果封装的对象--&gt;&lt;select id="findAll" resultType="com.nogizaka.domain.User"&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; 注意 在Mybatis中把持久层的操作接口名称和映射文件也叫做：Mapper Mybatis的映射配置文件位置必须和dao接口的包结构相同 映射配置文件的mapper标签namespace属性的取值**必须是dao接口的全限定类名，不能使用别名 映射配置文件的操作配置(select)，id属性取值必须是dao接口的方法名 创建步骤 第一步： 读取配置文件 第二步： 创建SqlSessionFactory工厂 第三步： 使用工厂生产SqlSession对象 第四步： 使用SqlSession创建Dao接口的代理对象 第五步： 使用代理对象执行方法 第六步： 释放资源 1234567891011121314151617// 1. 读取配置文件InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");// 2. 创建SqlSessionFactory工厂SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(in);// 3. 使用工厂生产SqlSession对象SqlSession session = factory.openSession();// 4. 使用SqlSession创建Dao接口的代理对象UserDao userDao = session.getMapper(UserDao.class);// 5. 使用代理对象执行方法List&lt;User&gt; users = userDao.findAll();for (User user : users) &#123; System.out.println(user);&#125;// 6. 释放资源session.close();in.close(); 注意 （第一步）读取配置文件：直接写绝对路径和相对路径都不合适，一般采用以下两种方式 使用类加载器，它只能读取类路径的配置文件 使用ServletContext对象的getRealPath()获取全局路径 （第二步）创建SqlSessionFactory：使用了构建者模式 构建者模式：把对象的创建细节隐藏，使用者直接调用方法即可拿到对象 （第三步）使用工厂生产SqlSession对象：使用了工厂模式 工厂模式：降低类之间的依赖关系，降低耦合度 （第四步）使用SqlSession对象创建Dao的代理对象：使用了代理模式 代理模式：在不修改源码的基础上，对已有方法进行增强 不要忘记在映射配置中告知mybatis要封装到哪个实体类中 配置的方式：在resultType属性指定实体类的全限定类名 使用注解 在Dao接口的方法上，使用@Select(&quot;..&quot;)注解，并且指定执行SQL语句 同时需要在SqlMapConfig.xml中的mapper配置中，使用class属性指定Dao接口的全限定类名 CRUD1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;mapper namespace="com.nogizaka.dao.UserDao"&gt; &lt;!--查询所有--&gt; &lt;select id="findAll" resultType="com.nogizaka.domain.User"&gt; select * from user; &lt;/select&gt; &lt;!--parameterType 参数类型--&gt; &lt;!--插入数据--&gt; &lt;insert id="addUser" parameterType="com.nogizaka.domain.User"&gt; &lt;!-- 配置插入操作后，获取插入数据的id值--&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,address,sex,birthday) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;!--更新数据--&gt; &lt;update id="updateUser" parameterType="com.nogizaka.domain.User"&gt; update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;, address=#&#123;address&#125; where id=#&#123;id&#125;; &lt;/update&gt; &lt;!--删除数据--&gt; &lt;delete id="delUser" parameterType="Integer"&gt; delete from user where id=#&#123;id&#125;; &lt;/delete&gt; &lt;!--通过ID查询--&gt; &lt;select id="findById" parameterType="int" resultType="com.nogizaka.domain.User"&gt; select * from user where id=#&#123;id&#125;; &lt;/select&gt; &lt;!--根据姓名模糊查询--&gt; &lt;select id="findByName" parameterType="String" resultType="com.nogizaka.domain.User"&gt; &lt;!--select * from user where username like #&#123;name&#125;--&gt; select * from user where username like '%$&#123;value&#125;%'; &lt;/select&gt; &lt;!--查询总用户数--&gt; &lt;select id="findTotal" resultType="int"&gt; select count(id) from user; &lt;/select&gt;&lt;/mapper&gt; #{}与${}的区别 #{}表示一个占位符号 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 ${}表示拼接 sql 串 通过${}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 获取新增用户id的返回值 使用&lt;selectKEy&gt; 12345678&lt;!--插入数据--&gt;&lt;insert id="addUser" parameterType="com.nogizaka.domain.User"&gt; &lt;!-- 配置插入操作后，获取插入数据的id值--&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,address,sex,birthday) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);&lt;/insert&gt; arameterType Mybatis使用OGNL表达式解析对象字段的值，#{}或者${}中为Pojo的属性名称 OGNL表达式：Object Graphic Navigation Language 对象导航图语言 通过对象的取值方法来获取数据，在写法上把get和省略了 类中获取名称：user.getUsername() OGNL中获取名称：user.username mybatis在parameterType中已经提供了属性所属的类，所以此时不需要写对象名 标签中的属性Select标签中的属性 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 fetchSize 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。 Insert, Update, Delete 标签的属性 属性 描述 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器推断出具体传入语句的参数，默认值为未设置（unset） 。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true（对于 insert、update 和 delete 语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 ResultMap 查询的列名和实体类的属性名称不一致: 方法一：使用sql语言中的起别名，如 Select id as userId，（执行效率高） 方法二：resultMap标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。（开发效率高） 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 1234567891011&lt;resultMap id="userMap" type="com.nogizaka.domain.User"&gt; &lt;!--主键字段的对应--&gt; &lt;id property="userId" column="id"&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property="userSex" column="sex"&gt;&lt;/result&gt; &lt;result property="useraddress" column="address"&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user;&lt;/select&gt; SqlMapConfig中的配置SqlMapConfig.xml配置内容和顺序1234567891011121314151617-properties（属性） --property-settings（全局配置参数） --setting-typeAliases（类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers（映射器） --mapper --package properties属性 properties属性： 可以在标签内部配置连接数据库的信息，也可通过属性引用外部配置文件信息 resource属性： 用于指定配置文件的位置，是按照类路径的写法，并且必须存在于类路径下 url属性；要求按照url的写法来写地址：协议 主机 端口 URI 123456789101112131415161718&lt;!--方法一：标签内部配置连接数据库的信息--&gt;&lt;properties&gt;&lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis_demo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/properties&gt;&lt;!--方法二：通过标签属性引用外部配置文件信息--&gt;&lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt;&lt;!--此时我们的 dataSource 标签就变成了引用上面的配置--&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; typeAliases属性 typeAliases必须按照configuration的配置顺序进行配置 配置domain中类的别名 type属性：指定是实体类全限定类名 alias属性：指定别名，指定别名后，不区分大小写 package ：用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写 mapper中的package 标签是用于指定dao接口所在的包，当指定了之后就不需要再写mapper已经resource或者class属性了 配置别名后，domain中的实体类都可以用简写，不区分大小写123&lt;typeAliases&gt; &lt;package name="com.nogi.domain"/&gt;&lt;/typeAliases&gt; mappers（映射器） &lt;mapper resource=&quot; &quot; /&gt; 使用相对于类路径的资源如：&lt;mapper resource=&quot;com/nogi/dao/UserDao.xml&quot; /&gt; &lt;mapper class=&quot; &quot; /&gt; 使用 mapper 接口类路径如：&lt;mapper class=&quot;com.nogi.dao.UserDao&quot;/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 &lt;package name=&quot;&quot;/&gt; 注册指定包下的所有 mapper 接口如：&lt;package name=&quot;com.nogi.mybatis.mapper&quot;/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 1234&lt;!--写法不同效果相同--&gt;&lt;mapper resource="com/nogi/dao/UserDao.xml"&gt;&lt;/mapper&gt;&lt;mapper class="com.nogi.dao.UserDao"&gt;&lt;/mapper&gt;&lt;package name="com.nogi.dao"/&gt; Mybatis连接池 mybatis连接池提供了3种方式的配置 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式 type属性的取值： POOLED ：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现 UNPOOLED ：采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没用使用池的思想 JNDI ：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的。如果不是web或者maven的war工程，是不能使用，tomcat采用dbcp连接池 Mybatis事务控制 Mybatis中的事务提交：SqlSession对象的commit()方法 Mybatis中的事务回滚：SqlSession对象的rollback()方法 设置自动提交：SqlSessionFactory对象的openSession(boolean autocommit) Mybatis基于XML配置的动态SQL语句if标签 原理：sql语句的拼接 test属性：判断条件 123456789101112&lt;!--根据条件查询--&gt;&lt;!--where 1=1 可以防止SQL语句报错,一般用于动态SQL拼接和查询表结构--&gt;&lt;select id="findByProp" resultMap="userMap" parameterType="USER"&gt; SELECT * FROM USER WHERE 1=1 &lt;!--test为判定内容--&gt; &lt;if test="uname!=null"&gt; AND USERNAME LIKE #&#123;uname&#125; &lt;/if&gt; &lt;if test="usex!=null"&gt; AND SEX=#&#123;usex&#125; &lt;/if&gt;&lt;/select&gt; where标签 简化上面 where 1=1 的条件拼装，我们可以采用&lt;where&gt;标签来简化开发 123456789101112&lt;select id="findByProp" resultMap="userMap" parameterType="USER"&gt; SELECT * FROM USER &lt;where&gt; &lt;!--test为判定内容--&gt; &lt;if test="uname!=null"&gt; AND USERNAME LIKE #&#123;uname&#125; &lt;/if&gt; &lt;if test="usex!=null"&gt; AND SEX=#&#123;usex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach标签 &lt;foreach&gt;标签用于遍历集合，它的属性： collection:代表要遍历的集合元素，注意编写时不要写#{} open:代表语句的开始部分 close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名 sperator:代表分隔符 SQL语句：SELECT 字段 FROM 表名 WHERE id IN (?) 123456789101112&lt;!--传入多个 id 查询用户信息，根据一组条件集合查询--&gt;&lt;select id="findByIDS" resultMap="userMap" parameterType="USER"&gt; SELECT * FROM USER &lt;where&gt; &lt;if test="ids!=null and ids.size()&gt;0"&gt; &lt;foreach collection="ids" open="ID IN (" close=")" item="vid" separator=","&gt; #&#123;vid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; Mybatis多表操作ResultMap1234567891011121314&lt;!--column不做限制，可以为任意表的字段，而property须为type 定义的pojo属性--&gt;&lt;resultMap id="唯一的标识" type="映射的pojo对象"&gt; &lt;id column="表的主键字段，或者可以为查询语句中的别名字段" jdbcType="字段类型" property="映射pojo对象的主键属性" /&gt; &lt;result column="表的一个字段（可以为任意表的一个字段）" jdbcType="字段类型" property="映射到pojo对象的一个属性（须为type定义的pojo对象中的一个属性）"/&gt; &lt;association property="pojo的一个对象属性" javaType="pojo关联的pojo对象"&gt; &lt;id column="关联pojo对象对应表的主键字段" jdbcType="字段类型" property="关联pojo对象的主键属性"/&gt; &lt;result column="任意表的字段" jdbcType="字段类型" property="关联pojo对象的属性"/&gt; &lt;/association&gt; &lt;!-- 集合中的property须为oftype定义的pojo对象的属性--&gt; &lt;collection property="pojo的集合属性" ofType="集合中的pojo对象"&gt; &lt;id column="集合中pojo对象对应的表的主键字段" jdbcType="字段类型" property="集合中pojo对象的主键属性" /&gt; &lt;result column="可以为任意表的字段" jdbcType="字段类型" property="集合中的pojo对象的属性" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 一对多 12345678910111213141516171819202122&lt;mapper namespace="com.asuka.dao.UserDao"&gt; &lt;resultMap id="userMapAccount" type="com.asuka.domain.User"&gt; &lt;!--主键--&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;!--非主键--&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;!--配置user中accounts集合的映射--&gt; &lt;collection property="accounts" ofType="com.asuka.domain.Account"&gt; &lt;!--主键--&gt; &lt;id property="aid" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="userMapAccount"&gt; SELECT * FROM user u LEFT OUTER JOIN account a ON u.id=a.uid &lt;/select&gt;&lt;/mapper&gt; JNDI JNDI：Java Naming and Directory Interface。是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。 在服务器中注册数据源： 在webapp目录下创建META-INF文件夹 创建context.xml文件 修改SqlMapConfig中的数据源 1234567891011121314151617181920212223242526272829303132333435&lt;!--Context.xml--&gt;&lt;Context&gt;&lt;!-- &lt;Resource name=数据源的名称type=数据源类型auth=数据源提供者maxActive=最大活动数maxWait=最大等待时间maxIdle=最大空闲数username=用户名password=密码driverClassName=驱动类url=连接url字符串/&gt; --&gt;&lt;Resource name="jdbc/mybatis_demo"type="javax.sql.DataSource"auth="Container"maxActive="20"maxWait="10000"maxIdle="5"username="root"password="1234"driverClassName="com.mysql.jdbc.Driver"url="jdbc:mysql://localhost:3306/mybatis_demo"/&gt;&lt;/Context&gt;&lt;!--修改SqlMapConfig配置--&gt;&lt;dataSource type="JNDI"&gt; &lt;property name="data_source" value="java:comp/env/jdbc/mybatis_demo"/&gt;&lt;/dataSource&gt; Mybatis延迟加载 概念：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 优点：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快 缺点：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 多对一、一对一：直接加载 多对多、一对多：延迟加载 使用步骤 在SqlMapConfig配置文件中加入&lt;settings&gt;标签 123456&lt;settings&gt; &lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认为false--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!--任一方法的调用都会加载该对象的所有延迟加载属性,3.4以后默认为false--&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 将原始的关联查询代码改为单表查询 更改关联查询的resultMap内的映射association标签加入懒加载需要的查询条件和sql语句statementId原始resultMap映射 Mybatis缓存一级缓存 指的是Mybatis中SqlSession对象的缓存。 当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块Map结构的区域。当我们在此查询同样的数据，mybatis会优先去数据库查询是否存在。 一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 二级缓存 二级缓存指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession对象共享 使用步骤： 第一步：在 SqlMapConfig.xml 文件开启二级缓存：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 第二步：配置相关的 Mapper 映射文件：&lt;cache/&gt; 第三步：配置 statement 上面的 useCache 属性：&lt;select id=&quot;findAll&quot; resultMap=&quot;userMapAccount&quot; useCache=&quot;true&quot;&gt; 注意： 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 Mybatis注解开发 常用注解 @Insert:实现新增 @Update:实现更新 @Delete:实现删除 @Select:实现查询 @Result:实现结果集封装 @Results:可以与@Result 一起使用，封装多个结果集 @ResultMap:实现引用@Results 定义的封装 @One:实现一对一结果集封装 @Many:实现一对多结果集封装 @SelectProvider: 实现动态 SQL 映射 @CacheNamespace:实现注解二级缓存的使用 @Results 注解 代替的是标签&lt;resultMap&gt; 该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（{@Result（），@Result（）}）或@Results（@Result（）） @Resutl 注解 代替了 &lt;id&gt;标签和&lt;result&gt;标签@Result 中 属性介绍：id 是否是主键字段column 数据库的列名property 需要装配的属性名one 需要使用的@One 注解（@Result（one=@One）（）））many 需要使用的@Many 注解（@Result（many=@many）（））） @One 注解（一对一） 代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One 注解属性介绍： select：指定用来多表查询的 sqlmapper fetchType： 会覆盖全局的配置参数 lazyLoadingEnabled。 使用格式：@Result(column=&quot; &quot;,property=&quot;&quot;,one=@One(select=&quot;&quot;)) @Many 注解（多对一） 代替了&lt;Collection&gt;标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType一般为 ArrayList）但是注解中可以不定义； 使用格式：@Result(property=&quot;&quot;,column=&quot;&quot;,many=@Many(select=&quot;&quot;))]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serializable]]></title>
    <url>%2F2020%2F03%2F08%2FSerializable%2F</url>
    <content type="text"><![CDATA[Serializable接口 java.io.Serializable 序列化接口没有方法或字段，仅用于标识可序列化的语义。 一个类只有实现了Serializable接口，它的对象才能被序列化 序列化 序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。 序列化：把对象转换为字节序列的过程称 反序列化：把字节序列恢复为对象的过程 序列化原因 将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本 按值将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复 要持久化和网络传输就得转为字节流，所以在分布式应用中及设计数据持久化的场景中，就得实现序列化 使用 实现Serializable接口：implements Serializable 定义serialversionUID变量：private static final long serialVersionUID = 1L; 注意 在NoSql数据库中，并没有与我们java基本类型对应的数据结构，所以在往nosql数据库中存储时，我们就必须将对象进行序列化 同时在网络传输中我们要注意到两个应用中javabean的serialVersionUID要保持一致，不然就不能正常的进行反序列化。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2020%2F03%2F08%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis 概念：Redis是一款高性能的NoSQL系列 非关系型数据库 NoSQL：NoSQL = Not Only SQL，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NoSQL和关系型数据库的比较 优点： 成本：NoSQL数据库简单易部署，基本都是开源软件，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：NoSQL数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及NoSQL数据库。 存储数据的格式：NoSQL的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点 维护的工具和资料有限，因为NoSQL是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 非关系型数据库的优势 高性能：性能NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 易扩展：可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。 总结：关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在Nosql数据库中备份存储关系型数据库的数据N 主流的NoSQL产品 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis详解 Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset 应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 下载与安装 官网：https://redis.io 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 Redis操作命令和数据结构 redis存储的是：key,value 格式的数据，其中key都是字符串，value有5种不同的数据结构: 字符串类型 string 哈希类型 hash ： map格式(key,value) 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 String 存储：set key value 获取：get key 删除：del key 哈希类型 Hash 存储：hset key field value 获取： 获取指定的field对应的值：hget key field 获取所有的field和value： hgetall key 删除：hdel key field 列表类型 List 可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： lpush key value：将元素加入列表左边 rpush key value：将元素加入列表右边 获取： 范围获取：lrange key start end 删除： lpop key：删除列表最左边的元素，并将元素返回 rpop key：删除列表最右边的元素，并将元素返回 集合类型 Set 不允许重复元素 存储：sadd key value 获取：smembers key：获取set集合中所有元素 删除：srem key value：删除set集合中的某个元素 有序集合类型 Sorted Set 不允许重复元素，且元素有顺序。每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value 通用命令 查询所有的键：keys * 获取键对应的value的类型：type key 删除指定的key value ：del key 持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置。在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 123456# after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf - **AOF**：日志记录的方式。可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 - 编辑`redis.windwos.conf`文件 1234appendonly no（关闭aof） --&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化 Java客户端：Jedis Jedis：一款java操作redis数据库的工具 步骤 导入Jedis的jar包 获取连接：Jedis jedis = new Jedis(&quot;localhost&quot;,6379); 操作数据库：jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); 关闭连接：edis.close(); 特殊方法： 指定数据过期时间：setex(&quot;key&quot;,time,&quot;value&quot;) JedisPool：Jedis连接池 12345678910111213141516//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10);//1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,"localhost",6379);//2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set("hehe","heihei");//4. 关闭 归还到连接池中jedis.close(); 连接池工具类 1234567891011121314151617181920212223242526272829303132333435public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2020%2F03%2F08%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven概念 Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 功能： jar包管理 构建工程 单元测试 项目部署 构建：从编译、测试、运行、打包、安装 、部署整个过程都交给 maven 进行管理， 安装 下载 配置环境变量 目录结构 bin：存放了maven的命令 boot：存放了一些maven本身的引导程序，如类加载器等 conf：存放了maven的一些配置文件，如 setting.xml 文件 lib：存放了maven本身运行所需的一些jar包 Maven仓库 本地仓库： 修改本地仓库：/conf/settings.xml &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; 远程仓库 中央仓库 Maven项目标准目录结构 src/main/java ：核心代码部分 src/main/resources ：配置文件部分 src/test/java ：测试代码部分 src/test/resources ：测试配置文件 src/main/webapp ；页面资源 Maven指令 指令 含义 作用 mvn clean 清理命令 删除 target 目录及内容 mvn compile 编译命令 是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。 mvn test 测试命令 执行 src/test/java 下的单元测试类 mvn package 打包命令 对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包。 mvn install 安装命令 执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库 mvn deploy 发布命令 将maven的web项目部署到远程服务器 Maven生命周期 maven 对项目构建过程分为三套相互独立的生命周期 Clean Lifecycle : 清理生命周期。在进行真正的构建之前进行一些清理工作。 Default Lifecycle : 默认生命周期。构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle : 站点生命周期。生成项目报告，站点，发布站点。 Maven概念模型依赖管理 项目对象模型（Project Object Model） pom.xml 项目信息 项目所依赖的jar包信息 项目运行环境信息，比如：jdk,tomcat等 依赖管理系统（Dependency Management System） 通过maven的依赖管理对项目所依赖的jar包进行统一管理 123456789101112&lt;!-- 依赖关系 --&gt; &lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围：单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 一键构建 项目生命周期：maven 管理项目生命周期过程都是基于插件完成的。 清理 编译 测试 打包 安装 部署 坐标定义 在pom.xml中定义坐标，内容包括：groupId、artifactid、version POM基本配置 12345678910&lt;project &gt; ：文件的根节点 .&lt;modelversion &gt; ： pom.xml 使用的对象模型版本&lt;groupId &gt; ：项目名称，一般写项目的域名&lt;artifactId &gt; ：模块名称，子项目名或模块名称&lt;version &gt; ：产品的版本号 .&lt;packaging &gt; ：打包类型，一般有 jar、war、pom 等&lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description &gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2020%2F03%2F08%2FAjax%26Json%2F</url>
    <content type="text"><![CDATA[AJAX概念 AJAX：ASynchronous JavaScript And XML ，异步的JavaScript和XML 异步和同步：客户端和服务器相互通信的基础上 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要再等待服务器端的响应。服务器处理请求的过程中，客户端可以进行其他的操作 AJAX是一种在 无需重新加载 整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX可以网页实现异步更新。 提升用户体验 实现方式 原生JS实现方式 1234567891011121314151617181920212223242526272829303132333435363738394041 //1.创建核心对象var xmlhttp;if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();&#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125;//2. 建立连接/* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */xmlhttp.open("GET","ajaxServlet?username=tom",true);//3.发送请求xmlhttp.send();//4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText//什么时候获取？当服务器响应成功后再获取//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。xmlhttp.onreadystatechange=function()&#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; JQuery实现方式 $.ajax() 语法：$.ajax({键值对}) 1234567891011121314// 使用$.ajax发送异步请求$.ajax(&#123; url:"ajaxServlet",//请求路径 type:"POST",//请求方式 //data:"username=jack&amp;password=123",//请求参数 data:&#123;"username":"jack","password":123&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert("出错了") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:"text"//设置接收到的响应数据格式&#125;) $.get()：发送get请求 语法：$.get(url, [data], [callback], [type]) 参数： url：请求路径 data：请求参数 callback：回调函数 type：响应结果查询 $.post()：发送post请求 语法：$.post(url, [data], [callback], [type]) 参数： url：请求路径 data：请求参数 callback：回调函数 type：响应结果查询 JSON概念 JSON：JavaScript Object Notation。JavaScript对象表示法 JSON现在多用于存储和交换文本信息的语法。进行数据的传输。 JSON 比 XML 更小、更快，更易解析 语法 基本规则 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 值的取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} null 数据由逗号分隔 花括号保存对象 方括号保存数组 获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 遍历:for in循环 12345678910111213141516171819202122232425// jsonvar person=&#123;name:"飞鸟",age:20,gender:true&#125;// json嵌套数组var people=&#123; person:[ &#123;name:"飞鸟",age:20,gender:true&#125;, &#123;name:"麻衣",age:22,gender:true&#125; ]&#125;// 数组嵌套jsonvar persons=[ &#123;name:"张三",age:24,gender:true&#125;, &#123;name:"李四",age:21,gender:true&#125;, &#123;name:"王五",age:14,gender:false&#125;];// for in遍历for(var i=0;i&lt;persons.length;i++)&#123; var p = persons[i]; for(var key in p)&#123; alert(key+":"+p[key]); &#125;&#125; JSON数据和Java对象的相互转换 JSON解析器 Jsonlib,Gson,fastjson,jackson JSON转Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class) Java对象转换为JSON 使用步骤： 导入jackson相关jar包 创建jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法： writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 writeValueAsString(obj):将对象转为json字符串 注解： @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 复杂java对象转换 List：数组 Map：对象格式一致 案例 校验用户名是否存在 输入用户名 事件：失去焦点 发送ajax请求 服务器响应 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： $.get(type):将最后一个参数type指定为”json” 在服务器端设置MIME类型：response.setContentType(“application/json;charset=utf-8”);//设置响应数据格式]]></content>
      <tags>
        <tag>json</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie&Session]]></title>
    <url>%2F2020%2F03%2F03%2FCookie%26Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie概念 客户端会话技术，将数据保存到客户端 快速入门 创建Cookie对象，绑定数据：new Cookie(String,String) 发送Cookie对象：response.addCookie(Cookie cookie) 获取Cookie对象：Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 Cookie的一些细节 一次可以发送多个Cookie：可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可 Cookie在浏览器中保存的时间 默认：浏览器关闭，Cookie数据被销毁 持久化存储：setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。并指定cookie存活时间，到时间后，自动销毁。 负数：默认值，关闭删除 0：删除cookie信息 Cookie中文数据 tomcat8之前cookie不能直接存储中文数据 解决方法：将中文数据转码–一般采用URL编码 编码：URLEncode.encode(String str,&quot;utf-8&quot;) 解码：URLDecode.decode(String str,&quot;utf-8&quot;) tomcat8之后cookie支持存储中文数据，但是不支持特殊字符(使用URL解决) Cookie数据共享 默认：项目内cookie共享 同一个服务器，多个Web项目：setPath(String path)。设置cookie的获取范围，默认情况下，设置当前的虚拟目录，如果需要共享，可以将Path设置为/ 不同服务器，不同项目：setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie可以共享 例如：setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 Cookie存储数据在客户端浏览器 浏览器对于单个cookie的大小有限制(4KB)以及对同一个域名下的总cookie数量也有限制(20) 作用： cookie一般用于存储少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 Session概念 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门 创建：HttpSession session = request.getSession(); 使用： Object getAttribute(String name) void setAttribute(String name,Object value) void removeAttribute(String name) 实现原理 Session的实现依赖于Cookie（set-cookie:JSESSIONID） Session的一些细节 当客户端关闭后，服务器不关闭，两次获取的Session不是同一个 如果需要相同，可以创建Cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 123Cookie c = new Cookie("JSESSIONID",session.getId());c.setMaxAge(60*60);response.addCookie(c); 当客户端关闭后，服务器关闭后，两次获取的Session不是同一个 为了确保数据不丢失，tomcat会自动完成以下工作 session的钝化：在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化：在服务器启动后，将session文件转化为内存中的session对象 session的销毁 服务器关闭 session对象调用invalidate() session默认失效时间 30min，可以修改配置参数 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; Session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 Session与Cookie的区别 session存储数据在服务器端，cookie在客户端 session没有数据大小限制，cookie有 session数据安全，cookie相对不安全]]></content>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器&监听器]]></title>
    <url>%2F2020%2F03%2F03%2F%E8%BF%87%E6%BB%A4%E5%99%A8%26%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Filter:过滤器概念 当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤 快速入门 定义一个类，实现Filter接口（javax.servlet.filter） 复写方法 配置拦截路径（拦截准备去访问的资源） web.xml 注解（@WebFilter） 123456789101112131415@WebFilter("/*")public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("Filter过滤器被执行了"); // 放行 filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 过滤器细节 web.xml配置 12345678910&lt;filter&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;filter-class&gt;com.nogizaka.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;!--拦截路径--&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下的代码 过滤器生命周期方法 init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter：每一次请求被拦截资源时，会执行。执行多次 destroy：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解 拦截路径配置： 具体资源路径：/index.jsp,只有访问index.jsp资源时，过滤器才会被执行 拦截目录：/user/*，访问/user下的所有资源时，过滤器都会被执行 后缀名拦截：*.jsp，访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/*，访问所有任意资源时，过滤器都会被执行 拦截方式配置： 注解配置：设置dispatcherTypes的属性 REQUEST：默认值，浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml 设置&lt;dispatcher&gt;&gt;&lt;/dispatcher&gt;标签 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器1，过滤器2 过滤器1-&gt;过滤器2-&gt;资源执行-&gt;过滤器2-&gt;过滤器1 过滤器先后顺序： 注解配置：按照类名的字符串比较规则，值小的先执行 web.xml配置：&lt;filter-mapper&gt;谁先定义谁先执行 代理模式 真实对象：被代理的对象 代理对象 代理模式：代理对象 代理 真实对象，达到增强真实对象功能的目的 实现方法： 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 实现步骤： 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance() 使用代理对象调用方法 增强方法 增强方式 增强参数列表 增强返回值类型 增强方法体执行逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ProxyDemo &#123; public static void main(String[] args) &#123; // 1.创建真实对象 Apple apple = new Apple(); // 2. 动态代理增强Apple对象 /* * 三个对象： * 1.类加载器:真实对象.getClass().getClassLoader() * 2.接口数组:真实对象.getClass().getInterfaces() * 3.处理器:使用匿名内部类 new InvocationHandler() * */ SaleComputer proxy_apple = (SaleComputer) Proxy.newProxyInstance(apple.getClass().getClassLoader(), apple.getClass().getInterfaces(), new InvocationHandler()&#123; /* * 代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行 * 参数： * 1. proxy:代理对象 * 2. method:代理对象的调用的方法，被封装为的对象 * 3. args:代理对象调用的方法时，传递的实际参数 * */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 判断是否是sale方法 if(method.getName()=="sale")&#123; // 增强参数 double money = (double) args[0]; money += 1000; // 使用真实对象调用该方法 String obj = (String) method.invoke(apple, money); return obj+"和鼠标"; &#125;else &#123; // 不是sale方法，将实际参数返回 Object obj = method.invoke(apple, args); return obj; &#125; &#125; &#125;); //3.调用方法 String computer = proxy_apple.sale(8000); System.out.println(computer); &#125;&#125; Listener:监听器 概念：web的三大组件之一 事件监听机制 事件 ：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 ServletContextListener：监听ServletContext对象的创建和销毁 方法 void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置 注解：@WebListener web.xml 1234567&lt;listener&gt;&lt;listener-class&gt;全类名&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--指定初始化参数--&gt;&lt;context-param&gt;&lt;/context-param&gt;]]></content>
      <tags>
        <tag>filter</tag>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2020%2F03%2F01%2FJSP%2F</url>
    <content type="text"><![CDATA[JSP 概念：Java Server Pages：Java服务器端页面 原理：JSP本质上是一个Servlet 服务器解析请求消息，找是否有index.jsp页面 如果有，会将index.jsp转换为.java文件 编译.java文件，生成.class字节码文件 由字节码文件提供访问 JSP的脚本：JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本就可以定义什么内容 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么 JSP的内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 一共9个内置对象 request response out：字符输出流对象，可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 JSP指令 作用：用于配置JSP页面，导入资源文件 格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ...%&gt; 分类： page：配置JSP页面 contentType：等同于response.setContentType() 设置响应体的MIME类型以及字符集 设置当前JSP页面的编码。（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，回自动跳转到指定的错误页面 isErrorPage：标识当前页面是否是错误页面 true：是，可以使用内置对象exception false；否，默认值。不可以使用内置对象exception include：页面包含的。导入页面的资源文件 格式： &lt;%@inlude file=&quot;xxx.jsp&quot;%&gt; taglib：导入资源，导入标签库 格式：&lt;%@ taglib prefix=&quot; &quot; uri=&quot; &quot; %&gt; prefix：前缀，自定义的 JSP注释 html注释： &lt;!-- --&gt;：只能注释html代码片段 jsp注释：推荐使用 &lt;%-- --%&gt;：可以注释所有 JSP内置对象 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 MVC开发模式 jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中写大量的java代码，又写html标签，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC Model：模型。JavaBean 完成具体的业务操作。如：查询数据库，封装对象 View：View视图。JSP 展示数据 Controller：控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 EL表达式 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中java代码的编写 语法：${表达式} 注意：JSP默认支持EL表达式。如果要忽略EL表达式 设置jsp中page指令中：isELIgnored=&quot;true&quot;，忽略当前jsp页面中所有的el表达式 \${表达式} ：忽略当前这个el表达式 使用： 运算 算数运算符 ： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}：判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}：判断字符串、集合、数组对象是否不为null 并且长度大于0 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 pageScope–&gt;pageContext requestScope–&gt;request sessionScope–&gt;session applicationScope–&gt;application（ServletContext ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会区调用对象的getter方法 List集合 ${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[&quot;key名称&quot;]} 隐式对象： EL表达式中有11个隐式对象 pageContext：获取JSP其他八个内置对象 ${pageContext.request.contextPath}：在JSP页面动态获取虚拟目录 JSTL 概念：JavaServer Pages Tag Library JSP标准标签库 由Apache组织提供的开源的免费的jsp标签 作用：用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关的jar包：&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 引入标签库：taglib指令：&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt; 使用标签 常用的JSTL标签 if：相当于java的if test：必须属性，接受boolean表达式 如果表达式为true,则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合EL表达式一起使用 注意 c:if标签没有else情况，需要else情况，则可以再定义一个c:if标签 123&lt;c:if test="true"&gt;&lt;h3&gt;这是真的&lt;/h3&gt;&lt;/c:if&gt; choose：相当于java的switch语句 12345678910&lt;c:choose&gt;&lt;c:when test="$&#123;requestScope.day==1&#125;&#125;"&gt;星期一&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==2&#125;&#125;"&gt;星期二&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==3&#125;&#125;"&gt;星期三&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==4&#125;&#125;"&gt;星期四&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==5&#125;&#125;"&gt;星期五&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==6&#125;&#125;"&gt;星期六&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==7&#125;&#125;"&gt;星期日&lt;/c:when&gt;&lt;c:otherwise&gt;数字输入有误&lt;/c:otherwise&gt;&lt;/c:choose&gt; foreach：相当于java代码的for语句 完成重复操作 begin：开始值 end：结束值 var：临时变量 step：步长 varStatus：循环状态对象 index：容器中元素的索引，从0开始 count：循环次数，从1开始 12345&lt;c:forEach begin="0" end="5" var="i" step="1" varStatus="s"&gt; $&#123;i&#125; $&#123;s.index&#125; $&#123;s.count&#125;&lt;br&gt;&lt;/c:forEach&gt; 遍历容器 item：容器对象 var：容器中元素的临时变量 三层架构：软件设计架构 界面层(表示层/web)：用户可以通过界面上的组件和服务器进行交互。 接收用户参数，封装数据，调用业务逻辑层完成处理，转发jsp页面完成显示 SpringMVC 业务逻辑层(service)：处理业务逻辑的。 组合DAO层中的简单方法，形成复杂的业务逻辑操作 Spring 数据访问层(dao)：操作数据存储文件。 定义对于数据库基本的CRUD操作 Mybatis]]></content>
      <tags>
        <tag>jsp</tag>
        <tag>el</tag>
        <tag>jstl</tag>
        <tag>mvc</tag>
        <tag>三层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2020%2F02%2F27%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP概述 Hyper Text Transfer Protocol ：超文本传输协议 特点： 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型：一次请求对应一次响应 无状态：每次请求之间相互独立，不能交互数据 历史版本 1.0 ：每次请求都会建立新的连接 1.1 ：可以复用连接 请求消息数据格式 请求行 格式：请求方式 请求url 请求协议/版本 请求方式：共7种 GET 请求参数在请求行中，（在url后） 请求的url长度有限制 安全性低 POST 请求参数在请求体中。 请求的url长度没有限制 相对安全 请求头 客户端浏览器告诉服务器的一些信息 格式：请求头名称 : 请求头值1,请求头值2... 常见请求头： User-Agent：浏览器版本信息，可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 请求空行 空行：用于分割POST请求的请求头和请求体 请求体（正文） 封装POST请求消息的请求参数 响应消息数据格式 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码：服务器高速客户端浏览器本次请求和响应的一个状态 1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码 2xx：成功。200 3xx：重定向。 302：重定向 304：访问缓存 4xx：客户端错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXXX方法 5xx：服务器错误。500(服务器内部异常) 响应头 格式：头名称:值 常见的响应头： Content-Type：服务器高速客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么样的格式打开响应体数据 in-line：默认值，在当前页眉内打开 attachment;filename=xxx：以附件形式打开响应体。（文件下载） 响应空行：分隔响应头和响应体 响应体：传输的数据]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2020%2F02%2F27%2FServlet%2F</url>
    <content type="text"><![CDATA[TomcatWeb服务器软件 Web服务器软件：接收用户的请求，处理请求，做出响应。web容器，部署web项目。 常见的web服务器： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 Java SE：Java Standard Edition，Java 标准版。是Java技术的核心和基础，是Java ME和Java EE编程的基础。 Java EE：Java Platform Enterprise Edition企业级应用程序版本。Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Java ME：Java Platform Micro Edition，是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。 Tomcat 目录结构 bin：可执行文件 conf：配置文件 libs：依赖jar包 logs：日志文件 temp：临时文件 webapps：存放web项目 work：存放运行时的数据 可能遇到的问题 黑窗一闪而过 原因：没有正确配置JAVA_HOME环境变量 启动报错 端口被占用：找到占用的端口号，杀死该进程，或修改自身端口号(查看进程和端口号netstat -ano) 修改端口号：conf/server.xml 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端号。在访问时，就不用输入端口号 关闭 正常关闭 bin/shutdown.bat ctrl+c 强制关闭 关闭窗口 部署 简单部署：将项目打成一个war包，再将war包放置到webapps目录下。（war包会自动解压缩） 配置conf/server.xml文件 1234在&lt;Host&gt;标签体中配置&lt;Context docBase="D:\xxx" path="/xxx" /&gt;// docBase:项目存放的路径// path：虚拟目录 热部署：在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 12&lt;Context docBase="D:\xxx" /&gt;* 虚拟目录：xml文件的名称 Servlet Server Applet：运行再服务器端的小程序概念 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet就是一个接口，定义了Java类被浏览器访问到（tomcat识别）的规则 需要自定义一个类，实现Servlet接口，复写方法。 快速入门 创建JavaEE项目 定义一个类，实现Servlet接口 public class 类名 implements Servlet 实现接口中的抽象方法 init：创建 ServletConfig：获取Servlet配置对象 service：提供服务 getServletInfo：获取Servlet信息 destroy：销毁 配置Servlet 123456789101112&lt;!--配置Servlet--&gt;&lt;servlet&gt;&lt;servlet-name&gt;demo&lt;/servlet-name&gt;&lt;servlet-class&gt;com.nogizaka.servlet.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--配置映射路径--&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo&lt;/servlet-name&gt;&lt;url-pattern&gt;/demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则在找到对应的&lt;servlet-class&gt;全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet生命周期创建 init方法，只执行一次 默认情况：第一次被访问时，Servlet被创建 配置执行创建时机： 在&lt;servlet&gt;标签下配置&lt;load-on-startup&gt; 负数：第一次被访问时创建 0或正整数：服务器启动时创建 注意：Servlet的iniy方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 多个用户同时访问时，可能存在线程安全问题 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要修改值。 提供服务 提供服务：执行service方法，执行多次 每次访问Servlet时，service方法都会被调用一次 销毁 销毁：destroy方法，只执行一次 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 Servlet3.0 支持注解配置，无需web.xml 步骤 创建JavaEE项目。选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(urlPatterns = &quot;资源路径&quot;) @WebServlet 12345678910111213141516171819202122232425@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)b@Documentedpublic @interface WebServlet &#123; String name() default "";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default ""; String largeIcon() default ""; String description() default ""; String displayName() default "";&#125; IDEA与tomcat的相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE 工作空间项目和tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目”(out文件夹)，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 Servlet体系结构12345Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法 Servlet相关配置 urlPattern：Servlet访问路径 一个Servlet可以定义多个访问路径 ：@WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 路径定义规则： /xxx：路径匹配 /xxx/xxx:多层路径，目录结构 *.do：扩展名匹配 Request &amp; Response request对象和response对象的原理 request和response对象是由服务器创建的 request对象是来获取请求消息，response对象是来设置响应消息 Requestrequest对象继承体系结构12345ServletRequest -- 接口 | 继承HttpServletRequest -- 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) request功能 获取请求消息数据 获取请求行数据 获取当前请求方式：String getMethod() 获取当前虚拟目录：String getContextPath() 获取Servlet路径：String getServletPath() 获取get方式请求参数：String getQueryString() 获取请求URI： String getRequestURI()：URI：统一资源标识符 StringBuffer getRequestURL()：URL:统一资源定位符 获取协议及版本：String getProtocol() 获取客户机的IP地址：String getRemoteAddr() 获取请求头数据 String getHeader(String name)：通过请求头的名称获取请求头的值 Enumeration&lt;String&gt; getHeaderNames()：获取所有的请求头名称 获取请求体数据 请求体：只有POST请求方式才有，请求体中封装了POST请求的请求参数 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 其他功能 获取请求参数通用方法 String getParameter(String name)：根据参数名称获取参数值 String[] getParameterValues(String name)：根据参数名称获取参数值的数组 Enumeration&lt;String&gt; getParameterNames()：获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap()：获取所有参数的map集合 中文乱码问题： get方式：tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 解决：在获取参数前，设置request的编码 request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发 一种在服务器内部的资源跳转方式 步骤 通过request对象获取请求转发器对象， RequestDispatcher getRequestDispatcher(String path) 使用RequestDistpatcher对象来进行转发： forward(ServletRequest request,ServletRespons response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj)：存储数据 Object getAttribute(String name)：通过键 获取 值 void removeAttribute(String name)：通过键 移除 键值对 获取ServletContext ServletContext getServletContext() 用户登录步骤 创建项目，导入html页面，配置文件，jar包 创建数据库 创建包domain,创建类User domain 存放 javabean 创建包util,编写工具类JDBCUtils JDBC工具类： 获取连接池DataSource对象 获取数据库连接Connection对象 创建包dao,创建类UserDao,提高login方法 dao：datasource access object，数据库连接对象 dao：处理所有的数据库相关操作 单元测试，数据库是否正常连接 创建web.servlet包，实现LoginServlet类 注意 html中的form表单中的action属性：虚拟目录+Servlet的资源路径 BeanUtils工具类 导包:commons-beanutils-1.8.0.jar 用于封装JavaBean JavaBean: 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 JavaBean中的属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（一般和成员方法名相同） 常用方法： setProperty(Object bean, String name, Object value)：设置属性 getProperty(Object bean, String name)：获取属性 populate(Object bean, Map&lt;String,? extends Object&gt; properties)：将map集合的键值对信息，封装到对应的JavaBean对象中 Response 功能：设置响应消息 设置响应行 格式：HTTP/1.1 200 OK 设置状态码：setStatus(int sc) 设置响应头 setHeader(String name,String value) 设置响应体 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流：将数据输出到客户端浏览器 重定向 资源的跳转 1234// 设置状态码为302response.setStatus(302);// 设置响应头locationresponse.setHeader("location","/JavaEE_Response/responseDemo2"); 方法：sendRedirect(&quot;/虚拟目录/资源路径&quot;) 特点： ||地址栏|服务器|请求| |—|—|—|—| |转发Forward|地址栏路径不变|只能访问当前服务器下的资源|一次请求可以使用request对象共享数据| |重定向Redirect|地址栏发送变化|可以访问其他站点(服务器)资源|两次请求不可以使用request对象共享数据| 路径写法相对路径 通过相对路径不可以确定唯一资源 不以/开头，以.开头 规则：找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../:后退一级目录 绝对路径 通过绝对路径可以确定唯一资源 以/开头 规则：判断定义的路径是给谁用 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取：request.getContextPath() &lt;a&gt;,&lt;form&gt;,重定向 给服务器使用：不需要加虚拟目录() 转发路径 服务器输出字符数据到浏览器 步骤： 获取字符输出流 输出数据 12345// 获取字符输出流PrintWriter pw = response.getWriter();// 输出数据pw.write("&lt;h1&gt;hello response&lt;/h1&gt;&lt;br&gt;"); 中文乱码 浏览器：与操作系统有关，windows GBK PrintWriter pw = response.getWriter();：获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码(设置响应头content-type) 1234// 设置响应头response.setHeader("content-type","text/html;charset=utf-8");//或者使用简单的形式，设置编码，是在获取流之前设置response.setContentType("text/html;charset=utf-8"); ServletContext对象 概念：代表整个web应用，可以和程序的容器(服务器)进行通信 获取： 通过request对象获取：request.getServletContext(); 通过HttpServlet获取：this.getServletContext(); 功能： 获取MIME类型 MIME：在互联网通信过程中定义的一种文件数据类型 格式：大类型/小类型 text/html image/jpeg 获取方法：String getMimeType(String file) 域对象：共享数据 ServletContext对象范围：所有用户所有请求的数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) 3. 获取文件的真实(服务器)路径 - 方法：`String getRealPath(String path)` 文件下载 步骤： 获取下载文件名：request.getParameter() 将资源按字节输入流读入内存 找到资源在服务器内的路径：ServletContext对象getRealPath方法 读入字节输入流：创建FileInputStream对象，传递路径 设置response响应头 获取文件类型：ServletContext对象的getMimeType() 设置响应头类型：content-type 设置响应头打开方式：content-disposition 将输入流数据 写出到 response输出流 获取输出流对象：response.getOutputStream() 设置缓冲区：byte[] buff = new byte[1024*4]; 输出数据：write方法 关闭缓冲区：close方法 12345678910111213141516171819202122232425// 获取文件名称String filename = request.getParameter("filename");// 使用字节输入流加载进入内存 // 找到文件的服务器路径ServletContext context = this.getServletContext();String realPath = context.getRealPath("/img/" + filename); // 字节流关联FileInputStream fis = new FileInputStream(realPath);// 指定response的响应头// 设置响应头类型：content-typeString mimeType = context.getMimeType(filename);response.setHeader("content-type",mimeType);// 设置想要头打开方式：content-dispositionresponse.setHeader("content-disposition","attachmemt;filename="+filename);// 将输入流数据写出到response输出流ServletOutputStream sos = response.getOutputStream();byte[] buff=new byte[1024*8];// 缓冲区int len=0;while((len=fis.read(buff))!=-1)&#123; sos.write(buff,0,len);&#125;fis.close(); 中文乱码 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同]]></content>
      <tags>
        <tag>tomcat</tag>
        <tag>Servlet</tag>
        <tag>request</tag>
        <tag>response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些异常]]></title>
    <url>%2F2020%2F02%2F26%2F%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常NoClassDefFoundError Caused by: java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException 原因：找不到DataAccessException类，可能是jar包导入异常 解决方案：查看依赖jar包是否配置在WEB-INF下的lib文件夹中（不是libs）或者是否缺少相关jar包]]></content>
      <tags>
        <tag>Exception</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2020%2F02%2F21%2FXML%2F</url>
    <content type="text"><![CDATA[XML概念 Extensible Markup Language 可扩展标记语言 可扩展：标签都是自定义的 功能：存储数据 配置文件 在网络中传输 xml与html的区别 xml标签都是自定义的,html标签都是预定义的 xml的语法严格，html语法比较松 xml是存储数据的，html是展示数据的 语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭(围堵标签、自闭合标签) xml标签名称区分大小写 123456789101112131415&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分 文档声明 格式：&lt;?xml 属性列表?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值ISO-8859-1 standalone：是否独立（yes/no） 指令：结合css&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 标签：标签名称自定义 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性：id属性值唯一 文本：CDATA区：在该区域中的数据会被原样展示 格式：&lt;![CDATA[ 数据 ]]&gt; 约束 规定xml文档的书写规则 作为框架的使用者 能够在xml中引入约束文档 能够简单的读懂约束文档 分类 DTD:一种简单的约束技术 Schema:一种复杂的约束技术 DTD 引入dtd文档到xml文档中 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema XML Schema语言也称作XML Schema定义（XML Schema Definition，XSD） XML Namespace(xmlns)属性: 格式：xmlns:namespace-prefix=&quot;namespaceURI&quot; 引入 填写xml文档的根元素 引入xsi前缀。 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间。 xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀，作为标识。 xmlns=&quot;http://www.itcast.cn/xml&quot; 解析 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：soup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup 步骤 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 1234567891011/*获取Document对象*//*获取student.xml的path*/String path = JsoupDemo.class.getClassLoader().getResource("student.xml").getPath();// 解析xml文档，加载文档进内存，获取dom树Document document = Jsoup.parse(new File(path),"utf-8");// 获取元素对象 ElementElements elements = document.getElementsByTag("name");//System.out.println(element.size());for (Element element : elements) &#123; System.out.println(element.text());&#125; 对象的使用 Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 Element：元素对象 获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取所有子标签的纯文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象，是Document和Element的父类 快捷查询方式 selector：选择器 使用的方法：Elements select​(String cssQuery) XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询]]></content>
      <tags>
        <tag>XML</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap]]></title>
    <url>%2F2020%2F02%2F21%2FBootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap概念 一个前端开发的框架，Bootstrap，基于HTML、CSS、JavaScript。 框架：一个半成品软件，开发人员可以在框架基础上，再进行开发，简化编码。 优点： 定义了很多的CSS样式和JS插件。我们开发人员直接可以使用这些样式和插件得到了丰富的页面效果。 响应式布局：同一套页面可以兼容不同分辨率的设备 快速入门 下载Bootstrap 导入资源文件 创建html，引入相关资源文件 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;!--&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;--&gt; &lt;link href="../css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="../js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局 同一套页面可以兼容不同分辨率的设备 实现：依赖于栅格系统。将一行平均分为12个格子，可以指定元素占几格 步骤 定义容器 container：固定宽度 container-fluid：100% 宽度 定义行 row 定义元素。指定该元素在不同的设备上，所占的格子数目。 col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px)：col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 12345678910111213141516171819&lt;!--1. 定义容器--&gt;&lt;div class="container-fluid"&gt; &lt;!--2. 定义行--&gt; &lt;div class="row"&gt; &lt;!--3. 定义元素。指定该元素在不同的设备上，所占的格子数目。--&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS样式和JS插件 全局CSS样式 按钮：class=&quot;btn btn-default&quot; 图片：class=&quot;img-responsive&quot;，图片在任意尺寸都占100% 方形： &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt; 圆形： &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; 相框： &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; 表格 table class=&quot;table table-bordered&quot;：带边框的表格 class=&quot;table table-hover&quot;：鼠标悬停 class=&quot;table table-striped&quot;：条纹状表格 表单 class=&quot;form-control&quot; 组件 导航条 分页条 插件 轮播图:Carousel]]></content>
      <tags>
        <tag>Bootstrap</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端]]></title>
    <url>%2F2020%2F02%2F20%2FWeb%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Web前端B/S架构 静态资源 使用静态网页开发技术发布的资源 特点： 所有用户访问，得到的结果是一样的 如：文本、图片、音频、视频，HTML、CSS、Javascript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器，浏览器内置了静态资源的解析引擎，可以展示静态资源 动态资源 使用动态网页即时发布的资源 特点： 所有用户访问，得到的结果可能不一样 如：jsp/servlet、php、asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 HTML概念 Hyper Text Markup Language 超文本标记语言 超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织再一起的网状文本。 标记语言：由标签构成的语言，标记语言不是编程语言 基础语法 html文档后缀：.html或.htm 标签分类 围堵标签：有开始标签和结束标签，如&lt;html&gt;&lt;/html&gt; 自闭合标签：开始标签和结束标签在一起，如&lt;br/&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号引起来（单引双引都可） html的表情不区分大小写，建议使用小写。 常用标签 文件标签 &lt;html&gt;&lt;/html&gt;：html文档的根标签 &lt;head&gt;&lt;/head&gt;：头标签，用于指定html文档的一些属性。引入外部资源 &lt;title&gt;&lt;/title&gt;：标题标签 &lt;body&gt;&lt;/body&gt;：体标签 &lt;!DOCTYPE html&gt;：定义文档类型，html5中定义该文档是html文档 &lt;meta charset=&quot;UTF-8&quot;&gt;：指定字符集 文本标签 注释：&lt;!-- 注释内容 --&gt; &lt;h1&gt;to&lt;h6&gt;：标题标签（h1~h6字体大小逐渐递减） &lt;p&gt;&lt;/p&gt;：段落标签 &lt;br/&gt;：换行标签 &lt;hr&gt;：展示一条水平线 属性： color：颜色 width：宽度 size：高度 align：对齐方式（center/left/right） &lt;b&gt;&lt;/b&gt;：字体加粗 &lt;i&gt;&lt;/i&gt;：字体斜体 &lt;font&gt;&lt;/font&gt;：字体标签 &lt;center&gt;：文本居中,相对于父元素 属性： color：颜色 size：大小 face：字体 属性定义 color： 英文单词 rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) #值1值2值3：值的范围：00~FF之间。如： #FF00FF width： 数值，单位默认px像素 数值%：占比相对于父元素的比例 &gt; 特殊字符表：空格：`&amp;nbsp;` 图片标签 &lt;img/&gt;：展示图片 属性： src：指定图片的位置 alt：规定在图像无法显示时的替代文本 &lt;img src=&quot;图片地址&quot; alt=&quot;图片名称&quot;&gt; 相对路径：以.开头的路径 ./：代表当前目录 ../：代表上一级目录 列表标签 有序列表 &lt;ol&gt;:定义有序列表。 &lt;li&gt;:定义列表的项目。 无序列表 &lt;ul&gt;:定义无序列表。 &lt;li&gt;:定义列表的项目。 链接标签 &lt;a&gt;:定义一个超链接 属性： href:指定访问资源的url(统一资源定位符) target:指定打开资源的方式 _self:默认值，在当前页面打开 _blank:在空白页打开 样式/节 &lt;div&gt;&lt;/div&gt;:可以把文档分割为独立的、不同的部分。每一个div占满一整行。块级标签 &lt;span&gt;&lt;/span&gt;:用来组合文档中的行内元素。文本信息在一行展示，行内标签 内联标签 &lt;header&gt;&lt;/header&gt;:定义文档的页眉（介绍信息）。 &lt;footer&gt;&lt;/footer&gt;:定义文档或节的页脚。 表格标签 &lt;table&gt;&lt;/table&gt; width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 &lt;tr&gt;&lt;/tr&gt;：定义行 bgcolor：背景色 align：对齐方式 &lt;td&gt;&lt;/td&gt;：定义单元格 colspan：合并列 rowspan：合并行 &lt;th&gt;&lt;/th&gt;：定义表头单元格 &lt;caption&gt;&lt;/caption&gt;：表格标题 &lt;thead&gt;&lt;/thead&gt;：表示表格的头部分 &lt;tbody&gt;&lt;/tbody&gt;：表示表格的体部分 &lt;tfoot&gt;&lt;/tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据。用于和服务器进行交互。 &lt;form&gt;：用于定义表单，可以定义一个范围，范围内代表采集用户数据的范围 属性： action；指定提交数据的URL method：指定提交方式（一共7种，常用2种） get 请求参数会在地址栏显示。数据被封装到请求行中 请求参数大小有限制 不太安全 post 请求参数不会显示在地址栏。数据被封装到请求体中 请求参数大小没有限制 比较安全 表单项中的数据想要被提交，必须指定其name属性 表单项标签 input：可以勇敢type属性值，改变元素展示的样式 type属性： text：文本输入框，默认值 password：密码输入框 radio：单选框 要想多个单选框实现单选的效果，则多个单选框的name属性必须一样 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性：可以指定默认值cheecked=&quot;checked&quot;，可以简写checked checkbox：复选框 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性：可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息 按钮： submit：提交按钮，可以提交表单 button：普通按钮 image：图片提交按钮（src属性指定图片的路径） date：定义 date 控件（包括年、月、日，不包括时间）。 email：定义用于 e-mail 地址的字段。 color：定义拾色器 number：定义用于输入数字的字段。 placeholder：指定输入框的提示信息，当输入框的内容发生改变，会自动清空提示信息 select：下拉列表 子元素：option，指定列表项 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行。 - `label`：指定输入项的文字描述信息 - label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。`&lt;label for=&quot;username&quot;&gt;&lt;/label&gt;` CSS 概念：Cascading Style Sheets 层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 优点： 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 使用 内联样式 在标签内使用style属性指定css代码 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 如1234567&lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt;&lt;div&gt;hello css&lt;/div&gt; 外部样式 定义css资源文件 在head标签内，定义link标签，引入外部的资源文件 1234567&lt;!-- a.css:div&#123; color:green;&#125; --&gt;&lt;link rel="stylesheet" href="css/a.css"&gt;&lt;div&gt;hello css&lt;/div&gt;&lt;div&gt;hello css&lt;/div&gt; 注意： 三种方式，css作用域越来越大 3种格式可以写为： 123&lt;style&gt; @import "css/a.css";&lt;/style&gt; 语法 格式： 12345选择器&#123; 属性名1:属性值1; 属性名2:属性值2; ...&#125; 注意：每一对属性需要使用分号;隔开，最后一对属性可以不加 选择器 选择器：筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素，建议在一个html页面中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法：标签名称{} 注意：id选择器优先级高于元素选择器 类选择器：选择具有相同class属性值的元素 语法：.class属性值{} 注意：类选择器优先级高于元素选择器 扩展选择器 选择所有元素 语法：*{} 并集选择器 语法：选择器1,选择器2{} 子选择器：筛选选择器1元素下的选择器2元素 语法：选择器1 选择器2{} 父选择器：筛选选择器2的父选择器1 语法：选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名=属性值的元素 语法：元素名称[属性名=&quot;属性值&quot;]{} 伪类选择器：选择一些元素具有的状态 语法：元素:状态{} 如： &lt;a&gt;标签 link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 属性 字体 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background:background: url(&quot;图片地址&quot;) no-repeat right top; 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right Javascript 概念：客户端脚本语言 运行再客户端浏览器中，每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行 功能：可以增强用户和html页面的交互过程，可以来控制html元素，让页面增加动态效果，增强用户体验 JavaScript的发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。 1995年，NetScape公司，开发了一门客户端脚本语言：LiveScript。后来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软模仿JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式 JavaScript = ECMAScript + JavaScript特有东西(DOM+BOM) ECMAScript：客户端脚本语言标准基本语法 与html结合方式 内部JS：定义&lt;script&gt;，标签体内容就是js代码 外部JS：定义&lt;script&gt;，通过src属性引入外部的js文件 注意： &lt;script&gt;可以定义在html页面的任何地方。但定义的位置会影响执行顺序 &lt;script&gt;可以定义多个 注释 单行注释：//注释内容 多行注释：/*注释内容*/ 数据类型 基本数据类型 number：数字。整数/小数/NaN（not a number一个不是数字的数字类型） string：字符串。 boolean：true/false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 引用数据类型 对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据 语法: var 变量名 = 初始化值; typeof运算符：获取变量的类型。(null运算后得到Object类型) 运算符 一元运算符：只有一个运算数的运算符 ++，-- ， +(正号) 在JS中，如果运算数不是运算符所要求的类型，那么JS引擎会自动地将运算数进行类型转换。 String转number:按照字面值转换，如果字面值不是数字，则转为NaN 算数运算符 + - * / % ... 赋值运算符 = += -+.... 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) 比较方式 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止 类型不同：先进行类型转换，再比较(“123”==123) ===全等于 在比较之前，先判断类型，如果类型不一致，则直接会返回false 逻辑运算符 &amp;&amp; || ! 其他类型转boolean number：0或NaN为false，其他为true string：除了空字符串，其他都是true null/undefined：false 对象：所有对象都为true 三元运算符 表达式? 值1:值2; 判断表达式的值，如果是true则取值1，如果是false则取值2 流程控制语句 if…else… switch 在Java中，switch语句可以接受地数据类型：byte int shor char,枚举(jdk1.5) ,String(jdk1.7) 在JS中,switch语句可以接受任意的原始数据类型 while do…while for JS特殊语法 语句以分号;结尾，如果一行只有一条语句，分号可以省略 变量地定义使用var关键字，也可以不使用 使用：定义的变量是局部变量 不使用：定义的变量是全局变量（不建议） 基本对象 Function函数(方法)对象 创建： 12345678// 常用function 方法名称(形参列表)&#123; 方法体&#125;// 常用2var 方法名 = function(形参列表)&#123; 方法体&#125; 属性： length:返回形参的个数 特点： 方法定义是，形参的类型不用写，返回值类型也不用写 方法是一个对象，如果定义名称相同的方法，会覆盖 JS中，方法的调用只与方法的名称有关，和参数列表无关(无法重载，可以通过arguments.length进行模拟重载) 在方法声明中有一个隐藏的内置对象（数组），arguments封装所有的实际参数 调用：方法名称(实际参数列表); Array数组对象 创建 123456// 1var arr = new Array(元素列表);// 2var arr = new Array(默认长度);// 3var arr = [元素列表]; 方法 join(分隔符)：将数组中的元素按照指定的分隔符拼接为字符串 push()：项数组的末尾添加一个或更多元素，并返回新的长度 属性 length：数组的长度 特点 在JS中，数组元素的类型是可变的 在JS中，数组的长度是可变的 Boolean Date日期对象 创建： 1var date = new Date(); 方法： toLocaleString()；返回当前date对象对应的时间本地字符串格式 getTime()：获取毫秒值。返回当前日期对象描述的时间到1970年1月1日0点的毫秒值差 Math对象 创建：Math对象不用创建，直接使用。Math.方法名(); 方法 random()：返回 0 ~ 1 之间的随机数。 含0不含1 ceil()：对数进行上舍入。 floor()：对数进行下舍入。 round()：把数四舍五入为最接近的整数。 属性 PI Number String RegExp正则表达式对象 正则表达式：定义字符串的组成规则 单个字符：[] 如：[a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符: \d:单个数字字符 [0-9] \w:单个单词字符[a-zA-Z0-9_] 量词符号 ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n m如果缺省： {,n}:最多n次 n如果缺省：{m,} 最少m次 开始结束符号 ^:开始$:结束 正则对象 创建 12345var reg = new RegExp("正则表达式")//引号里面的字符串需要转义符\var reg = /正则表达式/;//egvar reg1 = new RegExp("^\\w&#123;6,12&#125;$");var reg2 = /^\w&#123;6,12&#125;$/; 方法 test(参数)：验证指定的字符串是否符合正则定义的规范 Global全局对象 特点：Global中封装的方法不需要对象就可以直接调用。方法名(); 方法： encodeURI()：url编码 decodeURI()：url解码 12345var str1 = "乃木坂";var encode = encodeURI(str1);//编码document.write(encode+'&lt;br&gt;');//%E4%B9%83%E6%9C%A8%E5%9D%82var str2 = decodeURI(encode)//解码document.write(str2+'&lt;br&gt;'); - `encodeURIComponent()`：url编码,编码的字符更多 - `decodeURIComponent()`：url解码 - `parseInt()`：将字符串转为数字 &gt; 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number - `isNaN()`：判断一个值是否是NaN &gt; NaN六亲不认，连自己都不认。NaN参与的==比较全部问false - `eval()`：将JavaScript 字符串，并把它作为脚本代码来执行。 BOM 概念：Browser Object Model 浏览器对象模型。将浏览器的各个组成部分封装成对象 组成： Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Window窗口对象 创建 方法 与弹出框有关的方法 alert()：显示带有一段消息和一个确认按钮的警告框。 confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。 确定：返回true 取消：返回false prompt()：显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法 close()：关闭浏览器窗口。谁调用，谁被关闭 open()：打开一个新的浏览器窗口。返回新的Window对象 与定时器有关的方法 setTimeout(方法对象,毫秒值)：在指定的毫秒数后调用函数或计算表达式 参数：js代码或者方法对象，毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout(id)：取消由setTimeout()方法设置的timeout setInterval(方法对象,毫秒值)：按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval(id)：取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象 history location Navigator Screen 获取DOM对象 documet:window.document可简写document 特点 Window对象不需要创建可以直接使用。window.方法名() window引用可以省略。方法名() Location地址栏对象 创建 window.location location 方法 reload()：重新加载当前文档。刷新 属性 href：设置或返回完整的 URL。 History历史记录对象 创建 window.history history 方法 back()：加载 history 列表中的前一个 URL。 forward()：加载 history 列表中的下一个 URL。 go(参数)：加载 history 列表中的某个具体页面。 正数：前进几个历史记录 负数：后退几个历史记录 属性 length：返回当前窗口历史列表中的 URL 数量。 DOM 概念：Document Object Model文档对象模型。将标记语言文档的各个组成部分，封装成对象，可以使用这些对象，对标记语言文档进行CRUD动态操作（文档-&gt;dom树） 功能：控制html文档的内容 W3C DOM标准被分为3个不同的部分 核心DOM：正对任何结构化文档的标准模型 Document：文档对象 ElementL：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，上述5个对象的父对象 XML DOM：针对XML文档的标准模型 HTML DOM：针对HTML文档的标准模型 核心DOM Document：文档对象 创建(获取)：在html DOM模型中可以使用window对象来获取 window.document document 方法 获取Element对象 getElementById()：根据id属性值获取元素对象。id属性值一般唯一。 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName()：根据class属性值获取元素对象们。返回值是一个数组。 getElementsByName()：根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象 createAttribute(name) createComment() createElement() createTextNode() 属性 Element：元素对象 获取：通过document对象来获取 window.document.getElementById() document.getElementById() 方法 removeAttribute()：删除属性 setAttribute()：设置属性 123456789101112131415161718&lt;a&gt;点我进入百度&lt;/a&gt;&lt;input type="button" id="btn1" value="快点我一下"&gt;&lt;input type="button" id="btn2" value="点我删除"&gt;&lt;script&gt; /*设置Element对象属性*/ var btn1 = document.getElementById("btn1"); btn1.onclick = function()&#123; var ele_a = document.getElementsByTagName("a")[0]; ele_a.setAttribute("href","https://www.baidu.com"); &#125; /*删除Element对象属性*/ var btn2 = document.getElementById("btn2"); btn2.onclick = function()&#123; var ele_a = document.getElementsByTagName("a")[0]; ele_a.removeAttribute("href"); &#125;&lt;/script&gt; Node：节点对象，其他5个对象的父对象 特点：所有DOM对象都可以被认为是一个节点 方法： CRUD DOM树 appendChild()：向节点的子节点列表的结尾添加新的子节点 removeChild()：删除（并返回）当前节点的指定子节点 replaceChild()：用新节点替换一个子节点 属性 parantNode：返回节点的父亲节点 12345678910111213141516&lt;script&gt; /*删除子节点*/var ele_a = document.getElementById("del");ele_a.onclick = function()&#123; var div1 = document.getElementById("div1"); div1.removeChild(div2);&#125;;/*添加子节点*/var div3 = document.createElement("div");div3.setAttribute("id","div3");var ele_b = document.getElementById("add");ele_b.onclick = function()&#123; var div1 = document.getElementById("div1"); div1.append(div3);&#125;&lt;/script&gt; HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 12345//修改样式方式1div1.style.border = "1px solid red";div1.style.width = "200px";//font-size--&gt; fontSizediv1.style.fontSize = "20px"; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值 事件监听机制 概念：某些组件被执行了某些操作后，会触发某些代码的执行 事件：某些操作。如：单击、双击 事件源：组件。如：按钮、文本输入框 监听器：代码 注册监听：将事件、事件源、监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。 常见事件： 点击事件 onclick：单击事件 ondbclick：双击事件 焦点事件 onblur：失去焦点 onfocus：元素获得焦点 加载事件 onload：一张页面或一幅图像完成加载 鼠标事件 onmousedown：鼠标按键被按下 onmouseup：鼠标按键被松开 onmousemove：鼠标被移动 onmouseover：鼠标移到某元素之上 onmouseout：鼠标从某元素移开 键盘事件 onkeydown：某个键盘按键被按下 onkeyup：某个键盘按键被松开 onkeypress：某个键盘按键被按下并松开 选择和改变 onchange：域的内容被改变 onselect：文本被选中 表单事件 onsubmit：提交按钮被点击(可以阻止表单的提交。方法返回false则表单被阻止提交) onreset：重置按钮被点击 绑定事件： 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 onclick：单击事件 通过js获取元素对象，指定事件属性，设置一个函数]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签对应全称]]></title>
    <url>%2F2020%2F02%2F15%2FHTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%AF%B9%E5%BA%94%E5%85%A8%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[常用HTML标签的英文全称及简单描述 HTML标签 英文全称 中文释义 a Anchor 锚(定义超链接，用于从一张页面链接到另一张页面) abbr Abbreviation 缩写词 acronym Acronym 取首字母的缩写词 address Address 地址 alt alter 替用(一般是图片显示不出的提示) b Bold 粗体（文本） bdo Direction of Text Display 文本显示方向 big Big 变大（文本） blockquote Block Quotation 区块引用语 br Break 换行 cell cell 巢 cellpadding cellpadding 巢补白 cellspacing cellspacing 巢空间 center Centered 居中（文本） cite Citation 引用 code Code 源代码（文本） dd Definition Description 定义描述 del Deleted 删除（的文本） dfn Defines a Definition Term 定义定义条目 div Division 分隔 dl Definition List 定义列表 dt Definition Term 定义术语 em Emphasized 加重（文本） font Font 字体 h1~h6 Header 1 to Header 6 标题1到标题6 hr Horizontal Rule 水平尺 href hypertext reference 超文本引用 i Italic 斜体（文本） iframe Inline frame 定义内联框架 ins Inserted 插入（的文本） kbd Keyboard 键盘（文本） li List Item 列表项目 nl navigation lists 导航列表 ol Ordered List 排序列表 optgroup Option group 定义选项组 p Paragraph 段落 pre Preformatted 预定义格式（文本 ） q Quotation 引用语 rel Reload 加载 radio radiobox 单选框 s/ strike Strikethrough 删除线 samp Sample 示例（文本） small Small 变小（文本） span Span 范围 src Source 源文件链接 strong Strong 加重（文本） sub Subscripted 下标（文本） sup Superscripted 上标（文本） td table data cell 表格中的一个单元格 th table header cell 表格中的表头 tr table row 表格中的一行 tt Teletype 打印机（文本） u Underlined 下划线（文本） ul Unordered List 不排序列表 var Variable 变量（文本）]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2020%2F02%2F15%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概念 Java DataBase Connectivity(Java数据库连接)：Java语言操作数据库 本质：其实是官方（SUN公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动和jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码时驱动jar包中的实现类。 步骤 导入驱动jar包 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 注册驱动 DriverManager 获取数据库连接对象 Connection 定义SQL 获取执行SQL语句的对象 Statement 执行SQL，接收返回结果 处理结果 释放资源 对象 DriverManager：驱动管理对象 Connection：数据库连接对象 Statement：执行SQL的对象 ResultSet：结果集对象 PreparedStatement：执行SQL的对象 DriverManager驱动管理对象 注册驱动：告诉程序该使用哪一个数据库驱动jar 方法：static void registerDriver(Driver driver):注册与给定的驱动程序DriverManager 写代码时使用：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 12345678// 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125;&#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤 获取数据库连接（DriverManager） 方法：static Connection getConnection(String url,String user,String password) 参数： url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 Connection数据库连接对象 功能： 获取执行SQL的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：void setAutoCommit(boolean autoCommit):调用改方法设置参数为false。即开启事务 提交事务：void commit() 回滚事务：void rollback() Statement执行静态SQL的对象 执行SQL boolean execute(String sql):可以执行任意的sql int executeUpdate(String sql):执行DML(insert、update、delete)语句，DDL(create、alter、drop)语句 返回值：影响的行数。可以通过这个影响的行数判断DML语句是否执行成功，返回值&gt;0则执行成功。 ResultSet executeQuery(String sql):执行DQL(select)语句 样例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JdbcDemo01 &#123; public static void main(String[] args) &#123; // 导入驱动 Connection conn = null; Statement smt = null; try &#123; // 静态SQL语句 String s1 = "insert into emp values ()"; String s2 = "delete from emp where salary&gt;8000"; String s3 = "update emp set gender='女' where name='jdbc'"; // 注册驱动 Class.forName("com.mysql.jdbc.Driver"); // 获取数据库连接对象Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/demo", "root", "root"); // 获取Statement对象 smt = conn.createStatement(); // 执行sql语句 int r1 = smt.executeUpdate(s1); int r2 = smt.executeUpdate(s2); int r3 = smt.executeUpdate(s3); System.out.println(r1); System.out.println(r2); System.out.println(r3); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源 // 避免空指针异常 if (smt != null) &#123; try &#123; smt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; ResultSet结果集对象 封装查询结果 boolean next()：游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据）。如果是，则返回false，如果不是返回true； XXX getXXX(参数)：获取一列数据 XXX：代表数据类型， 如：int getInt() 参数： int：代表列的编号，如： getString(1) String：代表列名称，如： getString(“name”) 使用步骤： 游标向下移动一行 判断是否有数据 获取数据1234ResultSet resultSet = smt.executeQuery(s1);while(resultSet.next())&#123; System.out.println(resultSet.getString("name"));&#125; PreparedStatement执行SQL语句的对象 SQL注入问题：在拼接SQL时，有一些SQL的特殊关键字参与字符串的拼接，会造成安全性问题 输入用户随便，输入密码：a’ or ‘a’ = ‘a’ sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 解决方案：使用PreparedStatement对象 预编译的SQL：参数使用？作为占位符 使用步骤： 导入驱动jar包 注册驱动 获取数据库连接对象Connection 定义SQL sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行SQL语句的对象PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法：setXXX(参数1，参数2) 参数1：?的位置编号，从1开始 参数2：?的值 执行SQL：接受返回值结果，不需要传递SQL语句 处理结果 释放资源 注意：使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 语句中使用了占位符，规定了sql语句的结构。用户可以设置”?”的值，但是不能改变sql语句的结构，因此解决了SQL注入 JDBC工具类：JDBCUtils 目的：简化书写 分析： 注册驱动抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件jdbc.properties（文件的读取，只需要读取一次即可拿到这些值。使用静态代码块） 1234url=user=password=driver= 抽取一个方法释放资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.nogizaka.jdbc;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /* 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 * */ static &#123; // 读取资源文件 try &#123; // 1 创建Properties类 Properties prop = new Properties(); // 获取src路径下的文件的方式：ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource("jdbc.properties"); // 获取字符串路径 String path = res.getPath(); // 2 加载文件 prop.load(new FileReader(path)); // 3 获取数据 赋值 url = prop.getProperty("url"); user = prop.getProperty("user"); password = prop.getProperty("password"); driver = prop.getProperty("driver"); // 4 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // 获取数据库连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * * @param stmt * @param conn */ public static void close(Statement stmt, Connection conn) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(ResultSet res, Statement stmt, Connection conn) &#123; if (res != null) &#123; try &#123; res.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注意： properties文件放在src目录下 获取src路径下的文件的方式：ClassLoader 类加载器1234ClassLoader classLoader = JDBCUtils.class.getClassLoader();URL res = classLoader.getResource("jdbc.properties");// 获取字符串路径String path = res.getPath(); JDBC事务控制 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 数据库连接池 概念：其实就是一个容器（集合），存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象当用户来访问数据库时，从容器中获取连接对象，用户访问完以后，会将连接对象归还给容器。 好处：节约资源，提供访问效率 实现： 标准接口：javax.sql.DataSource 方法： 获取连接：getConnection() 归还连接：Connection.close() 如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接，而是归还连接 一般由数据库厂商实现 C3P0:数据库连接池技术 Druid:数据库连接池实现技术（阿里） C3P0 数据库连接池技术 步骤： 导入jar包 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 定义配置文件： 名称：c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建核心对象 数据率连接池对象 new ComboPooledDataSource() 获取连接：getConnection() 123456// 创建数据库连接池对象DataSource ds = new ComboPooledDataSource();// 获取连接对象,getConnection()可以传递配置名，不同配置效果不同，不传使用默认配置Connection conn = ds.getConnection();// 归还连接conn.close(); 配置文件：c3p0-config.xml1234567&lt;!-- 连接池参数 --&gt;&lt;!--初始化申请的连接数--&gt;&lt;property name="initialPoolSize"&gt;5&lt;/property&gt;&lt;!--最大连接数量--&gt;&lt;property name="maxPoolSize"&gt;10&lt;/property&gt;&lt;!--超时时间--&gt;&lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; Druid 数据库连接池实现技术 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件 Properties 可以放在任意目录下 加载配置文件 获取数据库连接池对象：通过工厂来获取 DruidDataSourceFactory.createDataSource() 获取连接：getConnection() 123456789101112// 定义配置文件// 加载配置文件Properties prop = new Properties();// 将properties文件转换为字节输入流InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");// 读取属性列表(键和元素对)从输入字节流。prop.load(is);// 获取连接池对象,通过工厂来获取，参数为配置文件DataSource ds = DruidDataSourceFactory.createDataSource(prop);// 获取连接Connection conn = ds.getConnection();System.out.println(conn); 定义工具类 定义一个类 JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC:JDBC Template Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 commons-logging-1.2.jar spring-beans-5.0.0.RELEASE.jar spring-core-5.0.0.RELEASE.jar spring-jdbc-5.0.0.RELEASE.jar spring-tx-5.0.0.RELEASE.jar 创建JdbcTemplate对象，依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update()：执行DML语句。增、删、改语句 queryForMap()：查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList()：查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query()：查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject()：查询结果，将结果封装为对象 一般用于聚合函数的查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* 需求：1. 修改1号数据的 salary 为 100002. 添加一条记录3. 删除刚才添加的记录4. 查询id为1的记录，将其封装为Map集合5. 查询所有记录，将其封装为List6. 查询所有记录，将其封装为Emp对象的List集合7. 查询总记录数*/public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = "update emp set salary = 10000 where id = 1001"; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; /** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = "insert into emp(id,ename,dept_id) values(?,?,?)"; int count = template.update(sql, 1015, "郭靖", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = "delete from emp where id = ?"; int count = template.update(sql, 1015); System.out.println(count); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = "select * from emp where id = ? or id = ?"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = "select * from emp"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = "select count(id) from emp"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2020%2F02%2F13%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL启动与关闭 MySQL服务启动： 手动 cmd–&gt; services.msc打开服务窗口 使用管理员打开cmd net start mysql：启动mysql服务 net stop mysql：关闭mysql服务 登录与退出 MySQL登录 mysql -u[user] -p[password] mysql -h[ip] -u[user] -p[password] mysql --host=[ip] --user=[user] --password=[password] MySQL退出 exit quit MySQL目录结构 安装目录 配置文件 my.ini 数据目录 数据库 表 数据 SQL 结构化查询语言。定义了操作所有关系型数据库的规则 SQL通用语法 SQL语句可以单行或者多行书写，以分号结尾 可以使用空格和缩进来增强语句的可读性 MySQL数据库的SQL语句不区分大小写，关键字建议使用大写 注释： 单行注释：-- 注释内容 或# 注释内容（MySQL特有） 多行注释： /* 注释 */ SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL数据定义语言操作数据库 CRUD：增删改查 CREATE创建 创建数据库：CREATE DATABASE 数据库名称; 创建数据库，判断不存在，再创建：CREATE DATABASE IF NOT EXISTS 数据库名称; 创建数据库，并指定字符集：CREATE DATABASE 数据库名称 CHARACTER SET 字符集名; RETRIEVE查询 查询所有数据库名称：SHOW DATABASES; 查询某个数据库的字符集：SHOW CREATE DATABASE 数据库名称;（查询某个数据库的创建语句） UPDATE修改 修改数据库的字符集：ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称; DELETE删除 删除数据库：DROP DATABASE 数据库名称; 判断数据库存在，存在再删除：DROP DATABASE IF EXISTS 数据库名称; 使用数据库 查询当前正在使用的数据库名称：SELECT DATABASE(); 使用数据库：USE 数据库名称; 操作表CREATE创建 格式 123456CREATE TABLE 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n); 注意：最后一列，不需要加逗号 数据库类型 int()：整数类型 double(,)：浮点数 date：日期，只包含年月日 yyyy-MM-dd datetime：日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp：时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar()：字符串 复制表：CREATE TABLE 表名 LIKE 被复制的表名 RETRIEVE查询 查询某个数据库中所有的表名称：SHOW TABLES; 查询表结构：DESC 表名; UPDATE修改 修改表名：ALTER TABLE 表名 RENAME TO 新表名 修改表的字符集：ALTER TABLE 表名 CHARACTER SET 字符集名称 添加一列：ALTER TABLE 表名 ADD 列名 数据类型 修改列名称、类型： ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型 ALTER TABLE 表名 MODIFY 列名 新数据类型 删除列：ALTER TABLE 表名 DROP 列名 DELETE删除 删除表： DROP TABLE 表名; DROP TABLE IF EXISTS 表名; DML数据操纵语言添加数据 语法：INSERT INTO 表名(列名1,列名2,...,列名n) VALUES(值1,值2,...值n); 注意： 列名和值要一一对应 如果表名后，不定义列名，则默认给所有列添加值 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据 语法：DELETE FROM 表名 [WHERE 条件]; 注意： 如果不加条件，则删除表中所有的记录 如果要删除所有记录 DELETE FROM 表名; 不推荐使用，有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; 推荐使用，效率更高，先删除表，然后再创建一张一样的表 修改数据 语法：UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,...[WHERE 条件]; 注意：如果不加任何条件，则会将表中所有记录全部修改 DQL数据查询语言 SELECT * FROM 表名; 语法： SELECT：字段列表 FROM：表名列表 WHERE：条件列表 GROUP BY：分组字段 HAVING：分组之后的条件 ORDER BY：排序 LIMIT：分页限定 基础查询 多个字段的查询 SELECT 字段名1,字段名2,...FROM 表名; 如果查询所有字段，可以使用*代替字段列表 去除重复 DISTINCT 计算列 一般可以使用四则运算计算一些列的值 IFNUL(表达式1，表达式2)：NULL参与的运算，计算结果都为NULL 表达式1：哪个字段需要判断是否为NULL 表达式2：如果表达式1的字段为NULL后进行替换的值 起别名 AS：可以省略 条件查询 WHERE子句后跟条件 运算符 &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN...AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL AND 或 &amp;&amp; OR 或 || NOT 或 ! 123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 查询年龄大于20岁SELECT * FROM student WHERE age &gt; 20;SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄等于20岁SELECT * FROM student WHERE age = 20;-- 查询年龄不等于20岁SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄大于等于20 小于等于30SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25SELECT * FROM student WHERE age IN (22,18,25);-- 查询英语成绩为nullSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为nullSELECT * FROM student WHERE english IS NOT NULL;-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%'; 排序查询 语法：ORDER BY 子句 ORDER BY 排序字段1 排序方式1,排序字段2 排序方式2... 排序方式： ASC：升序。（默认） DESC：降序 注意：如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件 eg：SELECT * FROM emp ORDER BY job_id ASC,id DESC; 聚合函数 将一列数据作为一个整体，进行纵向的计算。 COUNT:计算个数，一般选择非空的列（主键）COUNT(*) SELECT COUNT(IFNULL(mgr,0)) FROM emp; MAX:计算最大值 MIN:计算最小值 SUM:求和 AVG:求平均值 注意：聚合函数的计算，排除null值。 解决方案； 选择不包含非空的列进行计算 IFNULL函数 分组查询 语法：GROUP BY 分组字段; 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别 where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where后不可以跟聚合函数，having可以进行聚合函数的判断 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 分页查询 语法：LIMIT开始的索引，每页查询的条数； 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 limit 是一个MySQL”方言” 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性 分类： 主键约束：PRIMARY KEY 非空约束：NOT NULL 唯一约束：UNIQUE 外键约束：FOREIGN KEY 主键约束 PRIMARY KEY 含义；非空且唯一 一张表只能有一个字段为主键 主键就是表总记录的唯一表示 在创建表时，添加主键约束 1234CREATE TABLE stu( id INT PRIMARY KEY, -- 给id添加主键约束 name VARCHAR(20)) 创建表之后，添加主键约束 123ALTER TABLE stuMODIFY id INT PRIMARY KEY; 删除主键 1234-- 错误写法:ALTER TABLE stu MODIFY id INT;ALTER TABLE stuDROP PRIMARY KEY; 自动增长 概念：如果某一列时数值类型的，使用AUTO_INCREMENT可以来完成值的自动增长 在创建表时，添加主键约束，并且完成主键自增 1234CREATE TABLE stu( id INT PRIMARY KEY AUTO_INCREMENT. name VARCHAR(20)); 添加自动增长 123ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 删除自动增长 123ALTER TABLE stu MODIFY id INT; 非空约束 NOT NULL，值不能为NULL类型 创建表时添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空); 创建表之后，添加非空约束 123ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 删除非空约束 123ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束（索引） UNIQUE:值不能重复 创建表时，添加唯一约束 1234CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束); 在创建表之后，添加唯一约束 123ALTER TABLE stuMODIFY phone_number VARCHAR(20) UNIQUE; 删除唯一约束（索引） 123ALTER TABLE stu DROP INDEX phone_number; 外键约束 FOREIGN KEY：让表与表产生关系，从而保证数据的正确性 在创建表时，添加外键约束 123456CREATE TABLE stu( id INT, lesson VARCHAR(20), CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称) ); 在创建表后，添加外键约束 12345ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 删除外键约束 123ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 级联操作 添加级联操作 123456ALTER TABLE 表名ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE; 分类： 级联更新:ON UPDATE CASCADE 级联删除:ON DELETE CASCADE 数据库设计多表之间的关系 分类： 一对一：一对一关系实现，可以在任意一方添加唯一（UNIQUE）外键指向另一方的主键。 一对多：在多的一方建立外键，指向一的一方的主键。 多对多：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 范式 概念；设计数据库时，需要遵循一些规范，要遵循后边的范式要求，必须先遵循前边所有范式要求。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈，越高的范式数据库冗余越小 明确关系数据库有六种范式：第一范式、第二范式、第三范式、BC范式、第四范式、第五范式(完美范式) 第一范式(1NF)：每一列都是不可分割的原子数据项 第二范式(2NF)：在1NF基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 函数依赖：A-&gt;B，如果通过A属性(属性组)的值能唯一确定B属性的值，则称B依赖于A 完全函数依赖：A-&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值，如：(学号,课程名称)-&gt;分数 部分函数依赖：A-&gt;B,如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。如：(学号,课程名称)-&gt;姓名 传递函数依赖：A-&gt;B,B-C.如果通过A属性(属性组)的值，可以唯一确定B属性(属性组)的值，再通过B属性的值可以确定唯一C属性的值，则称C传递函数依赖于A 码：如果再一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该码的表 主属性：码属性组中的所有属性 非主属性：非 码属性组中的属性 第三范式(3NF)：在2NF的基础上，任何非主属性不依赖于其他非主属性(消除传递函数依赖) BC范式：在3NF的基础上消除主属性对于码的部分与传递函数依赖。 数据库的备份和还原 备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原：登录数据库，创建数据库，使用数据库，执行source 文件 多表查询 查询语法： 123456SELECT 列名列表FROM 表名列表WHERE ... 笛卡尔积：AXB的所有组合 内连接查询 步骤： 从哪些表中查询数据 条件是什么 查询哪些字段 隐式内连接：使用WHERE条件消除无用数据 123456789SELECT t1.name, -- 员工表的姓名t1.gender,-- 员工表的性别t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接：SELECT 字段列表 FROM 表名1 [INNER] JOIN 表名2 ON 条件 1234SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 外连接查询 左外连接 语法：SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 OM 条件; 查询的是左表所有数据以及其交集部分 右外连接 语法：SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 OM 条件; 查询的是右表所有数据以及其交集部分 子查询 概念：查询中嵌套查询，称嵌套查询为子查询。 子查询不同情况 结果是单行单列：子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = 结果是多行单列：子查询可以作为条件，使用运算符IN(条件)来判断 结果是多行多列：子查询可以作为一张虚拟表参与查询 事务基本介绍 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败 操作： 开启事务：START TRANSACTION; 回滚：ROLLBACK; 提交：COMMIT; MySQL数据库中事务默认自动提交 事务提交的两种范式： 自动提交:一条DML（增删改）语句会自动提交一次事务 手动提交：需要先开启事务，在提交 修改事务的默认提交范式： 查看事务的默认提交方式：SELECT @@autocommit;1代表自动提交，0代表手动提交 修改默认提交方式：SET @@autocommit=0; 四大特征 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）：事务前后数据的完整性必须保持一致。 隔离性（Isolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 事务隔离的问题 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改 事务隔离的级别 read uncommitted读取尚未提交的数据 ：脏读、不可重复读、幻读 read committed读取已经提交的数据 ：可以解决脏读–oracle默认的 repeatable read重读读取：可以解决脏读和不可重复读–mysql默认的 serializable串行化：可以解决脏读不可重复读和幻读–相当于锁表 注意 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别：select @@tx_isolation; 数据库设置隔离级别：set global transaction isolation level 级别字符串; DCL管理用户、授权管理用户 添加用户：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;; SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;); mysql中忘记了root用户的密码？ cmd – &gt; net stop mysql 停止mysql服务(需要管理员运行该cmd) 使用无验证方式启动mysql服务： mysqld –skip-grant-tables 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 use mysql; update user set password = password(‘你的新密码’) where user = ‘root’; 关闭两个窗口 打开任务管理器，手动结束mysqld.exe 的进程 启动mysql服务 使用新密码登录。 查询用户： 切换到mysql数据库：USE mysql; 查询user表：SELECT * FROM USER; 权限管理 查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;; 授予所有权限：GRANT ALL ON *.* TO &#39;用户名&#39;@&#39;主机名&#39;; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java测试、反射、注解]]></title>
    <url>%2F2020%2F02%2F09%2FJava%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Junit概述 测试分类； 黑盒测试；不需要写代码，给输入值，看程序是否能够输出期望值 白盒测试；需要写代码。关注程序具体的执行流程。 Junit使用；白盒测试 步骤； 定义一个测试类（测试用例） 建议； 测试类名；被测试的类名Test 报名；xxx.xx.xx.test 定义测试方法；可以独立运行 建议； 方法名；test测试的方法名 返回值；void 参数列表；空参 给方法加@Test 导入junit依赖环境 判断结果； 红色；失败 绿色；成功 一般使用断言操作来处理结果；Assert.assertEquals(期望,结果) 补充； @Before；修饰的方法会在测试方法之前被自动执行（一般用于资源申请） @After；修饰的方法会在测试方法执行之后自动被执行（一般用于资源释放） 反射概述 框架；半成品软件。可以再框架的基础上进行软件开发，简化编码 反射；将类的各个组成部分封装为其他对象，这就是反射机制 优点； 可以在程序运行过程中，操作这些对象 可以解耦，提高程序的可扩展性 获取Class对象的方式； Class.forName(&quot;全类名&quot;)；将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class；通过类名的属性class获取 多用于参数的传递 对象.getClass()；getClass()方法在Object类中定义 多用于对象的获取字节码的方式 结论；同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个 Class对象功能 获取功能 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取全类名 String getName() Field：成员变量 操作： 设置值；void set(Object obj, Object value) 获取值；get(Object obj) 忽略访问权限修饰符的安全检查；setAccessible(true):暴力反射 Constructor:构造方法 创建对象：T newInstance(Object... initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象newInstance方法 Method：方法对象 执行方法： Object invoke(Object obj, Object… args) 获取方法名称： String getName:获取方法名 method.invoke(方法名，方法参数) 注解 概念；说明程序的，给计算机看的 注释； 用文字描述程序的，给程序员看的 定义；注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述： JDK1.5之后的新特性 说明程序的 使用注解：@注解名称 作用分类； ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告 一般传递参数all @SuppressWarnings(&quot;all&quot;) 自定义注解 格式； 1234元注解public @interface 注解名称&#123; 属性列表;&#125; 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 public interface MyAnno extends java.lang.annotation.Annotation {} 反编译；cmd -&gt; javap xxx.class 属性；接口中的抽象方法 要求； 属性的返回值类型有下列取值 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性，在使用时需要给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解；用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 在程序使用(解析)注解：获取注解中定义的属性值 获取注解定义的位置的对象 （Class，Method,Field） 获取指定的注解 getAnnotation(Class) 其实就是在内存中生成了一个该注解接口的子类实现对象 调用注解中的抽象方法获取配置的属性值 注意； 以后大多数时候，使用注解，而不是自定义注解 注解给谁用？ 编译器 给解析程序用 注解不是程序的一部分，可以理解为一个标签]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性]]></title>
    <url>%2F2020%2F02%2F09%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java8新特性函数式接口概念 有且只有一个抽象方法的接口，称之为函数式接口 接口中可以包含其他的方法（默认，静态，私有），但是只能有一个抽象方法。 @FunctionalInterface注解 检测接口是否是一个函数式接口 是；编译成功 否；编译失败（接口中没有抽象方法或抽象方法的个数大于1） 格式；1234@FunctionalInterfacepublic interface 接口名&#123; 抽象方法&#125; 使用；一般可以作为方法的参数和返回值类型 函数式编程Lambda的延迟执行 Lambda特点；延迟执行 作用；提升性能 常用函数式接口Supplier接口 java.util.function.Supplier&lt;T&gt;；接口仅包含一个无参的方法；T get()。用来获取一个泛型参数指定类型的对象数据。 生产型接口；指定接口的泛型是什么类型，那么接口中的get方法就会产生什么类型的数据 Consumer接口 java.util.function.Consumer&lt;T&gt;；接口包含抽象方法void accept(T t)，意为消费一个指定泛型数据 消费型接口，泛型执行什么类型，就可以使用accept方法消费什么类型的数据，至于具体怎么消费，需要定义计算 默认方法；addThen 需要两个Consumer接口，可以把两个Consumer接口组合到一起，在对数据进行消费 源码；1234default Consumer&lt;T andThen(Consumer&lt;? super T&gt; after)&#123; Objects.requirNonNull(after); return (T t)-&gt;&#123;accept(t);after.accept(t);&#125;;&#125; Predicate接口 java.util.function.Predicate&lt;T&gt;接口；对某种数据类型的数据进行判断，结果返回一个Boolean值 抽象方法；boolean test(T t)；用来对指定数据类型数据进行判断的方法 默认方法； add；与 1234default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;Objects.requireNonNull(other);return (t) ‐&gt; test(t) &amp;&amp; other.test(t);&#125; or；或 1234default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;Objects.requireNonNull(other);return (t) ‐&gt; test(t) || other.test(t);&#125; negate；非 123default Predicate&lt;T&gt; negate() &#123;return (t) ‐&gt; !test(t);&#125; Function接口 java.util.function.Function&lt;T,R&gt;；接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件 抽象方法；R apply(T t)；根据类型T的参数获取类型R的的结果（一般用于类型转换） 默认方法； andThen Stream流式思想 JDK1.8之后 关注做什么，不关注怎么做 “Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值） Stream（流）是一个来自数据源的元素队列 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源流的来源。 可以是集合，数组等。 Stream操作还有两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 使用步骤 获取数据源 数据转换 执行操作获取想要的结果 注意； Stream流属于管道流，只能被消费一次，第一个Stream流调用完毕，就会关闭。获取流 两种方法 所有的Collection集合都可以通过stream默认方法获取流 Stream接口的静态方法of可以获取数组对应的流 java.util.stream.Stream&lt;T&gt;是Java8新加入的最常用的流接口 根据COllection获取流 default Stream&lt;E&gt; stream() 根据Stream接口获取流 static &lt;T&gt; Stream&lt;T&gt; of(T...values)；参数是一个可变参数，可以传递一个数组 常用方法 延迟方法；返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。 终结方法；返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用逐一处理；foreach void forEach(Consumer&lt;? super T&gt; action)；该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理 forEach方法，用来遍历流中的数据，是一个终结方法，遍历之后就不能继续调用Stream流中的其他方法过滤；filter Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)；可以通过filter方法将一个流转换为另一个子集流映射；map &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);；将流中的元素映射到另一个流中，可以使用map方法统计个数；count long count()；用于统计Stream流中元素的个数 count方法是一个终结方法，返回值是一个long类型的整数，所有不能再继续调用Stream流中的其他方法取用前几个；limit Stream&lt;T&gt; limit(long maxSize);；用于截取流中的元素 limit是一个延迟方法，只是对流中的元素进行截取，返回是一个新的流，所以可以继续调用Stream流中的其他方法跳过前几个；skip Stream&lt;T&gt; skip(long n);；用于跳过元素 如果流的当前长度大于n，则跳过前n个，否则会得到一个长度为0的空流组合；concat static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)；将两个流合并为一个流 这是一个静态方法，与String中的concat方法不同 方法引用 方法引用符：双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者 语义； Lambda表达式写法： s -&gt; System.out.println(s)；拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。 方法引用写法：System.out::println；直接让System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 注:Lambda中传递的参数一定是方法引用中的那个方法可以接收的类型,否则会抛出异常 通过对象名引用成员方法 通过对象名引用成员方法，使用前提是对象名已经存在，成员方法也是已经存在的 通过类名称引用静态方法 通过super引用成员方法 通过this引用成员方法、 类的构造器引用 数组的构造器引用]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程]]></title>
    <url>%2F2020%2F02%2F05%2FJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java网络编程网络基础 软件结构： C/S；Client/Server B/S；Browser/Server 网络协议 TCP/IP协议；传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol) 应用层 传输层 网络层 数据链路层 物理层 TCP；传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次：客户端—&gt;服务器（发请求） 第二次：客户端&lt;—服务器（返回响应） 第三次：客户端—&gt;服务器（曲儿响应） UDP；用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。 IP分类： IPv4；是一个32位的二进制数，通常被分为4个字节，表示成 a.b.c.d的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d的形式，例如 192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个 IPv6；采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成 ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 本机IP地址：127.0.0.1、localhost端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 常用端口号； 80；网络端口 3306；MySQL 1521；Oracle 8080：Tomcat TCP通信 客户端和服务器端进行一个数据交互，需要4个IO流对象 服务器端必须明确； 多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互。在服务器端有个方法叫accept客户端获取到请求的客户端对象 多个客户端同时和服务器端进行交互，就需要使用多个IO流对象 服务器是没有IO流的，服务器可以获取到请求的客户端对象Socket。使用每个客户端Socket中提供的IO流和客户端进行交互（服务器使用客户端的流和客户端交互） TCP通信的客户端；向服务器发送连接请求，给服务i去发送数据，读取服务器回写的数据Socket类 表示客户端的类；java.net.Socket；此类实现客户端套接字，套接字是两台机器之间通信的端点。套接字包含了IP地址和端口号的网络单位 构造方法： Socket(String host,int port)；创建一个流套接字并将其连接到指定主机上的指定端口号。 String host；服务器主机的名称/服务器的IP地址 int port；服务器的端口号 成员方法； OutputStream getOutputStream()；返回此套接字的输出流 InputStream getInputStream()；返回此套接字的输入流 void close()；关闭此套接字 实现步骤； 创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据 释放资源（Socket） 注意； 客户端和服务器端进行交互，必须使用Socket中提供网络流，不能使用自己创建的流对象 当我们创建客户端对象Socket时，就会去请求服务器和服务器经过3次握手建立连接通路。如果服务器没有启动，则抛出异常，如果服务器启动，则进行交互 ServerSocket类 表示服务器的类；java.net.ServerSocket；此类实现服务器套接字 构造方法； ServerSocket(int port)；创建绑定到特定端口的服务器套接字 服务器端必须明确是哪个客户端请求的服务器，所以可以使用accpet方法获取到请求的客户端对象Socket 成员方法； Socket accept()；侦听并接收到此套接字的连接 实现步骤； 创建服务器ServerSocket对象和系统要指定的端口号 使用ServerSocket对象中的方法accpept获取到请求的客户端对象Socket 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据 释放资源(Socket、ServerSocket) 注意 上传完文件，给服务器写一个结束标记 void shutdownOutput()；禁用次套接字的输出流。对于TCP套接字，任何以前写入的数据都将发送，并且后跟TCP的正常连接终止序列]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语法]]></title>
    <url>%2F2020%2F02%2F01%2FJava%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java初步字节 位（bit): 一个数字0或1 字节（Byte）: 8位=1字节，这是数据存储的最小单位 1KB = 1024 Byte,1MB = 1024 KB 命令提示符 MS-DOS(Microsoft Disk Operating System) 启动 ：win + R 切换盘符 ： [盘符]: 进入文件： cd [文件名] 退回上一层：cd .. 退回根目录：cd \ 显示文件列表: dir 清空屏幕：cls 推出cmd : exit JVM、JRE、JDK JVM : Java Virtual Machine,Java虚拟机，是Java程序的运行环境,系统不同，虚拟机版本不同 JRE : Java Runtime Environment, Java运行时环境，包含JVM 和 核心类库 JDK : Java Development Kit, Java开发工具包，包含JRE 和 开发者工具 JDK &gt;&gt; JRE &gt;&gt; JVM Java环境配置 新建变量：JAVA_HOME，值：jdk安装路径，直到bin的上一级 添加Path：%JAVA_HOME%\bin ,%自动匹配% Java入门Java程序运行步骤 java源程序–&gt;编译器–&gt;java字节码文件–&gt;JVM运行 javac.exe : 编译器 java.exe : 解释器 HelloWorld 编写：编写HelloWorld.java 编译：打开CMD，找到程序所在目录，输入javac HelloWorld.java，生成：HelloWorld.class 文件 运行：输入 java HelloWorld ,无需后缀，指定类名 注释 单行注释 ： // 多行注释 ： / / 关键字、标识符 关键字 : 完全小写的字母（public） 标识符 : ·在程序中，自己定义的内容，比如类的名字和变量的名 命名规则: 由 英文字母、0-9、$(美元符)、_（下划线）组成 不能以数字开头 不能是关键字 命名规范: 类名规范：首字母大写，后面每个单词首字母大写（大驼峰） 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰） 方法名规范：同变量名 常量 在程序运行期间，固定不变的量 分类： 字符串常量：双引号引用的部分,例如：”abc”,”123” 整数常量：直接写上数字，没有小数点,例如：100,200 浮点数常量：直接写上数字，有小数点，例如：2.5,-3.14 字符常量：单引号引起来的单个字符，例如：’A’,’中’（没有’’,’AB’，有’ ‘） 布尔常量：只有两种取值，true、false 空常量：null,代表没有任何数据 变量 程序运行期间，内容可以发生改变的量 创建一个变量并且使用的格式： 数据类型 变量名称 //创建了一个变量 变量名称 = 数据值 //赋值交给左边的变量 一步到位 数据类型 变量名称 = 数据值；//创建一个变量的同时，立刻放入指定的数据值 注意事项 ： 如果创建多个变量，变量之间的名称不可以重复 对于float和long类型来说，字母f和L不要漏掉 如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围 没有进行赋值的变量，不能直接使用 变量使用不能超过作用域的范围【作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止】 Java数据类型基本数据类型 整数型 byte short int long 浮点型 float double 字符型 char 布尔型 boolean引用数据类型 字符串 数组 类 接口 Lambda注意事项 字符串不是基本类型，而是引用类型 浮点型可能只是一个近似值，并非精确的值 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节 浮点数当中默认类型是double,如果要用float，需要加上一个后缀F 整数 当中默认类型是int,如果要使用long，需要加上一个后缀L，推荐使用大写字母后缀 数据类型转换 自动类型转换（隐式） 特点：代码不需要进行特殊处理，自动完成。 规则：数据范围从小到大，向上兼容 强制类型转换（显式） 特点: 代码需要进行特殊格式处理，不能自动完成 格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据 注意事项： 强制类型转换一般不推荐使用，因为有可能发生精度损失(小数)、数据溢出(大数) byte/short/char 这三种类型都可以发生数学运算，例如加法”+”。 byte/short/char 这三种类型在运算时，都会被首先提升为int类型，然后再计算。 boolean类型不能发生数据类型转换 对于byte/short/char 三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧范围，编译器自动补上强转。 如果超过左侧范围，编译器会直接报错。 在给变量进行赋值时候，如果右侧地表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 编译器的常量优化 ： short result = 5 + 8; 等号右边全是常量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中相当于直接就是 short result = 13;右侧的常量结果数值，没有超过左侧范围，所以正确。这种成为“编译器的常量优化”。常量计算在编译时已经计算并赋值。一旦表达式右侧有变量参与，则无法进行这种优化。 ASCII码 ASCII : American Standard Code for Information Interchange 美国信息交换标准代码 Unicode : 万国码，也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是128开始包含有更多字符 ‘0’ - ‘48’ , ‘A’ - 65 , ‘a’ - 97 运算符 进行特定操作的符号，例如：+ 表达式：用运算符连起来的式子，例如：a + b 分类： 算数运算符：+ 、 - 、 * 、 / 、 % 、 ++ 、 – 赋值运算符：= 、 += 、-= 、*= 、/= 、%= 比较运算符：== 、&lt; 、 &gt; 、 &lt;= 、 &gt;= 、 != 逻辑运算符：&amp;&amp; 、 || 、 !(取反) 三目运算符：数据类型 变量名称 = 布尔类型表达式 ? 结果1 : 结果2 （true为结果1，false为结果2） 方法入门 定义：若干语句功能的集合，将一个功能抽取出来，形成一个单独的功能，提高代码复用，减少冗余 格式： 123456789/*修饰符 返回值类型 方法名(参数列表)&#123; 方法体 return ;&#125;*/public static void method()&#123; System.out.println("这是一个方法");&#125; 调用: 方法不会自动运行，必须被调用 注意: 方法定义的先后顺序无所谓 方法定义必须是挨着的，不能再一个方法的内部定义另外一个方法 方法必须被调用才会执行 Java9 新特性 JShell : 适合片段代码的测试 启动 ： cmd + JShell 退出 : /exit 流程控制顺序 顺序结构：根据编写顺序，从上到下执行。 判断 if if…else if…else if…else 选择 switch 注意：多个case后面的数值不可以重复 switch小括号当中只能是下列数据类型 基本数据类型 ： byte/short/char/int 引用数据类型 : String字符串、enum枚举 123456789101112switch()&#123; case 常量值1: 语句1; break; case 常量值2: 语句2; break; ... default: 语句体:n+1; break;&#125; case的穿透性：如果case的后面不写break,将出现穿透现象，直接向后运行，直到遇到break; 循环 for while do-while：无条件执行一次循环体，具有一定风险性 12345初始化表达式 do&#123; 循环体 步进表达式 &#125;while(布尔表达式) 区别： 如果条件判断从来没有满足过，for和while将执行0次，do-while至少循环一次 for循环的变量在小括号当中定义，只有循环内可以使用 IDEA快捷键 (自定义)自动补全快捷键:file-settings-keymap-dupulicate(创建副本)-main menu-code-completion-basic(ctrl+alt+?) Alt+Enter : 导入包，自动修正代码 Ctrl+Y : 删除光标所在行 Ctrl+D : 复制光标所在行，插入光标位置下面 Ctrl+ALt+L : 格式化代码 Ctrl+/ : 单行注释 Ctrl+Shift+/ : 多行注释 Alt+Ins : 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 : 移动当前代码行项目结构 Project Module Package Class Java基础方法定义 若干语句功能的集合 参数:进入方法的数据 返回值: 从方法中出来的数据 格式1234修饰符 返回值类型 方法名称(参数类型 参数名称,...)&#123; 方法体 return 返回值;&#125; 修饰符: public static… 返回值类型: void int 方法名称 : 方法名字，小驼峰 参数名称 : 进入方法的数据对应的变量名称 方法体 : 方法需要做的事 return : 停止当前方法，将返回值还给调用处 返回值 : 执行方法后得到的数据结果 注意 : return后面的”返回值“，必须和方法名称前面的返回值类型，保持对应 方法的调用 单独调用: 方法名称(参数),返回值为void,只能单独调用 打印调用: System.out.println(方法名称(参数)); 赋值调用: 数据类型 变量名称 = 方法名称(参数); 方法的重载（Overload） 在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 参数列表: 个数不同，数据类型不同，顺序不同 重载方法调用 : JVM通过方法的参数列表，调用不同的方法。 注意 : 与参数的名称无关 与方法的返回值类型无关 注意 方法应该定义在类中，但是不能在方法中再定义方法，不能嵌套 方法定义的先后顺序无所谓 方法必须被调用才能执行 返回值类型必须和方法的返回值类型对应 数组概念 存储数据长度固定的容器，保证多个数据的数据类型要一致 特点 数组是一种引用数据类型 数组当中的多个数据类型一致 数组的长度在程序运行期间不可改变 初始化 在内存中创建一个数组，并且向其中赋予一些默认值 动态初始化:指定长度 静态初始化:指定内容 动态初始化 数据类型[] 数组名称 = new 数据类型[数组长度] 左侧数据类型:数组中保存的数据类型 左侧的中括号:表示这是一个数组 左侧数组名称:数组的名字 右侧的new : 代表创建数组的动作 右侧数据类型:必须和左边的数据类型保持一致 右侧中括号的长度:数组当中，到底可以保存多少个数据,是一个int数字 1int[] arrayA = new int[200]; 注意: 使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值 整数型:默认值0; 浮点型:默认值0.0; 字符型:’\u0000’; 布尔型:false; 引用型:null. 静态初始化 数据类型[] 数组名称 = new 数据类型[]{元素1, 元素2, 元素3...} 自动分配空间和容量 1int[] arrayB = new int[]&#123;5,10,15&#125; 注意: 静态初始化也有默认值，只不过系统自动马上将默认值替换成大括号中具体值 数组的访问 直接打印数组名称，得到的是数组对应的,内存地址哈希值 访问数组元素的格式: 数组名称 [索引值] 数组的内存 栈(Stack):存放的都是方法中的局部变量。方法的运行一定要在栈中运行。 局部变量:方法的参数，或者是方法{}内部的变量 作用域:一旦超出作用域，立刻从栈内存当中消失 堆(Heap): new出来的东西，都在堆中。 堆内存里面的东西都有一个地址值:16进制 堆内存里面的数据，都有默认值 方法区(Method Area):存储.class相关信息，包含方法的信息 本地方法栈(Native Method Stack):与操作系统相关 寄存器(pc Register): 与CPU相关 数组的常见问题 索引越界异常:如果访问数组元素的时候，索引编号不存在，将会发生数组索引越界异常:ArrayIndexOutOfBoundsException 空指针:数组必须进行new初始化才能使用其中的元素。如果只是赋值了一个null,没有进行new创建，那么将会发生空指针异常:NullPointerException 数组的常用操作 获取数组长度: 数组名称.length，数组一旦创建，程序运行期间，长度不可改变 数组的遍历: 数组名称.fori–&gt;自动补全遍历代码 数组作为方法参数: 传递地址值 数组作为方法返回值: 返回地址值，public static int[] 方法名，return 数组名 注意 方法的参数为基本类型时，传递的是数据值 方法的参数为引用类型时，传递的时地址值 Java中级面向对象思想 面向过程: 当需要实现一个功能时，每一个步骤都需要具体描述出来，强调步骤 面向对象:当需要实现一个功能时，不关心具体步骤，强调过程 封装 继承 多态类和对象类和对象的关系 类:一组相关属性和行为的集合，可以看作是一类事物的模板，使用事物的属性特性和行为特征来描述该类事物。 属性:该事物的状态信息 行为:该事物能够做什么 对象:一类事物的具体体现。对象是类的一个实例,必然具备该类事物的属性和行为。 类与对象的关系: 类是对象的模板，对象是类的实例 类是一类事物的描述，抽象 对象是一类事物的实例，具体 类的定义 格式: 1234public class ClassName&#123; //成员变量 //成员方法&#125; 成员变量(属性):对应事物的属性(事物的状态信息) 成员方法(行为):对应事物的行为(事物能够做什么)对象的使用 通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用 导包：指出所需要使用的类，在什么位置：import 包名称.类名称 创建：类名称 对象名 = new 类名称(); 使用： 使用成员变量：对象名.成员变量名 使用成员方法：对象名.成员方法名(参数) 注意： 当使用一个对象类型作为方法的参数时，传递的就是对象的地址值。 当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值。 成员变量与局部变量的区别 定义的位置不一样 局部变量：方法内部 成员变量：方法外部，直接写在类当中 作用的范围不一样 局部变量：只有方法当中才可以使用 成员变量：整个类可以使用 默认值不一样 局部变量：没有默认值，必须手动赋值 成员变量：如果没有进行赋值，会有默认值，规则和数组一样 内存位置不一样 局部变量；位于栈内存中 成员变量：位于堆内存中 生存周期不一样 局部变量：随着方法进栈儿诞生，随着方法出栈而消失 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失封装 封装性在Java当中的体现 方法就是一种封装 关键字private也是一种封装 封装就是将一些细节信息隐藏起来，对于外界不可见 Private private是一个权限修饰符，代表最小权限 可以修饰成员变量和成员方法 被private修饰后的成员变量和成员方法，只有在本类中访问，超过本类范围就不能被访问 通过设置setXXX(),getXXX()方法来实现外部访问 This this代表所在类的当前对象的引用(地址值),即对象自己的引用 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量 如果需要访问本类当中的成员变量，需要使用格式:this.成员变量名 通过谁调用的方法，谁就是this 构造方法 构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。 格式 123public 类名称(参数类型 参数名称)&#123; 方法体&#125; 注意事项： 构造方法的名称必须和所在类名称完全一致 构造方法不要写返回值类型，连void也不用写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，编译器会默认添加一个无参，无方法体的构造方法 一旦编写了至少一个构造方法，那么编译器将不再默认添加 构造方法也可以进行重载（方法名相同，参数列表不同） 标准类(JavaBean) 格式 所有成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法(快捷键:Alt+insert/CODE-&gt;Generate生成器) 编写一个无参数的构造方法(快捷键：Alt+insert-&gt;Constuctor构造器) 编写一个全参数的构造方法 这样的标准类也叫JavaBean JavaBean：Java语言编写类的一种标准规范。 Java高级常用API API: Application Programming Interface.应用程序编程接口。Java API时一本程序员的字典，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们通过查询API的方式，来学习Java提供的类 API使用步骤： 打开帮助文档 点击显示，找到快速索引，看到输入框 输入需要查找的内容 看包，java.lang下的类不需要导包，其他需要 看类的解释和说明 学习构造方法 使用成员方法 Scanner类 功能：可以实现键盘输入数据，到程序中 引用类型一般使用步骤： 导包: import 包路径.类名称，如果需要使用的目标类和当前类位于同一个包下，则可以省略导包语句不写，只有java.lang包下的内容不需要导包，其他包都需要import语句 创建: 类名称 对象名 = new 类名称() 使用: 对象名·成员方法名() 导包：import java.util.Scanner 创建：Scanner sc = new Scanner(System.in)，System.in表示从键盘进行输入 使用： 获取键盘输入的一个int数字：int num = sc.nextInt(); 获取键盘输入的一个字符串：String str = sc.next(); 匿名对象 创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量 格式：new 类名称(参数列表);，左边没有变量值和赋值号。 应用场景： 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不创建一个新对象，造成浪费 匿名对象可以作为方法的参数和返回值 12345678910111213141516171819202122232425262728293031import java.util.Scanner;/* * 匿名对象 Anonymous * 做参数 * 做返回值 * */public class Anonymous &#123; public static void main(String[] args) &#123;// 做参数 System.out.println("输入的数字是：" + new Scanner(System.in).nextInt());// 使用匿名对象作为参数 methodParam(new Scanner(System.in));// 匿名对象作为返回值 Scanner sc = methodReturn(); System.out.println("第三次输入的是："+sc.nextInt()); &#125; // 匿名对象做参数 public static void methodParam(Scanner sc) &#123; int anInt = sc.nextInt(); System.out.println("输入的第二个数字是:" + anInt); &#125; // 匿名对象做返回值 public static Scanner methodReturn()&#123; return new Scanner(System.in); &#125;&#125; Random类 作用：产生随机数 使用步骤： 查看类：导包，import java.util.Random 查看构造方法：创建，Random r = new Random() 查看成员方法：使用， 获取一个随机的int数字：int num = r.nextInt() 获取一个随机的int数字：(参数代表范围，左闭右开区间)，int num = r.nextInt(3),实代表的范围是 [0,3) ArrayList类 ArrayList集合的长度是可以随便变化的 导包：import java.util.ArrayList 创建：ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); 使用：成员方法 public boolean add()：向集合当中添加元素，参数的类型和泛型一致 public E get(int index)；从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素 public E remove(int index)：从集合中删除元素，参数是索引编号，返回值就是被删除掉的元素 public int size()：获取集合的长度，返回值是集合中元素的个数 注意： 尖括号内的泛型只能是引用类型，不能是基本类型 如果向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的包装类 基本类型 -&gt; 包装类 int -&gt; Integer byte -&gt; Byte short -&gt; Short long -&gt; Long float -&gt; Float double -&gt; Double char -&gt; Character boolean -&gt; Boolean 从JDK1.5开始，支持自动装箱（基本类型-&gt;包装类型），自动拆箱（包装类型-&gt;基本类型） String 特点： 字符串的内容永不可变 字符串可以共享使用 字符串效果上相当于是char[ ]字符数组，但其底层原理是byte[ ]字节数组。 创建字符串： 三种构造方法 public String()：创建一个空白字符串，不含任何内容 public String(char[] array)：根据字符数组的内容，来创建对应的字符串 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串 一种直接创建 String str = &quot;Hello&quot;; //右边直接用双引号 直接写上双引号，就是字符串对象 字符串常量池 对于常量类型来说，==判断的是值 对于引用类型来说，==判断的是地址值 双引号直接写的字符串在常量池当中，new的不在池当中 常用方法字符串比较 public boolean equals(Object obj);//参数可以是任何对象，任何对象都能用object进行接受 注意： 任何对象都能用object进行接收 equals方法具有对称性，也就是a.equals(b)和b.equals(a); 如果比较双方一个常量一个变量，推荐常量写在前面，推荐：&quot;abc&quot;.equals(str),不推荐str.equals(&quot;abc&quot;)；防止str为null，产生空指针异常 public boolean equalsIgnoreCase(String str)：忽略大小写进行内容比较 字符串获取 public int length()：获取字符串当中含有的字符个数，拿到字符串的长度 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串（concatenate级联） public char charAt(int index)：获取指定索引位置的单个字符（索引从0开始） public int indexOf(String str)：查找参数字符串在原本字符串当中首次出现的索引位置，如果不存在，返回-1 字符串截取 public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串，[begin, end)，包含左边，不含右边 字符串转换、替换 public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值 public byte[] getBytes()：获取当前字符串底层的字节数组 public String replace(CharSequence oldString, CharSequence newString)：将所有出现的老字符串替换成为新的字符串,CharSequence意思就是说可以接受字符串类型。 字符串分割方法 public String[] split(String regex)：按照参数规则，将字符串切分为若干部分 注意：split方法的参数其实是一个正则表达式如果要切分&quot;.&quot;，必须写成&quot;\\.&quot; static关键字 static用来修饰成员变量和成员方法，被修饰的成员是属于类，而不是仅仅属于某个对象自己，凡是本类的对象，都共享同一内容。 一旦使用static修饰静态成员方法，那么这种方法就成为了静态方法，静态方法可以直接通过对象名进行调用，也可以直接通过类名称来调用；非静态方法必须通过创建类才能使用 有static，推荐使用类名称进行调用 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 对于本类当中的静态方法，可以省略类名称，编译器会自动补全 注意： 静态不能直接访问非静态，因为在内存当中先有静态内容，后有非静态内容 静态方法不能用this，因为this代表当前对象，通过谁调用方法，谁就是当前对象 静态代码块 格式 12345public class 类名称&#123; static&#123; //静态代码块内容 &#125;&#125; 当第一次用到本类时，静态代码块执行唯一的一次 静态内容总是优先于非静态，所以静态代码块构造方法先执行 用途：用来一次性地对静态成员变量进行赋值 数组根据类：Arrays 作用：与数组相关的工具类，实现数组的常见操作，所有方法都是静态方法，使用非常方便 导包：java.util.Arrays 使用： public static String toString()；将参数数组变成字符串(按照默认格式；[元素1，元素2，元素3…]) public static void sort(数组)：按照默认升序对数组的元素进行排序。 如果是数值，sort默认升序 如果是字符串，sort默认按字母升序 如果是自定义类，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 数学工具类：Math 与数学相关的工具类，里面提供了大量的静态方法，完成于数学运算相关的操作 导包；java.util.Math 使用： public static double abs(double num)：获取绝对值 public static double ceil(double num)：向上取整 public static double floor(double num)：向下取整 public static long round(double num)：四舍五入 Math.PI：圆周率常量 继承定义 继承是多态的前提，如果没有继承，就没有多态 主要解决的问题：共性抽取 子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类的非私有的属性和行为 父类：基类、超类 子类；派生类格式 子类与父类的关系：is-a 父类：(一个普通的类定义) 123public class 父类名称&#123; //...&#125; 子类： 123public class 子类名称 extends 父类名称&#123; //...&#125; 特点成员变量 父类无法使用子类成员变量 子类仅可以直接访问父类的非私有成员变量 成员变成重名： 直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找 间接通过成员方法访问成员变量：方法属于谁就优先用谁，没有则向上找 三种变量重名： 局部变量：直接写成员变量名 本类的成员变量：this.成员变量名 父类的成员变量：super.成员变量名 成员方法 成员方法不重名：正常使用 成员方法重名：创建的对象是谁，优先用谁的方法 注意：无论是成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类 方法重写 重写(Override)【覆盖】：在继承关系当中，方法的名称一样，参数列表也一样 对比： 重载：Overload：方法名称相同，参数列表不同 重写：Override：方法名称相同，参数列表也相同–覆盖 特点：创建的是子类对象，则优先使用子类方法 注意： 必须保证父子类之间的方法名称相同，参数列表也相同 @Override // 写在方法前面，用来检测是不是有效的正确的覆盖重写（注解） // 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写 2. 子类方法的返回值必须**小于等于**父类方法的返回值范围 &gt; `java.lang.Object`类是所有类的公共最高父类，java.lang.String就是Object的子类 3. 子类方法的权限必须**大于等于**父类方法的权限修饰符 &gt; public &gt; protected &gt; (default)(不写) &gt; private 构造方法 继承关系中，父子类构造方法的访问特点； 子类构造方法当中有一个默认隐含的super()调用，所以一定是先调用父类构造，后执行子类的构造 子类构造可以通过super关键字来调用父类重载构造 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造 super关键字 在子类的成员方法中，访问父类的成员变量：super.变量名 在子类的成员方法中，访问父类的成员方法：super.方法名 在子类的构造方法中，访问父类的构造方法：super(); 继承的特征 Java语言是单继承的，一个类的直接父类只能有一个 Java语言可以多级继承（继承体系），顶层都是Object类 一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类 抽象类定义 没有方法主体的方法称为抽象方法，包含抽象方法的类，必须是抽象类 抽象类：包含抽象方法的类 抽象方法：没有方法体的方法，加上abstract关键字，去掉方法体，分号结束 格式 抽象方法： 12// 修饰符 abstract 返回值类型 方法名(参数列表);public abstract void method(); 使用 不能直接创建new抽象类对象 必须用子类继承抽象父类 子类必须覆盖重写抽象父类所有的抽象方法 继承抽象类的子类必须重写父类所有的抽象方法，否则该子类也必须声明为抽象类，最终必须要有子类实现该父类的抽象方法，否则抽象父类到子类的创建全部失效，失去意义 注意 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的 抽象类中，不一定包含抽象方法，但是有抽象方法的类一定是抽象类 抽象类的子类，必须重写抽象父类所有的抽象方法，否则，编译无法通过报错，除非该子类也是抽象类 接口定义 接口就是一种公共的规范标准 接口是一种引用数据类型（数组、类、接口） 格式 123public interface 接口名称&#123; // 接口内容&#125; 备注：换成关键字interface之后，编译生成的字节码文件仍然是：.java-&gt;.class java版本 java7： 常量 抽象方法 java8: 默认方法 静态方法 java9 私有方法 使用 接口不能直接使用，必须有一个“实现类”来“实现”接口 格式：123public class 实现类名称 implements 接口名称&#123; // ...&#125; 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法（否则它必须是一个抽象类） 实现：去掉abstract关键字，加上方法体和大括号 创建实现类的对象，进行使用 接口的抽象方法 注意： 接口当中的抽象方法，修饰符必须是两个固定关键字：public abstract 这两个关键字修饰符，可以选择性省略 方法的三要素，可以随意定义 接口的默认方法 从Java8开始，可以使用默认方法，默认方法可以被实现类继承 作用：解决接口升级的问题（实现类可以重写默认方法） 格式：123public default 返回值类型 方法名称(参数列表)&#123; // 方法体&#125; 接口的静态方法 从Java8开始，接口当中允许定义静态方法 静态与.class文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 格式： 123public static 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 注意：不能通过接口实现类的对象来调用当中的静态方法 正确用法：通过接口名称，直接调用其中的静态方法。 格式：接口名称.静态方法名称(参数) 接口的私有方法 我们需要抽取一个共有方法，用来解决多个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。 从Java9开始，接口当中允许定义私有方法 普通私有方法：解决多个默认方法之间重复代码问题 格式： 123private 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 静态私有方法：解决多个静态方法之间重复代码问题 123private static 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 接口的成员变量（常量） 接口中可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】 格式： public static final 数据类型 常量名称 = 数据值; 一旦使用final关键字进行修饰，说明不可改变 注意： 接口当中的常量，可以省略public static final 接口当中的常量，必须进行赋值，不能不赋值 接口中，常量的名称，使用完全大写的字母，用下划线进行分隔(shift+F6) 总结 在java9+版本中，接口的内容可以有 成员变量其实是常量，格式：[public] [static] [final] 数据类型 常量名称 = 数据值; 注意： 常量必须进行赋值，而且一旦赋值不能改变 常量名称完全大写，用下划线进行分隔 接口中最重要的就是抽象方法，格式： [public] [abstract] 返回值类型 方法名称(参数列表) 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类 从Java8开始，接口里允许定义默认方法，格式：[public] default 返回值类型 方法名称(参数列表){方法体} 注意：默认方法也可以被覆盖重写 从Java8开始，接口里允许定义静态方法，格式：[public] static 返回值类型 方法名称(参数列表){方法体} 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法 从Java9开始，接口里允许定义私有方法，格式： private 返回值类型 方法名称(参数列表){方法体} private static 返回值类型 方法名称(参数列表){方法体} 注意：private方法只有接口自己才能调用，不能被实现类或别人使用 注意 接口不能有静态代码块 接口不能有构造方法 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口 格式： 123public class 实现类 implements 接口A,接口B&#123; // 覆盖重写所有抽象方法&#125; 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类 如果实现类所实现的多个接口，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法（父类&gt;&gt;接口） 接口的多继承 类与类之间是单继承的，直接父类只能有一个 类与接口之间是多实现的，一个类可以实现多个接口 接口与接口之间是多继承的 使用：关键字extends 注意 多个父接口当中的抽象方法如果有重复，没关系 多个父接口当中的默认方法如果有重复，那么子接口必须进行默认方法的覆盖重写，【而且要带着default关键字】 实现类重写接口默认方法，不需要保留default关键字 多态概述 多态性：一个对象拥有多种形态 代码当中体现多态性：【父类引用指向子类对象】 格式： 父类名称 对象名 = new 子类名称(); 或者 接口名称 对象名 = new 实现类名(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误，如果有，执行的是子类重写后方法 多态中的成员变量 直接通过对象名访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 多态中的成员方法 new的是谁，就优先用谁，没有则向上找 注意： 成员方法：编译看左，运行看右 成员变量：编译看左，运行看左 多态的优点 方法调用相同（编译时），用谁找谁（运行时），动态过程 引用类型转换向上转型 向上转型：多态本身是子类类型向父类类型向上转型的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型 格式：父类名称 对象名 = new 子类名称(); 注意：向上转型一定是安全的。从小范围–&gt;大范围 缺陷：无法调用子类特有的内容 向下转型 向下转型：父类类型向子类类型向下转型的过程(还原)，这个过程是强制的 格式：子类名称 对象名 = (子类名称)父类对象; 含义：将父类对象，还原成原本的子类对象 注意： 要还原的对象必须是原来创建的对象，才能向下转型 要还原的对象如果不是原来创建的对象，而是其他对象，就会报错（运行异常，ClassCastException） instance of关键字 作用：返回一个boolean值，判断前面的对象能不能当作后面类型的实例 格式：变量名 instance of 数据类型 final关键字 含义：代表最终、不可改变的 使用： 修饰一个类，不能被继承 修饰一个方法，不能被重写 修饰一个局部变量，不能被重新赋值 修饰一个成员变量，不能被重新赋值 修饰类 格式： 123public final class 类名称()&#123; // ...&#125; 作用：当前这个类不能有任何的子类（final类不能作为父类） 注意：final类的所有成员方法都无法进行覆盖重写 修饰方法 格式： 123public final 返回值 方法名(参数列表)&#123; // 方法体&#125; 作用：当前方法就是最终方法，不能再被覆盖重写 注意：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾 修饰局部变量 格式： 1final 数据类型 数据名 = 数据值; 作用：当前局部变量，不能进行更改，一次赋值，终生不变 注意：对于基本类型，不可变说的是变量当中的数据不可变；对于引用类型来说，不可变说的是变量当中的地址值不可变 修饰成员变量 格式： 1final 数据类型 数据名 = 数据值; 作用：当前成员变量，不能进行更改，但成员变量有默认值，用了final后必须进行手动赋值 注意： 对于final的成员变量，要么使用直接赋值，要么使用构造方法赋值（二选一） 必须保证类当中所有重载构造方法，都最终会对final的成员变量进行赋值 权限修饰符 public protected (default) private 同一个类 YES YES YES YES 同一个包 YES YES YES NO 不同包子类 YES YES NO NO 不同包非子类 YES NO NO NO 内部类 定义：将一个类A定义在另一个类B里面，A被称为内部类，B被称为外部类 成员内部类：定义在类中方法外的类 分类： 成员内部类 局部内部类(包含匿名内部类) 注意：内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。比如，Person$Heart.class 成员内部类 定义在一个类内成员方法外的类 格式： 123456修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; //... &#125; //...&#125; 使用： 直接：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称() 间接：在外部类的方法中，使用内部类：然后main只是调用外部类的方法 注意； 内用外，随意访问，外用内，需要内部类对象 同名变量访问：（重名）外部类名称.this.外部类成员变量名 局部内部类 定义在一个方法内部的类，“局部”：只有当前所属方法才能使用，出了方法无法使用 格式： 1234567修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称(参数列表)&#123; class 局部内部类名称&#123; //... &#125; &#125;&#125; 使用：方法内创建局部类对象，main直接调用外部类方法 注意：权限修饰符 外部类：public/(default) 成员内部类：public / protected / (default) / private 局部内部类：无法使用修饰符 局部内部类的final问题 局部内部类，如果希望访问所在方法的局部变量，那么这份局部变量必须是有效final的(从Java8开始，只要局部变量事实不变，那么final关键字可以省略) 原因： new出来的对象在堆内存当中 局部变量是跟着方法走到，在栈内存中 方法运行结束之后，立刻出栈，局部变量就会立刻消失 new出来的对象会在堆中持续存在，直到垃圾回收消失 匿名内部类 如果接口的实现类(或者是父类的子类)，只需要使用唯一的一次，那么这种情况就可以省略掉该类的定义，改用匿名内部类 格式： 123接口名称 对象名 = new 接口名称()&#123; // 覆盖重写所有抽象方法&#125;; 对”new 接口名称(){…};”解析: new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 注意： 匿名内部类，在创建对象的时候，只能使用唯一一次，如果希望多次创建对象，而且内容一样，那么就必须使用单独的实现类 匿名对象，在调用方法的时候，只能调用一次，如果希望同一个对象，调用多次方法，必须要给对象取名 匿名内部类省略了实现类/子类，匿名对象省略了对象名称 匿名内部类和匿名对象不是一回事 常用API-2Object类 类Object是类层次结构的根(父)类。每个类都使用Object作为超(父)类，所有对象（包括数组）都实现这个类的方法 导包：java.lang.Object 使用 public String toString()：返回该对象的字符串表示 public boolean equals(Object obj)：指示其他某个对象是否与此对象”相等” toString方法 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值 直接打印对象的名字，其实就是调用对象的toString 覆盖重写 在IDEA中，可以使用alt+insert，点击toString() 看一个类是否重写了toString,直接打印这个类的对象即可，如果没有重写toString方法，那么打印的是对象的地址值equals方法 如果没有重写equals方法，默认比较对象的地址值，如果需要比较内容，需要覆盖重写 参数： Object obj：可以传递任意的对象 this ；调用的对象 obj ；参数 基本数据类型：比较地址值 引用数据类型；比较对象的地址值 覆盖重写： 问题：隐含一个多态，无法使用子类特有的内容（属性和方法） 解决：向下转型（强转） alt+insert ,equals() and hashCode() Objects类 JDK7中添加的工具类，其中的方法是null-save(空指针安全)或null-tolerant(容忍空指针)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象 Objects.equals方法：防止出现空指针异常123public static boolean equals(Object a, Object b)&#123; return (a==b)||(a!=null&amp;&amp;a.equals(b));&#125; Date类 表示特定的瞬间，精确到毫秒（千分之一秒 1000毫秒=1秒） 毫秒值的作用：可以对时间和日期进行计算（0毫秒：1970年1月1日 00:00:00） 中国属于东八区，会把时间+8小时 导包：java.util.Date构造方法 public Date()：获取当前系统的日期和时间 public Date(Long date):传递毫秒值，把毫秒值转换为Date日期成员方法 public long getTime():把日期转换为毫秒值(相当于System.currentTimeMillis()方法)，返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数DateFormat类 定义：日期/时间格式化子类的抽象类，可以实现日期和文不之间的转换（Date-&gt;String） 作用：格式化（日期-&gt;文本）、解析（文本-&gt;日期） 导包：java.text.DateFormat 成员方法： String format(Date date)：按照指定的模式，把Date日期，格式化为符合模式的字符串 Date parse(String source)：把符合模式的字符串，解析(parse)为Date日期 DateFormat是抽象类，无法之间创建对象使用，可以使用DateFormat的子类（SimpleDateFormat） parse方法声明了一个异常叫ParseException，如果字符串和构造方法的模式不一样，那么程序就会抛出此异常，调用一个抛出了异常的方法，就必须处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理 SimpleDateFormat: java.text.SimpleDateFormat extends DateFormat 构造方法：SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造 注意：模式中的字母不能更改，连接模式的符号可以改 Calendar类 本身是抽象类，已知子类GregorianCalendar，提供了很多操作日历字段的方法(YEAR\MONTH\DAT_OF_MONTH\HOUR) Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance()，此方法返回了Calendar类的子类对象 static Calendar getInstance() 使用默认时区和语言环境获得一个日历常用方法 public int get(int field)：返回给定日历字段的值 public void set(int field, int value)；将给定的日历字段设置为给定值 public abstract void add(int field, int amount)；根据日历的规则，为给定的日历字段添加或减去指定的时间量 public Date getTime()；返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象 注意；int field；日历类的字段，可以使用Calendar类的静态成员变量获取 System类 导包：java.lang.System 获取与系统相关的信息或系统级操作常用方法 public static long currentTimeMillis()；返回以毫秒为单位的当前时间 public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length)；将数组中指定的数据拷贝到另一个数组中 StringBuilder类 字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），底层也是一个数组，但是没有final修饰，可以改成长度 在内存中始终是一个数组，占用空间少（byte[] value = new byte[16]），效率高，如果超出，自动扩容 java.lang.Builder构造方法 StringBuilder()；构造一个不带任何字符的字符串生成器，其初始容量为16个字符 StringBuilder(String str)；构造一个字符串生成器，并初始化为指定的字符串内容成员方法 public StringBuilder append(...)；添加任意类型数据的字符串形式，并返回当前对象自身 public String toString()；将当前StringBuilder对象转换为String对象注意 String-&gt;StringBuilder；可以使用StringBuilder的构造方法 StringBuilder-&gt;String；可以使用StringBuilder的toString方法 基本类型包装类 使用一个类，将基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类，我们可以使用类中的方法来操作这些基本类型的数据装箱与拆箱 装箱；把基本类型的数据，包装到包装类中 构造方法： Integer(int value)；构造一个新分配的Integer对象，它表示指定的int值 Integer(String s)；构造一个新分配的Integer对象，它表示String参数所指示的int值（注意：传递的字符串，必须是基本类型的字符串，否则会抛出异常‘100’正确，‘0’异常） 静态方法 static Integer valueOf(int i)；返回一个表示指定的int值的Integer对象 static Integer valueOf(String s)；返回保存指定的String的值的Integer对象 拆箱；在包装类中取出基本类型的数据 成员方法；int intvalue()；以int类型返回该Integer值 自动装箱与自动拆箱 基本类型的数据和包装类之间可以自动地相互转换（JDK1.5之后） 基本类型与字符串类型的转换 基本类型-&gt;字符串； 基本类型的值+”” 包装类的静态方法toString(参数)，不是Object类的toString()方法，发生了重载 String类的静态方法valueOf(参数) 字符串-&gt;基本类型； 包装类的静态方法；parseXXX(“数值类型的字符串”) 集合概述 数组长度固定；集合长度可变 数组存储同一类型元素；集合只能存储对象，类型可以不一致 框架 Collection接口；所有单列集合中共性的方法\所有的单列集合都可以使用共性的方法\没有索引的方法 List接口；有序的集合（存储和取出元素顺序相同）\允许存储重复元素\有索引，可以使用普通的for循环遍历 Vector集合 ArrayList集合 LinkedList集合 Set接口；不允许存储重复元素\没有索引（不能使用普通的for循环遍历） TreeSet集合 HashSet集合 LinkedHashSet集合(存取一致) Collection集合常用方法 public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() ；清空集合中所有的元素。 public boolean remove(E e)；把给定的对象在当前集合中删除。 public boolean contains(E e)；判断当前集合中是否包含给定的对象。 public boolean isEmpty()；判断当前集合是否为空。 public int size()；返回集合中元素的个数。 public Object[] toArray()；把集合中的元素，存储到数组中。 Iterator迭代器 为了遍历集合中所有元素 java.util.Iterator Iterator接口 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 常用方法； boolean hasNext()；如果仍有元素可以迭代，返回true E next() ；返回迭代的下一个元素 注意：Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象。Colletion接口中有一个方法，叫iterator()，返回的就是迭代器的实现类对象 使用步骤； 使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态），注意迭代器也有泛型，跟着集合走 使用Iterator接口中的方法hasNext判断还有没有下一个元素 使用Iterator接口中的方法next取出集合中的下一个元素 增强for循环 底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，jdk1.5之后 Collection&lt;E&gt;extends Iterable&lt;E&gt;；所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;；实现这个接口允许对象成为”foreach”语句的目标 格式 123for(集合/数组的数据类型 变量名:集合名/数组名)&#123; sout(变量名);&#125; 注意；新for循环必须有被遍历的目标，目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现 泛型(Generic)概述 一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型 泛型可以看作是一个变量，用来接收数据类型 E e；Element元素 T t；Type类型 创建集合对象的时候，就会确定泛型的数据类型优点 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型 把运行期间异常ClassCastException，提升到了编译时期的编译失败 但是泛型是什么类型，只能存储什么类型的数据定义与使用 含有泛型的类 格式：123修饰符 class 类名&lt;泛型&gt;&#123; //...&#125; 含有泛型的方法 格式；123456789// 普通方法修饰符 &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123; 方法体;&#125;// 静态方法修饰符 static &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123; 方法体;&#125; 含有泛型的接口 格式； 123修饰符 interface 接口名&lt;泛型&gt;&#123; 抽象方法(泛型 参数名,...);&#125; 使用： 定义类时确定泛型的类型 始终不确定泛型的类型，直到创建对象时，确定泛型的类型泛型通配符 ？；代表任意的数据类型 使用： 不能创建对象使用 只能作为方法的参数使用 注意：泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 泛型的上限限定 ? extends E；代表使用的泛型只能是E的子类/本身 泛型的下限限定 ? super E；代表使用的泛型只能是E类型的父类/本身 List集合 java.util.List extends Collection List接口继承Collection接口特点 有序的集合，存储元素和取出元素的顺序是一致的 有索引，包含了一些带索引的方法 允许存储重复的元素常用方法 public void add(int index, E element)；将指定的元素，添加到该集合中的指定位置上 public E get(int index)；返回集合中指定位置的元素 public E remove(int index)；移除列表中指定位置的元素，返回的是被移除的元素 public E set(int index, E element)；用指定元素替换集合中指定位置的元素，返回以前在指定位置的元素 注意：操作索引的时候，一定要防止索引越界异常子类 ArrayList；List接口的数组实现，元素增删慢，查找快。此实现是不同步的（多线程）。 LinkedList；List接口的链表列表实现。元素添加快，查找慢。 双向链表 含有大量操作首尾元素的方法，因此不要使用多态 常用方法： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst() :返回此列表的第一个元素。 public E getLast() :返回此列表的最后一个元素。 public E removeFirst() :移除并返回此列表的第一个元素。 public E removeLast() :移除并返回此列表的最后一个元素。 public E pop() :从此列表所表示的堆栈处弹出一个元素。 public void push(E e) :将元素推入此列表所表示的堆栈。 public boolean isEmpty() ：如果列表不包含元素，则返回true。 Vector；单线程，与ArrayList原理一样，已被ArrayList替代 Set集合 java.util.Set extends Collection Set接口继承Collection接口特点 不允于存储重复的元素 原理；add方法会调用元素的hashCode方法和equals方法，判断元素值是否重复(前提；存储的元素必须重写hashCode和equals方法)，哈希值不同，直接存入集合，哈希值相同，比较equals，true为相同值，不存入集合 没有索引，没有带索引的方法，也不能使用普通的for循环遍历 子类HashSet 特点； 由哈希表支持，不保证迭代顺序 是一个无序的集合，存储元素和取出元素的顺序有可能不一致 底层是一个哈希表结构(查询速度快) 哈希值； 是一个十进制的整数，由系统随机给出(对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址) 在Object类中由一个方法，可以获取对象的哈希值；int hashCode() hashCode()；public native int hashCode()，native代表该方法调用的是本地操作系统的方法 String类的哈希值；String类重写了Object类的hashCode()方法（”重地和通话”哈希值相同） 数据结构； 哈希表； jdk1.8版本之前；哈希表= 数组+链表 jdk1.8版本之后；哈希表=数组+链表+红黑树（提高了查询速度） 存储数据到集合中(先计算元素的哈希值) 把元素进行分组，相同哈希值链接到一起 哈希冲突：元素不同，哈希值相同 如果链表的长度超过8位，那么就会把链表转换为红黑树 存储自定义类型元素 重写hashCode和equals方法 LinkedHashSet java.util.LinkedHashSet extends HashSet,继承父类HashSet 可预知迭代顺序的Set接口的哈希表和链接列表实现 底层是一个哈希表（数组+链表/红黑树）+链表；多了一条链表记录元素的存储顺序，保证元素有序 可变参数 JDK1.5之后出现的新特性 使用前提；当前方法的参数列表数据类型已经确定，但是参数的个数不确定，使用可变参数 格式；修饰符 返回值类型 方法名(数据类型...变量名){} 原理；可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个,1,2…多个 注意； 一个方法的参数列表，只能有一个可变参数 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾 终极写法；(Object...obj) Collections工具类 java.util.Collections；集合工具类常用方法 public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T...elements)；往集合中添加一些元素 public static void shuffle(List&lt;?&gt; list)；打乱集合顺序 public static &lt;T&gt; void sort(List&lt;T&gt; list)；将集合中元素按照默认规则（升序）排序 public static &lt;T&gt; void sort(List&lt;T&gt; list ,Comparetor&lt;? super T&gt;)；将集合中元素按照指定规则排序 注意； sort(List&lt;T&gt; list)被排序的集合里面存储的元素，必须实现Comparable接口，重写接口中的compareTo()定义排序规则 Comparable接口的排序规则；自己(this)-参数；升序 Comparator和Comparable的区别 Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法 Comparator；找一个第三方的裁判 Comparator排序规则；o1-o2升序，o2-o1降序 Map集合 java.util.Map&lt;k,v&gt; 特点； Map集合是一个双列集合，一个元素包含两个值(一个key,一个value) Map集合中的元素，key和value的数据类型可以相同，也可以不同 Map集合中的元素，key是不允许重复的，value是可以重复的 Map集合中的元素，key和value是一一对应的 和Collection的区别： Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 Map常用子类 HashMap&lt;K,V&gt;； HashMap底层是哈希表，查询速度快，元素的存储顺序不能保证一致 为了保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法 JDK1.8之前；数组+单向链表 JDK1.8之后；数组+单向链表/红黑树（链表的长度超过8时） LinkedHashMap&lt;K,V&gt;； 是HashMap的子类，底层是哈希表+链表 是一个有序的集合，存储元素和取出元素的顺序是一致的，需要重写hashCode()、equals()方法 注意；Map接口中的集合都有两个泛型变量&lt;K,V&gt;，在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 Map常用方法 public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值V: 存储键值对的时候，key不重复，返回值V是null 存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值V: key存在，返回被删除的值 key不存在，返回null public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值V: key存在，返回对应value值 key不存在，返回null boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map遍历key找value方式 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keySet() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) Entry键值对对象 Map.Entry&lt;K,V&gt;；在Map接口中有一个内部接口Entry 作用；当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键与值得映射关系） Entry对象的常用方法； public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 HashMap存储自定义类型键值 Map集合保证Key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一 LinkedHashMap&lt;K,V&gt; LinkedHashMap&lt;K,V&gt;继承HashMap&lt;K,V&gt; 底层原理；哈希表+链表（记录顺序） HashTable&lt;K,V&gt; 底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢 HashTable不能存null值,null键 HashTable和Vector在jdk1.2之后被取代（HashMap,ArrayList） HashTable的子类Properties依然在使用 JDK9对集合添加的优化 JDK9的新特性； List接口、Set接口、Map接口；增加了一个静态方法of，可以给集合一次性添加多个元素 前提；集合中存储的元素的个数已经确定，不再改变 注意； of方法值适用于List、Set、Map接口，不适用于接口的实现类 of方法的返回值是一个不能改变的集合，集合不能再使用add、put方法添加元素，会抛出异常 Set接口和Map接口再调用of方法的时候，不能有重复的元素，否则会抛出异常 Debug调试 Debug调试程序； 可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug 使用方式； 在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里） 右键，选择Debug执行程序 执行程序； f8；逐行执行程序 f7；进入到方法中 shift+f8；跳出方法 f9；跳到下一个断点，如果没有下一个断点，那么就结束程序 ctrl+f2；退出Debug模式，停止程序 Console；切换到控制台 异常与多线程异常 异常；程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止 异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象，Javac处理异常的方式是中断处理异常体系 Throwable；Java.lang.Throwable Error；工程师无法处理，只能尽力避免 Exception；编译期异常，由于使用不当导致，可以避免 RuntimeException；运行期异常,Java程序运行过程中出现的问题 异常处理 常用关键字；try,catch,finally,throw,throws throw 在指定的方法中抛出指定的异常 格式；throw new xxxException(&quot;异常产生的原因&quot;) 注意； throw关键字必须写在方法内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，(运行期异常)可以不处理，默认交给JVM处理（打印异常对象，中断程序） throw关键字后边创建的是编译异常，我们就必须处理这个异常，要么throw,要么try...catch 声明异常throws 异常处理的第一种方式，交给别人处理 当方法内部抛出异常对象的时候，必须处理这个异常对象 可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理 格式； 12345修饰符 返回值 方法名(参数列表) throws AAAException, BBBException...&#123; throw new AAAException("产生原因"); throw new BBBException("产生原因"); ...&#125; 注意； throws关键字必须写在方法声明处 throws关键字后边声明的异常必须是Exception或者是Exception的子类 方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常。（如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可） 调用了一个声明抛出异常的方法，我们就必须处理声明的异常。（要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM，要么try...catch自己处理异常） 捕获异常try…catch 格式； 123456789try&#123; 可能产生异常的代码&#125;catch(异常类型 变量名)&#123; //用来接收try中抛出的异常对象 处理异常的代码（一般把异常信息记录到一个日志中）&#125;...catch(异常类型 变量名)&#123;&#125; 注意； try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try…catch之后的代码 如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑 Throwable常用方法 public void printStackTrace()；打印异常的详细信息 public String getMessage()；获取发生异常的原因 public String toString()；获取异常的类型和异常描述信息（不用） finally代码块 格式 1234567try&#123; 可能发生异常的代码&#125;catch(异常类型 变量名)&#123;&#125;finally&#123; 无论是否出现异常都会执行&#125; 注意； finally 不能单独使用，必须和try一起使用 finally 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源（IO） 异常的注意事项 多个异常使用捕获该如何处理 多个异常分别处理 多个异常一次捕获，多次处理 注意；一个try,多个catch,如果catch定义的异常变量，具有父子类的关系，子类的异常变量必须写在上面，否则会报错 多个异常一次捕获（catch异常对象的父类），一次处理 如果finally有return语句,永远返回finally中的结果,避免该情况 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类重写父类方法时 抛出和父类相同的异常 抛出父类异常的子类异常 不抛 父类没有抛出异常，子类也不能抛出异常，如果出现异常，只能捕获处理，不可抛出 自定义异常类 格式 12345public class XXXException extends Exception|RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法&#125; 注意； 自定义异常类一般都是Exception结尾，说明该类是一个异常类 自定义异常类，必须的继承Exception或者RuntimeException 继承Exception；自定义的异常类是一个编译器异常，如果方法内抛出了编译器异常，必须处理这个异常，要么抛出要么捕获 继承RuntimeException；自定义的异常类是一个运行期异常，无需处理，交给JVM（中断处理） 多线程并发与并行 并发；指两个或多个事件在同一个时间段内发生(交替执行) 并行；指两个或多个事件在同一时刻发(同时发生)线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度； 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的是抢占式调度 单线程程序：Java程序中只有一个线程 主线程：执行主（main）方法的线程创建线程类方式一：创建Thread类的子类 java.lang.Thread；描述线程的类，要实现多线程程序，必须继承Thread类 实现步骤： 创建一个Thread子类 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程做什么） 创建Thread类的子类对象 调用Thread类中的方法start()方法，开启新的线程（开辟新的栈空间），执行run方法方式二：实现Runnable接口 java.lang.Runnable 实现步骤： 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法实现Runnable接口创建多线程的好处 避免了单继承的局限性 一个类只能继承一个类，类继承了Thread类就不能继承其他的类，实现Runnable接口，还可以继承其他的类，实现其他的接口 增强了程序的扩展性，降低了程序的耦合性（解耦） 实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离(解耦)。实现类中，重写了run方法：用来设置线程任务；创建Thread类对象，调用start()方法：用来开启新线程 Thread类 构造方法 常用方法 public String getName()；获取当前线程名称 public void start()；导致此线程开始执行，Java虚拟机调用此线程的run方法 public void run()；此线程要执行的任务在此处定义代码 public static Thread currentThread()；返回当前正在执行的线程对象的引用 public static void sleep(long millis)；使当前正在执行的线程以指定的毫秒数暂停 设置线程名称 使用Thread类中的方法void setName(String name) 创建一个带参数的构造方法，参数传递线程的名称，调用父类的带参构造方法（super(name)）,把线程名称传递给父类，让父类（Thread）给子线程改名字（Thread(String name)） 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。匿名内部类方式实现线程的创建 格式： 1234new 父类/接口（）&#123; @Override 重写父类/接口中的方法&#125; eg: 123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 线程任务 &#125; &#125;).start(); 线程安全线程同步 当使用多线程访问同一资源的时候，多个线程对资源有写操作，就容易出现线程安全问题 Java提供了同步机制（Synchronized）解决线程同步机制同步代码块 格式： 123synchronized(锁对象)&#123; 需要同步操作的代码&#125; 注意； 同步代码块中的锁对象，可以使用任意的对象 必须保证多个线程使用的锁对象是同一个 锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行，其他线程被阻塞（BLOCKED） 频繁的上锁、解锁会降低程序效率，但是提供程序安全性 同步方法 使用synchronized修饰的方法，就叫同步方法 格式： 123public synchronized 返回值类型 方法名()&#123; 可能会产生线程安全问题的代码&#125; 同步方法也会把方法内部打代码锁住 同步锁是谁?对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 Lock锁 java.util.concurrent.locks.Lock Lock 实现了比 synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象 创建对象 Lock 锁名 = new ReentrantLock(); 常用方法； public void lock() :加同步锁。 public void unlock() :释放同步锁 线程状态 java.lang.Thread.State六种状态 线程状态 导致状态发生的条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法 Runnable(可运行) 线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于CPU Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而对象锁被其他的线程持有，则该线程进入Blocked状态；当线程持有锁时，该线程变成Runnable状态 Waiting(无限等待) 一个线程在等待另一个线程执行（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒 TimedWaiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入TimeWaiting状态，这一状态将一致保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有：Thread.sleep(),Object.wait() Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 Timed Waiting 计时等待 Thread.sleep(long m)；强制当前正在执行的线程休眠，线程进入Runnable/Blocked状态 锁对象.wait(long m)；在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程进入Runnable/Blocked状态 注意；sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。Blocked 锁阻塞 线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态Waiting 无限等待 等待唤醒 只有锁对象才能调用void wait()和void notify()方法 void notifyAll()；全部唤醒 等待唤醒机制线程间通信 多个线程在处理同一个资源，但是处理的动作（线程的任务）却不同 多个线程并发执行，CPU默认随机切换线程，为了让他们有规律执行，需要进行协调通信 等待唤醒机制；使各个线程能有效利用资源等待唤醒机制 多个线程间的一种协作机制 wait/notify就是线程间的一种协作机制 等待唤醒中的方法： wait：线程不再活动，不再参与调度，进入wait set中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：选取所通知对象的 wait set中的一个线程释放 notifyAll；释放所通知对象的 wait set上的全部线程。 注意： wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法 线程池 线程池；可以容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源 优点； 降低资源消耗 提高响应速度 提高线程的可管理性 线程池的使用 jdk1.5之后提供 java.util.concurrent.Executors；线程池的工厂类，用来生成线程池 Executors类中的静态方法； static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用固定线程数的线程池 参数；int nThreads；创建线程池中包含的线程数量 返回值；ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口接收) java.util.concurrent.ExecutorService；线程池接口 用来从线程池中获取线程，调用start()方法，执行线程任务 submit(Runnable task)提交一个Runnable任务用于执行 关闭/销毁线程池的方法 void shutdown() 线程池的使用步骤 使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类，实现Runnable接口，重写run方法，设置线程任务 调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法 调用ExecutorService中的方法shutdown销毁线程池（不建议执行） Lambda表达式函数式编程思想 面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程Lambda Java8 实现多线程：12345678910// 匿名内部类实现多线程new Thread(new Runnable()&#123; @Override public void run()&#123; 线程任务 &#125; &#125;).start();// Lambda表达式实现多线程new Thread(()-&gt;&#123;线程任务&#125;).start();//启动线程 Lambda表达式标准格式 组成； 一些参数 一个箭头 一段代码 格式； (参数列表)-&gt;{一些重写方法的代码} 解释； ()；接口中抽象方法的参数列表，没有参数就空着，有参数就写处参数，多个参数用逗号分隔 -&gt;；床底的意思，把参数传递给方法体{} {}；重写接口的抽象方法的方法体 Lambda省略格式 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为函数式接口 File类与IO流File类概述 java.io.File是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作 File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法静态方法 static String pathSeparator ；与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 static char pathSeparatorChar ；与系统有关的路径分隔符。 static String separator ；与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 路径不要写死，win和分隔符不同eg:&quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a.txt&quot; static char separatorChar ；与系统有关的默认名称分隔符。 路径 绝对路径；是一个完整的路径，以盘符开始的路径 相对路径；是一个简化的路径，相对指的是相对于当前项目的根目录 注意： 路径不区分大小写 路径中的文件名称分隔符windows用的是反斜杠，但反斜杠是转义字符，所以两个反斜杠菜表示一个普通的反斜杠构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 String pathname：字符串的路径名称 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的File实例。 String parent 父路径，String child 子路径 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的File实例。 File parent 父路径是File类，可以使用一些方法，String child 注意； 路径可以是文件结尾，也可以是文件夹结尾 路径可以是相对路径，也可以是绝对路径 路径可以是不存在的 创建File对象，只是把字符串路径封装成File对象，不考虑路径的真实情况获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。不存在，返回0。判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 文件不存在，创建文件，返回true,文件存在，创建失败，返回false 创建文件的路径必须存在，否则会抛出异常（IOException） public boolean mkdir() ：创建由此File表示的目录。(单级) 只会创建目录，与名称是否存在后缀无关 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录（多级） public boolean delete() ：删除由此File表示的文件或目录。 删除成功，返回true,文件夹中有内容，不会删除，返回flase，构造方法中路径不存在，返回false delete方法是直接在硬盘删除文件/文件夹，不走回收站，需要谨慎 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 list方法和listFiles方法遍历的是构造方法中给出的目录 如果构造方法中给出的目录的路径不存在，会抛出空指针异常 如果构造方法中给出的路径不是一个目录，也会抛出空指针异常 文件过滤器FileFilter java.io.FileFilter接口；用于抽象路径名（File对象）的过滤器 作用；用来过滤文件（File对象） 抽象方法；用来过滤文件的方法 boolean accept(File pathname)；测试指定抽象路径名是否应该包含在某个路径名列表中FilenameFilter java.io.FilenameFilter接口；实现此接口的类实例可用于过滤文件名 作用；用于过滤文件名 抽象方法；用来过滤文件的方法 boolean accept(File dir, String name)；测试指定文件是否应该包含在某一文件列表中 参数； File dir；构造方法中传递的被遍历的目录 String name；使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称 注意；两个过滤器接口没有实现类，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤规则 IO流IO分类 数据流向： 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存中写出到其他设备上的流。 数据类型； 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1字符=2字节 1字节=8位 顶级父类： 类型 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 字节流字节输出流 java.io.OutputStream；抽象类表示字节输出流的所有类的超类 常用方法； public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 注意；当完成流的操作时，必须调用此方法，释放系统资源 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流（以二进制存入）。 如果写的第一个字节是正数（0-127）,那么显示的时候会查询ASCII表 如果写的第一个字节是负数，那第一个字节回合第二个字节，两个字节组成一个中文显示，查询系统默认码表（GBK） public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 FileOutputStream类： 构造方法： public FileOutputStream(File file) ：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name) ： 创建文件输出流以指定的名称写入文件。 注意；当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 写入数据的原理 内存–&gt;硬盘 Java抽象–&gt;JVM–&gt;OS–&gt;OS调用写数据的方法–&gt;把数据写入到文件中数据追加续写 public FileOutputStream(File file, boolean append) ： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append) ： 创建文件输出流以指定的名称写入文件 boolean append:追加写开关 true：创建对象不会覆盖原文件，继续在文件的末尾追加写数据 false；创建一个新文件，覆盖源文件 换行写 Windows系统里，换行符号是\r\n 字节输入流 java.io.InputStream；抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中 常用方法； public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read() ： 从输入流读取数据的下一个字节。 public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 byte[]；起到缓冲作用，存储每次读取到的多个字节，一般定义为1024(1kb)或1024的整数倍 返回值int ；每次读取的有效字节个数 FileInputStream类 java.io.FileInputStream；从文件中读取字节 构造方法； FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。读取数据的原理 硬盘-&gt;内存 java程序-&gt;JVM-&gt;OS-&gt;OS读取数据的方法-&gt;读取文件关于中文 1个中文： GBK；占用2个字节 UTF-8；占用3个字节 字符流字符输出流 java.io.Writer； 常用方法： void write(int c) 写入单个字符。void write(char[] cbuf) 写入字符数组。- abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str) 写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush() 刷新该流的缓冲。void close() 关闭此流，但要先刷新它。 FileWriter extends OutputStreamWriter extends Writer； 构造方法； FileWriter(File file) ： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName) ： 创建一个新的 FileWriter，给定要读取的文件的名称 使用步骤； 创建FileWriter对象，构造方法中绑定要写入数据的目的地 使用FileWriter中的方法write，把数据写入到内存缓冲区中（字符转字节的过程） 使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 释放资源(会先把内存缓冲区的数据刷新到文件中) 字符输入流 java.io.Reader；抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。 常用方法： public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read() ： 从输入流读取一个字符。 public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 FileReader类 extends InputStreamReader extends Reader； 构造方法： FileReader(File file) ： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName) ： 创建一个新的 FileReader ，给定要读取的文件的名称 使用方法； 创建FileReader对象，构造方法中绑定要读取的数据源 使用FileReader对象中的方法read读取文件 释放资源 flush和close flush ：刷新缓冲区，流对象可以继续使用。 close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 注意 字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流IO异常处理 jdk1.7之前使用try…catch finally处理流中的异常 格式；12345678try&#123; 可能产生出异常的代码&#125;catch(异常类型 变量名)&#123; 异常的处理逻辑&#125;finally&#123; 一定会执行的代码 (资源释放)&#125; JDK7新特性：在try的后边可以增加一个(),在括号中可以定义流对象，那么这个流对象的作用域就在try中有效。try中的代码执行完毕，会自动把流对象释放，不用写finally 格式：12345try(定义流对象;定义流对象;...)&#123; 可能产生出异常的代码&#125;catch(异常类型 变量名)&#123; 异常的处理逻辑&#125; JDK9新特性；try的前面可以定义流对象，try后边的()中可以直接引入流对象的每次（变量名），在try代码执行完毕只会，流对象可以自动释放，不用写finally 格式：1234567A a = new A();B b = new B();try(a,b)&#123; 可能产生出异常的代码&#125;catch(异常类型 变量名)&#123; 异常的处理逻辑&#125; 属性集概述 java.util.Properties extends Hashtable&lt;K,V&gt; implements Map&lt;K,V&gt; Properties表示一个持久的属性集。Properties可保存在流中或从流中加载。 Properties集合是一个唯一和IO流相结合的集合 可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用 属性列表中每个键及其对应值都是一个字符串：Properties集合是一个双列集合，key和value默认都是字符串Properties类 构造方法： public Properties()；创建一个空的属性列表 常用方法： public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合 与流相关的方法 void store(OutputStream out, String comments)；以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。 void store(Writer writer, String comments)；以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符。 参数； OutputStream out；字节输入流，不能写入中文 Writer writer；字符输出流，可以写中文 String comments；注释，用来解释说明保存的文件是做什么的，不能使用中文，默认unicode编码，一般使用””空字符串 void load(InputStream inStream) ；从输入流中读取属性void列表（键和元素对）。 void load(Reader reader) ；按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。 注意； 存储键值对的文件中，键与值默认的链接符号可以使用=，空格（其他符合） 存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取 存储键值对的文件中，键与默认值都是字符串，不用加引号 缓冲流 字节缓冲流： BufferedInputStream ， BufferedOutputStream 字符缓冲流： BufferedReader ，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 字节缓冲流 BufferedOutputStream；字节缓冲输出流 java.io.BufferedOutputStream.extends.OutputStream 构造方法； public BufferedOutputStream(OutputStream out)； 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 public BufferedOutputStream(OutputStream out, int size)；创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流 使用方法； 创建FileOutputStream对象，构造方法中绑定要输出的目的地 创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据，刷新到文件中 释放资源（会先调用flush方法刷新的数据，第4步可以省略） BufferedInputStream；字节缓冲输入流 java.io.BufferedInputStream.extends.InputStream 构造方法； public BufferedInputStream(InputStream in)； 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 public BufferedInputStream(InputStream in, int size)；创建具有指定缓冲区大小的BufferedInputStream并保存其参数，即输入流 使用方法； 创建FileInputStream对象，构造方法中绑定要读取的数据源 创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象效率 使用BufferedInputStream对象中的方法read，读取文件 释放资源（会先调用flush方法刷新的数据，第4步可以省略） 字符缓冲流 BufferedWriter；字符缓冲输出流 java.io.BufferedWriter.extends.Writer 构造方法； public BufferedWriter(Writer out)； 创建一个使用默认大小输出缓冲区的缓冲字符输出流 public BufferedWriter(Writer out, int size)；创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流 特有的成员方法； void newLine()；写入一个行分隔符。会根据不同的操作系统，获取不同的行分隔符 使用方法； 创建FileWriter对象，构造方法中绑定要输出的目的地 调用字符缓冲输出流的方法write，吧数据写入到内存缓冲区中 调用字符缓冲输出流中的方法flush，把内存缓冲区中的数据，刷新到文件中 释放资源 BufferedReader；字符缓冲输入流 java.io.BufferedReader.extends.Reader 构造方法； public BufferedReader(Reader in)； 创建一个使用默认大小输入缓冲区的缓冲字符输入流 public BufferedReader(Reader in, int size)；创建一个使用指定大小输入缓冲区字符输入流 特有的成员方法； String readLine()；读取一个文本行，读取一行数据 行的终止符号；通过下列字符之一即可认为某行已终止（换行：\n,回车；\r,或回车后直接跟着换行\r\n） 返回值；包含该行内容的字符串，不包含任何终止符，如果已到达流末尾，则返回null 使用方法； 创建字符缓冲输入流对象，构造方法中传递字符输入流 使用字符缓冲输入流对象中的方法read/readLine读取文本 释放资源 转换流字符编码 字符编码 Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。字符集 字符集 Charset ：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。InputStreamReader类 字节–（解码）–&gt;字符 java.io.InputStreamReader extends Reader；从字节流到字符流的桥梁，它读取字节，并使用指定的字符集将其解码为字符 构造方法； InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。- InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。OutputStreamWriter类 字符–（编码）–&gt;字节 java.io.OutputStreamWriter extends Writer；从字符流到字节流的桥梁，使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法； OutputStreamWriter(OutputStream out) : 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream out, String charsetName) : 创建一个指定字符集的字符流。 序列化流 序列化；把对象以流的方式，写入到文件中保存，也叫写对象 反序列化；把文件中保存的对象，以流的方式读取出来，也叫读对象ObjectOutputStream类 序列化。Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法； public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 成员方法； void writerObject(Object obj)；将指定的对象写入ObjectOutputStream序列化操作 一个对象要想序列化，必须满足两个条件 该类必须实现 java.io.Serializable 接口， Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰（静态也不能被序列化）。 ObjectInputStream类 反序列化。将之前使用ObjectOutputStream序列化的原始数据恢复为对象 构造方法； public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。 成员方法； Object readObject()；从ObjectInputStream读取对象 反序列化操作 类必须实现Serializable 必须存在类对应的.class文件，如果找不到该类的class文件，则抛出一个ClassNotFoundException异常。 InvalidClassException； 当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 InvalidClassException 异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。 static final long serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配 打印流]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础-02(语法)]]></title>
    <url>%2F2019%2F12%2F31%2FC-%E5%9F%BA%E7%A1%80-02-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分类 值类型：存放到栈中，每次存取都会在内存中操作 引用类型：首先在栈中创建一个引用变量，绕后在堆中创建对象本身，再把这个对象所在内存的首地址赋给引用变量。 值类型- 整型 - 浮点型 - 字符型 - 布尔型 - 枚举型 整型- sbyte ：有符号，1字节， - byte ：无符号，1字节 - short ：有符号，2字节 - ushort ：无符号，2字节 - int ：有符号，4字节（C#整型 默认值） - uint : 无符号，4字节 - long : 有符号，8字节 - ulong : 无符号，8字节 浮点型- float ：单精度浮点，4字节，最多保留7位小数，123.45f/123.345F - double ： 双精度浮点，8字节，最多保留16位小数，默认double类型 字符型- char : 2字节，存放一字符、汉字,单引号表示，&apos;a&apos; 布尔型- bool : true/false 枚举型引用类型- 类 - 接口 - 数组 - 委托 - 字符串 类接口数组委托字符串- string ： 存放多个字符，双引号表示，“abc”]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令]]></title>
    <url>%2F2019%2F12%2F29%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git工作区域 远程仓库（Remote） 备份代码，实现代码的远程管理 仓库区/本地仓库（Respository） 确定的文件保存到仓库，成为一个新的版本，并且对他人可见 暂存区(Index/unStage) 暂存已经修改的文件，最后统一提交到git仓库 工作区（Workspace） 添加、编辑、修改文件 Git命令新建代码库 在当前目录新建一个Git代码库git init 新建一个目录，将其初始化为Git代码库git init [project-name] 下载一个项目git clone [url] 配置 显示当前配置git config --list 显示文件状态git status 增加/删除文件 添加当前目录所有文件(work)到暂存区(index)git add 添加指定文件到暂存区git add [filename] 代码提交 提交暂存区(index)到仓库（repo）git commit -m [Message提交描述] 分支 列出所有本地分支git branch 列出所有远程分支git branch -r 远程同步 更新远程仓库git remote update 取回远程仓库的变化，并与本地分支合并git pull [remote][branch] 上传本地指定分支到远程仓库git push [remote][branch]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础-01]]></title>
    <url>%2F2019%2F12%2F29%2FC-%E5%9F%BA%E7%A1%80-01%2F</url>
    <content type="text"><![CDATA[C# 基础C# 是什么？- MicroSoft开发。创始人Anders - 面向对象编程 C# 的特点？- 简单、安全 - 面向对象 - 封装：将代码看作一个整体，只提供对象名和参数，提高安全性 - 继承：C#仅支持单继承 - 多态：通过继承和实现接口的方式，让类或接口中的成员表现出不同作用 - 跨平台 - 开发多种类型的程序 C# 和 Java、C++的区别C# 和 .NET- .NET是一个开发平台，而C#是一种在.NET开发平台上使用的编程语言 - .NET框架是一个多语言组件和执行环境，它提供一个跨语言的统一编程环境 - .NET框架的目的是便于开发人员容易建立Web应用程序和Web服务，使得Internet上的各应用程序之间可以使用Web服务进行沟通 .NET Framework定义一个可以快速开发、部署网站服务及应用程序的开发平台，是Windows中的一个组件 - 公共语言运行时（CLR）虚拟系统 - .NET Framework类库 优点- 提供标准的面向对象开发环境 - 提供优化的代码执行环境、兼容性高 - 使用JIT(just in time)技术，提高代码运行速度 体系结构1. 编程语言：C#、VB、C++、JScript 2.Common Language Specification(CLS):公共语言运行规范，定义一组规则：可以通过不同的编程语言来创建Windows应用程序、ASP.NET网站程序以及在.NET Framework中所有支持的程序。 3.Framework Class Library(FCL)：在FCL中包括Windows Forms（窗体程序）、ASP.NET(网站程序)、WPF(windows界面程序的框架)、WCF(Windows平台上的工作流程序)等所用到的类库文件。 4.Common Language Runtime(CLR)：.NET Framework的基础，用户可以将CLR看作一个在执行时管理代码的代码，它提供内存管理、线程管理和远程处理等核心服务，并且还强制实施严格类型安全以及可靠性的管理。(类似Java虚拟机)，以CLR为目标的代码称为托管代码，不以CLR为目标的代码称为非托管代码。 5.Windows API、COM+ Service：application programming interface应用程序接口 6.OS]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#学习笔记(一)]]></title>
    <url>%2F2019%2F12%2F19%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[C#简介 Microsoft开发 面向对象 结构化 C# 功能 布尔条件（Boolean Conditions) 自动垃圾回收(Automatic Garbase Collection) 标准库(Standard Library) 组件版本(Assembly Versioning) 属性(Properties）和事件（Events） 委托（Delegates) 和事件管理（Events Management) 泛型（Generics） 索引器(Indexers) 条件编译（Conditional Compilation) 简单的多线程(Multithreading) LINQ和Lambda表达式 集成Winodws C# 环境.Net框架（.Net Framework)用于开发 Windows应用程序 Web 应用程序 Web 服务]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO常用指令]]></title>
    <url>%2F2019%2F07%2F09%2FHEXO%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令 打开hexo目录：右键 git bash here 新建文章：hexo new 文章名称 新建草稿：hexo publish 文章名称 生成：hexo g 本地服务器：hexo s 部署：hexo d]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取猫眼电影排行榜]]></title>
    <url>%2F2019%2F01%2F18%2FPython%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C%E6%A6%9C%2F</url>
    <content type="text"><![CDATA[Python爬取猫眼电影排行榜 requests 获取 html lxml 解析 html xpath 定位元素 json 存文件 自己写的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import requestsfrom lxml import htmlimport json# 存储排名的列表rank_list = []def spider(offset): '''爬取猫眼电影排行榜''' url = "https://maoyan.com/board/4?offset=&#123;offset&#125;".format(offset=offset) html_data = requests.get(url).text # print(html_data) selector = html.fromstring(html_data) # print(selector) topper = selector.xpath('//dd') # print(topper) temp = [] for movie in topper: # 排名 rank = movie.xpath('i/text()')[0] print("排名:&#123;&#125;".format(rank)) # 电影名 name = movie.xpath('div/div/div/p/a/@title')[0] print("《&#123;&#125;》".format(name)) # 主演 star = movie.xpath('div/div/div/p[@class="star"]/text()')[0].strip() print(star) # 上映时间 time = movie.xpath('div/div/div/p[@class="releasetime"]/text()')[0] print(time) # 评分 score1 = movie.xpath('div/div/div/p[@class="score"]/i[1]/text()')[0] print("评分:&#123;&#125;".format(score1), end='') score2 = movie.xpath('div/div/div/p[@class="score"]/i[2]/text()')[0] print("&#123;&#125;".format(score2)) # 封面,网站两个&lt;img&gt;标签，两个src资源无法区分，通过pycharm获取html源代码,src标签是不一样的 image = movie.xpath('a[@class="image-link"]/img/@data-src')[0] print(image) print("-"*20) rank_list.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1+score2, 'image': image &#125;) temp.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1 + score2, 'image': image &#125;) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) return temp# 爬一次写一次，爬一页写一次，爬完写一次def write_to_file(content): '''写入文件''' with open('Maoyan_Rank.txt', 'a', encoding='utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False)+'\n')if __name__ == '__main__': #spider() for i in range(0, 100, 10): for item in spider(i): write_to_file(item) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) # f = open('Maoyan_Rank.txt', 'w') # f.write(item for item in rank_list) 书上用的正则表达式，这里跳过12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import requestsfrom lxml import htmlimport jsondef get_one_page(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' &#125; res = requests.get(url, headers=headers) # print(res) # get 请求 成功返回 状态码 = 200 if res.status_code == 200: # print(res.text) return res.text return Nonedef spider(offset): '''爬取猫眼电影排行榜''' url = "https://maoyan.com/board/4?offset=&#123;&#125;".format(offset) html_data = get_one_page(url) # print(html_data) selector = html.fromstring(html_data) # print(selector) topper = selector.xpath('//dd') # print(topper) rank_list = [] for movie in topper: # 排名 rank = movie.xpath('i/text()')[0] print("排名:&#123;&#125;".format(rank)) # 电影名 name = movie.xpath('div/div/div/p/a/@title')[0] print("《&#123;&#125;》".format(name)) # 主演 star = movie.xpath('div/div/div/p[@class="star"]/text()')[0].strip() print(star) # 上映时间 time = movie.xpath('div/div/div/p[@class="releasetime"]/text()')[0] print(time) # 评分 score1 = movie.xpath('div/div/div/p[@class="score"]/i[1]/text()')[0] print("评分:&#123;&#125;".format(score1), end='') score2 = movie.xpath('div/div/div/p[@class="score"]/i[2]/text()')[0] print("&#123;&#125;".format(score2)) # 封面,网站两个&lt;img&gt;标签，两个src资源无法区分，通过pycharm获取html源代码,src标签是不一样的 image = movie.xpath('a[@class="image-link"]/img/@data-src')[0] print(image) print("-"*20) rank_list.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1+score2, 'image': image &#125;) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) return rank_listdef write_to_file(content): '''写入文件''' with open('result.txt', 'a', encoding='utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False)+'\n\n')if __name__ == '__main__': #spider() for i in range(0, 100, 10): for item in spider(i): write_to_file(item) 爬取结果输出结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703C:\ProgramData\Anaconda3\python.exe F:/Python+/Spider/Maoyan.py排名:1《霸王别姬》主演：张国荣,张丰毅,巩俐上映时间：1993-01-01评分:9.6https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c--------------------排名:2《肖申克的救赎》主演：蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿上映时间：1994-10-14(美国)评分:9.5https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@160w_220h_1e_1c--------------------排名:3《罗马假日》主演：格利高里·派克,奥黛丽·赫本,埃迪·艾伯特上映时间：1953-09-02(美国)评分:9.1https://p0.meituan.net/movie/54617769d96807e4d81804284ffe2a27239007.jpg@160w_220h_1e_1c--------------------排名:4《这个杀手不太冷》主演：让·雷诺,加里·奥德曼,娜塔莉·波特曼上映时间：1994-09-14(法国)评分:9.5https://p0.meituan.net/movie/e55ec5d18ccc83ba7db68caae54f165f95924.jpg@160w_220h_1e_1c--------------------排名:5《教父》主演：马龙·白兰度,阿尔·帕西诺,詹姆斯·肯恩上映时间：1972-03-24(美国)评分:9.3https://p1.meituan.net/movie/f5a924f362f050881f2b8f82e852747c118515.jpg@160w_220h_1e_1c--------------------排名:6《泰坦尼克号》主演：莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩上映时间：1998-04-03评分:9.5https://p1.meituan.net/movie/0699ac97c82cf01638aa5023562d6134351277.jpg@160w_220h_1e_1c--------------------排名:7《唐伯虎点秋香》主演：周星驰,巩俐,郑佩佩上映时间：1993-07-01(中国香港)评分:9.2https://p0.meituan.net/movie/da64660f82b98cdc1b8a3804e69609e041108.jpg@160w_220h_1e_1c--------------------排名:8《千与千寻》主演：柊瑠美,入野自由,夏木真理上映时间：2001-07-20(日本)评分:9.3https://p0.meituan.net/movie/b076ce63e9860ecf1ee9839badee5228329384.jpg@160w_220h_1e_1c--------------------排名:9《魂断蓝桥》主演：费雯·丽,罗伯特·泰勒,露塞尔·沃特森上映时间：1940-05-17(美国)评分:9.2https://p0.meituan.net/movie/46c29a8b8d8424bdda7715e6fd779c66235684.jpg@160w_220h_1e_1c--------------------排名:10《乱世佳人》主演：费雯·丽,克拉克·盖博,奥利维娅·德哈维兰上映时间：1939-12-15(美国)评分:9.1https://p0.meituan.net/movie/230e71d398e0c54730d58dc4bb6e4cca51662.jpg@160w_220h_1e_1c--------------------排名:11《天空之城》主演：寺田农,鹫尾真知子,龟山助清上映时间：1992评分:9.1https://p1.meituan.net/movie/ba1ed511668402605ed369350ab779d6319397.jpg@160w_220h_1e_1c--------------------排名:12《喜剧之王》主演：周星驰,莫文蔚,张柏芝上映时间：1999-02-13(中国香港)评分:9.2https://p1.meituan.net/movie/18e3191039d5e71562477659301f04aa61905.jpg@160w_220h_1e_1c--------------------排名:13《辛德勒的名单》主演：连姆·尼森,拉尔夫·费因斯,本·金斯利上映时间：1993-12-15(美国)评分:9.2https://p1.meituan.net/movie/39ed7a0941a3604bba78d299b11a18ce119679.jpg@160w_220h_1e_1c--------------------排名:14《大闹天宫》主演：邱岳峰,毕克,富润生上映时间：1965-12-31评分:9.0https://p1.meituan.net/movie/14a7b337e8063e3ce05a5993ed80176b74208.jpg@160w_220h_1e_1c--------------------排名:15《音乐之声》主演：朱莉·安德鲁斯,克里斯托弗·普卢默,埃琳诺·帕克上映时间：1965-03-02(美国)评分:9.0https://p1.meituan.net/movie/6bc004d57358ee6875faa5e9a1239140128550.jpg@160w_220h_1e_1c--------------------排名:16《剪刀手爱德华》主演：约翰尼·德普,薇诺娜·瑞德,黛安·韦斯特上映时间：1990-12-06(美国)评分:8.8https://p1.meituan.net/movie/0e91ffcfa7e53449216cc29ee8af513a75791.jpg@160w_220h_1e_1c--------------------排名:17《春光乍泄》主演：张国荣,梁朝伟,张震上映时间：1997-05-30(中国香港)评分:9.2https://p0.meituan.net/movie/ae7245920d95c03765fe1615f3a1fe3865785.jpg@160w_220h_1e_1c--------------------排名:18《美丽人生》主演：罗伯托·贝尼尼,尼可莱塔·布拉斯基,乔治·坎塔里尼上映时间：1997-12-20(意大利)评分:9.3https://p0.meituan.net/movie/43d259ecbcd53e8bbe902632772281d6327525.jpg@160w_220h_1e_1c--------------------排名:19《海上钢琴师》主演：蒂姆·罗斯,普路特·泰勒·文斯,比尔·努恩上映时间：1998-10-28(意大利)评分:9.2https://p1.meituan.net/movie/c15b7623cce2f51c75562a3baefe507b68290.jpg@160w_220h_1e_1c--------------------排名:20《黑客帝国》主演：基努·里维斯,凯瑞-安·莫斯,劳伦斯·菲什伯恩上映时间：2000-01-14评分:9.0https://p1.meituan.net/movie/d981a12f59d3cc92ff666094404ad8f0211220.jpg@160w_220h_1e_1c--------------------排名:21《加勒比海盗》主演：约翰尼·德普,凯拉·奈特莉,奥兰多·布鲁姆上映时间：2003-11-21评分:8.9https://p1.meituan.net/movie/b449893ebc63d5c54eb4a5b60341f334383831.jpg@160w_220h_1e_1c--------------------排名:22《指环王3：王者无敌》主演：伊莱贾·伍德,伊恩·麦克莱恩,丽芙·泰勒上映时间：2004-03-15评分:9.2https://p0.meituan.net/movie/932bdfbef5be3543e6b136246aeb99b8123736.jpg@160w_220h_1e_1c--------------------排名:23《哈利·波特与魔法石》主演：丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃特森上映时间：2002-01-26评分:9.1https://p1.meituan.net/movie/aacb9ed2a6601bfe515ef0970add1715623792.jpg@160w_220h_1e_1c--------------------排名:24《无间道》主演：刘德华,梁朝伟,黄秋生上映时间：2003-09-05评分:9.1https://p1.meituan.net/movie/0d93b5b585ce29c6688e43f3989fb41f86421.jpg@160w_220h_1e_1c--------------------排名:25《射雕英雄传之东成西就》主演：张国荣,梁朝伟,张学友上映时间：1993-02-05(中国香港)评分:8.9https://p1.meituan.net/movie/53b6f0b66882a53b08896c92076515a8236400.jpg@160w_220h_1e_1c--------------------排名:26《楚门的世界》主演：金·凯瑞,劳拉·琳妮,诺亚·艾默里奇上映时间：1998-06-01(美国)评分:8.9https://p0.meituan.net/movie/8959888ee0c399b0fe53a714bc8a5a17460048.jpg@160w_220h_1e_1c--------------------排名:27《蝙蝠侠：黑暗骑士》主演：克里斯蒂安·贝尔,希斯·莱杰,阿伦·伊克哈特上映时间：2008-07-18(美国)评分:9.3https://p0.meituan.net/movie/d12a1c198ad9ffac72b5db57feacb449294699.jpg@160w_220h_1e_1c--------------------排名:28《教父2》主演：阿尔·帕西诺,罗伯特·德尼罗,黛安·基顿上映时间：1974-12-12(美国)评分:9.0https://p1.meituan.net/movie/7bac8bfa6739c18620065132ce9c64fa85110.jpg@160w_220h_1e_1c--------------------排名:29《指环王2：双塔奇兵》主演：伊莱贾·伍德,伊恩·麦克莱恩,丽芙·泰勒上映时间：2003-04-25评分:9.1https://p0.meituan.net/movie/5cfa597a98b35ee4ee598695942641ba287922.jpg@160w_220h_1e_1c--------------------排名:30《机器人总动员》主演：本·贝尔特,艾丽莎·奈特,杰夫·格尔林上映时间：2008-06-27(美国)评分:9.3https://p1.meituan.net/movie/4592eef6b6dffcd1d950f55f41ab098f239816.jpg@160w_220h_1e_1c--------------------排名:31《天堂电影院》主演：菲利浦·诺瓦雷,赛尔乔·卡斯特利托,蒂兹亚娜·罗达托上映时间：1988-11-17(意大利)评分:9.2https://p1.meituan.net/movie/618e57ddb3173de6bbf2e278946b11f279679.jpg@160w_220h_1e_1c--------------------排名:32《活着》主演：葛优,巩俐,牛犇上映时间：1994-05-18(法国)评分:9.0https://p0.meituan.net/movie/4c41068ef7608c1d4fbfbe6016e589f7204391.jpg@160w_220h_1e_1c--------------------排名:33《拯救大兵瑞恩》主演：汤姆·汉克斯,马特·达蒙,汤姆·塞兹摩尔上映时间：1998-07-24(美国)评分:8.9https://p1.meituan.net/movie/779bcc212a50a2526343362778f6b63c334618.jpg@160w_220h_1e_1c--------------------排名:34《哈尔的移动城堡》主演：倍赏千惠子,木村拓哉,美轮明宏上映时间：2004-11-20(日本)评分:9.0https://p0.meituan.net/movie/0127b451d5b8f0679c6f81c8ed414bb2432442.jpg@160w_220h_1e_1c--------------------排名:35《阿凡达》主演：萨姆·沃辛顿,佐伊·索尔达娜,米歇尔·罗德里格兹上映时间：2010-01-04评分:9.1https://p1.meituan.net/movie/91f575ec93f019f428d1f33e3ceca7c5115495.jpg@160w_220h_1e_1c--------------------排名:36《盗梦空间》主演：莱昂纳多·迪卡普里奥,渡边谦,约瑟夫·高登-莱维特上映时间：2010-09-01评分:9.2https://p1.meituan.net/movie/2f344a9f9575edbcae9f0abe0578bc90339773.jpg@160w_220h_1e_1c--------------------排名:37《忠犬八公的故事》主演：Forest,理查·基尔,琼·艾伦上映时间：2010-03-12(英国)评分:9.3https://p0.meituan.net/movie/7787c10ad5e95b03cf83ef9473500d8e282796.jpg@160w_220h_1e_1c--------------------排名:38《幽灵公主》主演：松田洋治,石田百合子,田中裕子上映时间：1997-07-12(日本)评分:8.9https://p0.meituan.net/movie/6ab1882a217e848acceb240365043d53329196.jpg@160w_220h_1e_1c--------------------排名:39《搏击俱乐部》主演：爱德华·哈里森·诺顿,布拉德·皮特,海伦娜·伯翰·卡特上映时间：1999-10-15(美国)评分:8.8https://p1.meituan.net/movie/c5e76795bf7a78b12a2ffabb4a0c5c11112921.jpg@160w_220h_1e_1c--------------------排名:40《东邪西毒》主演：张国荣,梁朝伟,刘嘉玲上映时间：1994-09-17评分:8.8https://p1.meituan.net/movie/7e471a9171a410ebc9413b2f1de67afc130067.jpg@160w_220h_1e_1c--------------------排名:41《风之谷》主演：岛本须美,永井一郎,坂本千夏上映时间：1992评分:8.9https://p0.meituan.net/movie/4f9638ba234c3fb673f23a09968db875371576.jpg@160w_220h_1e_1c--------------------排名:42《疯狂原始人》主演：尼古拉斯·凯奇,艾玛·斯通,瑞安·雷诺兹上映时间：2013-04-20评分:9.5https://p1.meituan.net/movie/d5e5e53ef9bbd98223e83df261b51b84103223.jpg@160w_220h_1e_1c--------------------排名:43《当幸福来敲门》主演：威尔·史密斯,贾登·史密斯,坦迪·牛顿上映时间：2008-01-17评分:8.9https://p1.meituan.net/movie/5896de3c1474277730e321c9b1db04a9205644.jpg@160w_220h_1e_1c--------------------排名:44《V字仇杀队》主演：娜塔莉·波特曼,雨果·维文,斯蒂芬·瑞上映时间：2006-03-17(美国)评分:8.8https://p1.meituan.net/movie/4a4c84aa103ab47202f1aa907c5542a4128882.jpg@160w_220h_1e_1c--------------------排名:45《十二怒汉》主演：亨利·方达,李·科布,马丁·鲍尔萨姆上映时间：1957-04-13(美国)评分:9.1https://p0.meituan.net/movie/df15efd261060d3094a73ef679888d4f238149.jpg@160w_220h_1e_1c--------------------排名:46《放牛班的春天》主演：热拉尔·朱尼奥,让-巴蒂斯特·莫尼耶,玛丽·布奈尔上映时间：2004-10-16评分:8.8https://p0.meituan.net/movie/7cd18fcf0b4f9180500124711e81492994030.jpg@160w_220h_1e_1c--------------------排名:47《三傻大闹宝莱坞》主演：阿米尔·汗,黄渤,卡琳娜·卡普上映时间：2011-12-08评分:9.1https://p0.meituan.net/movie/4bb144bc0a674ba6908349018fd092e6330929.jpg@160w_220h_1e_1c--------------------排名:48《勇敢的心》主演：梅尔·吉布森,苏菲·玛索,帕特里克·麦高汉上映时间：1995-05-24(美国)评分:8.8https://p1.meituan.net/movie/f8e9d5a90224746d15dfdbd53d4fae3d209420.jpg@160w_220h_1e_1c--------------------排名:49《黑客帝国3：矩阵革命》主演：基努·里维斯,雨果·维文,凯瑞-安·莫斯上映时间：2003-11-05评分:8.8https://p1.meituan.net/movie/5ca6ffcbb994a51cd6215e7c4fff2d9b71039.jpg@160w_220h_1e_1c--------------------排名:50《速度与激情5》主演：范·迪塞尔,保罗·沃克,道恩·强森上映时间：2011-05-12评分:9.2https://p1.meituan.net/movie/1d0fa86bcf7a44484b9c16ac6af5be68191952.jpg@160w_220h_1e_1c--------------------排名:51《驯龙高手》主演：杰伊·巴鲁切尔,杰拉德·巴特勒,亚美莉卡·费雷拉上映时间：2010-05-14评分:9.0https://p1.meituan.net/movie/8194ae885ed9419aadf35c196af86ba4239039.jpg@160w_220h_1e_1c--------------------排名:52《少年派的奇幻漂流》主演：苏拉·沙玛,伊尔凡·可汗,塔布上映时间：2012-11-22评分:9.1https://p0.meituan.net/movie/34998e31c6d07475f1add6b8b16fd21d192579.jpg@160w_220h_1e_1c--------------------排名:53《神偷奶爸》主演：史蒂夫·卡瑞尔,杰森·席格尔,拉塞尔·布兰德上映时间：2010-07-09(美国)评分:9.0https://p0.meituan.net/movie/85c2bfba6025bfbfb53291ae5924c215308805.jpg@160w_220h_1e_1c--------------------排名:54《闻香识女人》主演：阿尔·帕西诺,克里斯·奥唐纳,加布里埃尔·安瓦尔上映时间：1992-12-23(美国)评分:8.8https://p0.meituan.net/movie/7cb7965469cb7ff95613714389f1ea3d87743.jpg@160w_220h_1e_1c--------------------排名:55《断背山》主演：希斯·莱杰,杰克·吉伦哈尔,米歇尔·威廉姆斯上映时间：2006-01-13(美国)评分:9.0https://p0.meituan.net/movie/e71affe126eeb4f8bfcc738cbddeebc8288766.jpg@160w_220h_1e_1c--------------------排名:56《飞屋环游记》主演：爱德华·阿斯纳,乔丹·长井,鲍勃·彼德森上映时间：2009-08-04评分:8.9https://p0.meituan.net/movie/47dd790e19dad72b50580641de5608c5199014.jpg@160w_220h_1e_1c--------------------排名:57《大话西游之月光宝盒》主演：周星驰,莫文蔚,吴孟达上映时间：2014-10-24评分:9.6https://p0.meituan.net/movie/92eb862c42c49f8e41e459c369c4512b226610.jpg@160w_220h_1e_1c--------------------排名:58《飞越疯人院》主演：杰克·尼科尔森,路易丝·弗莱彻,威尔·萨姆森上映时间：1975-11-19(美国)评分:8.8https://p1.meituan.net/movie/4dddd98730274c3b1464ff0a0ad195e5233381.jpg@160w_220h_1e_1c--------------------排名:59《怦然心动》主演：玛德琳·卡罗尔,卡兰·麦克奥利菲,艾丹·奎因上映时间：2010-08-06(美国)评分:8.9https://p0.meituan.net/movie/457a35fda360cb72090fa6dcbd1db3c1275333.jpg@160w_220h_1e_1c--------------------排名:60《美国往事》主演：罗伯特·德尼罗,詹姆斯·伍兹,伊丽莎白·麦戈文上映时间：1984-02-17(美国)评分:9.1https://p1.meituan.net/movie/92198a6fc8c3f5d13aa1bdf203572c0f99438.jpg@160w_220h_1e_1c--------------------排名:61《致命魔术》主演：休·杰克曼,克里斯蒂安·贝尔,迈克尔·凯恩上映时间：2006-10-20(美国)评分:8.8https://p1.meituan.net/movie/75c0d3eb584be030a01f2e26741a8f41251454.jpg@160w_220h_1e_1c--------------------排名:62《鬼子来了》主演：姜文,姜宏波,陈强上映时间：2000-05-12(法国戛纳)评分:8.9https://p1.meituan.net/movie/0b507aa44c4dfbbcc91949b69b1b39a168922.jpg@160w_220h_1e_1c--------------------排名:63《无敌破坏王》主演：约翰·C·赖利,萨拉·西尔弗曼,简·林奇上映时间：2012-11-06评分:9.1https://p0.meituan.net/movie/fcc17667b8343131101eeb4c67d90bf9150883.jpg@160w_220h_1e_1c--------------------排名:64《美丽心灵》主演：罗素·克洛,詹妮弗·康纳利,艾德·哈里斯上映时间：2001-12-21(美国)评分:8.8https://p0.meituan.net/movie/7b7d1f8aa36d7a15463ce6942708a1a7265296.jpg@160w_220h_1e_1c--------------------排名:65《蝙蝠侠：黑暗骑士崛起》主演：克里斯蒂安·贝尔,迈克尔·凯恩,加里·奥德曼上映时间：2012-08-27评分:8.9https://p1.meituan.net/movie/96bb58f3e9d213fb0438987d16d27561379209.jpg@160w_220h_1e_1c--------------------排名:66《夜访吸血鬼》主演：汤姆·克鲁斯,布拉德·皮特,克尔斯滕·邓斯特上映时间：1994-11-11(美国)评分:8.8https://p0.meituan.net/movie/7ec873ba943f13e3c63789d899bd0e23256871.jpg@160w_220h_1e_1c--------------------排名:67《倩女幽魂》主演：张国荣,王祖贤,午马上映时间：2011-04-30评分:9.2https://p1.meituan.net/movie/6d0510f326bf145dcf49a901fb949b77278838.jpg@160w_220h_1e_1c--------------------排名:68《哈利·波特与死亡圣器（下）》主演：丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃特森上映时间：2011-08-04评分:9.0https://p1.meituan.net/movie/68fa7db99e958c47d7aa07d015845a6f335154.jpg@160w_220h_1e_1c--------------------排名:69《本杰明·巴顿奇事》主演：布拉德·皮特,凯特·布兰切特,塔拉吉·P·汉森上映时间：2008-12-25(美国)评分:8.8https://p0.meituan.net/movie/2526f77c650bf7cf3d5ee2dccdeac332244951.jpg@160w_220h_1e_1c--------------------排名:70《钢琴家》主演：艾德里安·布洛迪,艾米莉娅·福克斯,米哈乌·热布罗夫斯基上映时间：2002-09-25(法国)评分:8.8https://p1.meituan.net/movie/484171372de45945e8bbbcc97db57e09136701.jpg@160w_220h_1e_1c--------------------排名:71《触不可及》主演：弗朗索瓦·克鲁塞,奥玛·希,安娜·勒尼上映时间：2011-11-02(法国)评分:9.1https://p0.meituan.net/movie/7874ba1378033b0b491df0cc56c43d25221208.jpg@160w_220h_1e_1c--------------------排名:72《熔炉》主演：孔刘,郑有美,金智英上映时间：2011-09-22(韩国)评分:8.8https://p1.meituan.net/movie/4ad513be2e9419ec7d7d63ba8cc2b6cc134065.jpg@160w_220h_1e_1c--------------------排名:73《初恋这件小事》主演：马里奥·毛瑞尔,平采娜·乐维瑟派布恩,阿查拉那·阿瑞亚卫考上映时间：2012-06-05评分:8.8https://p1.meituan.net/movie/7ed07b8ea8c0e0d0c7b685d20e3ec64e232004.jpg@160w_220h_1e_1c--------------------排名:74《大话西游之大圣娶亲》主演：周星驰,朱茵,莫文蔚上映时间：2014-10-24评分:8.8https://p1.meituan.net/movie/dc2246233a6f5ac1e34c7176b602c8ca174557.jpg@160w_220h_1e_1c--------------------排名:75《新龙门客栈》主演：张曼玉,梁家辉,甄子丹上映时间：2012-02-24评分:8.8https://p0.meituan.net/movie/9e9f12cfc1f54c973dda6c85bd3a139d334520.jpg@160w_220h_1e_1c--------------------排名:76《甜蜜蜜》主演：黎明,张曼玉,曾志伟上映时间：2015-02-13评分:9.2https://p1.meituan.net/movie/8ad5a0f521fb15637dfdf9cab38d414453783.jpg@160w_220h_1e_1c--------------------排名:77《小鞋子》主演：默罕默德·阿米尔·纳吉,Kamal Mirkarimi,Behzad Rafi上映时间：1999-01-22(美国)评分:9.1https://p1.meituan.net/movie/bc7b6ababa54e11577d45c05e84a33af54072.jpg@160w_220h_1e_1c--------------------排名:78《素媛》主演：李来,薛耿求,严志媛上映时间：2013-10-02(韩国)评分:9.1https://p0.meituan.net/movie/4cc4c55c29b77b090485ce9943bf6f87274708.jpg@160w_220h_1e_1c--------------------排名:79《萤火之森》主演：内山昂辉,佐仓绫音,后藤弘树上映时间：2011-09-17(日本)评分:9.0https://p0.meituan.net/movie/5420be40e3b755ffe04779b9b199e935256906.jpg@160w_220h_1e_1c--------------------排名:80《时空恋旅人》主演：瑞秋·麦克亚当斯,多姆纳尔·格里森,比尔·奈伊上映时间：2013-09-04(英国)评分:8.9https://p0.meituan.net/movie/4abc8c932cfacfc0089e2883765d02d1295222.jpg@160w_220h_1e_1c--------------------排名:81《穿条纹睡衣的男孩》主演：阿沙·巴特菲尔德,维拉·法梅加,大卫·休里斯上映时间：2008-09-12(英国)评分:9.0https://p1.meituan.net/movie/a0e0426a4390f5ecb49d25770a184dc0150779.jpg@160w_220h_1e_1c--------------------排名:82《窃听风暴》主演：乌尔里希·穆埃,塞巴斯蒂安·科赫,马蒂娜·格德克上映时间：2006-03-23(德国)评分:9.0https://p0.meituan.net/movie/3985eaf3858bea0f2a3d966bf7ee2103178217.jpg@160w_220h_1e_1c--------------------排名:83《借东西的小人阿莉埃蒂》主演：志田未来,神木隆之介,大竹忍上映时间：2010-07-17(日本)评分:8.8https://p0.meituan.net/movie/ce262f261f69fc3d679020402336a4af270365.jpg@160w_220h_1e_1c--------------------排名:84《恐怖直播》主演：河正宇,李璟荣,李大为上映时间：2013-07-31(韩国)评分:8.8https://p0.meituan.net/movie/b5ff0216e689b3fcc065590c48cd5105255305.jpg@160w_220h_1e_1c--------------------排名:85《7号房的礼物》主演：柳承龙,郑镇荣,朴信惠上映时间：2013-01-23(韩国)评分:8.9https://p1.meituan.net/movie/6a6e74b2c289f9fa4433dd2dc04a7741331638.jpg@160w_220h_1e_1c--------------------排名:86《海豚湾》主演：里克·奥巴瑞,路易·西霍尤斯,哈迪·琼斯上映时间：2009-07-31(美国)评分:8.9https://p0.meituan.net/movie/7373dbba07b50ce6f24336edb96b2ea4271536.jpg@160w_220h_1e_1c--------------------排名:87《忠犬八公物语》主演：仲代达矢,春川真澄,井川比佐志上映时间：1987-08-01(日本)评分:9.0https://p1.meituan.net/movie/c835b3588d0061ed3b992388a0a96f15160913.jpg@160w_220h_1e_1c--------------------排名:88《上帝之城》主演：亚历桑德雷·罗德里格斯,艾莉丝·布拉加,莱安德鲁·菲尔米诺上映时间：2002-08-30(巴西)评分:8.9https://p1.meituan.net/movie/b553d13f30100db731ab6cf45668e52d94703.jpg@160w_220h_1e_1c--------------------排名:89《辩护人》主演：宋康昊,郭度沅,吴达洙上映时间：2013-12-18(韩国)评分:8.8https://p0.meituan.net/movie/8fabf3894b7d12d3d2f6e66404813670265761.jpg@160w_220h_1e_1c--------------------排名:90《七武士》主演：三船敏郎,志村乔,千秋实上映时间：1954-04-26(日本)评分:9.1https://p1.meituan.net/movie/73349facab53529ab9e079c6c8c7c059281729.jpg@160w_220h_1e_1c--------------------排名:91《英雄本色》主演：狄龙,张国荣,周润发上映时间：2017-11-17评分:9.2https://p0.meituan.net/movie/3e5f5f3aa4b7e5576521e26c2c7c894d253975.jpg@160w_220h_1e_1c--------------------排名:92《一一》主演：吴念真,金燕玲,李凯莉上映时间：2000-09-20(法国)评分:8.9https://p1.meituan.net/movie/2c0a5fedf4b43d142121b91c6ccabe1b59051.jpg@160w_220h_1e_1c--------------------排名:93《完美的世界》主演：凯文·科斯特纳,克林特·伊斯特伍德,T·J·劳瑟上映时间：1993-11-24(美国)评分:8.9https://p1.meituan.net/movie/30310858fdab34c7a17cfd7ec8ad8bfc112201.jpg@160w_220h_1e_1c--------------------排名:94《海洋》主演：雅克·贝汉,姜文,兰斯洛特·佩林上映时间：2011-08-12评分:9.0https://p0.meituan.net/movie/0018b57299d0d4540330a31244c880a9112971.jpg@160w_220h_1e_1c--------------------排名:95《爱·回家》主演：俞承豪,金艺芬,童孝熙上映时间：2002-04-05(韩国)评分:9.0https://p1.meituan.net/movie/36a893c53a13f9bb934071b86ae3b5c492427.jpg@160w_220h_1e_1c--------------------排名:96《黄金三镖客》主演：克林特·伊斯特伍德,李·范·克里夫,埃里·瓦拉赫上映时间：1966-12-23(意大利)评分:8.9https://p1.meituan.net/movie/9bff56ed3ea38bb1825daa1d354bc92352781.jpg@160w_220h_1e_1c--------------------排名:97《我爱你》主演：宋在浩,李顺才,尹秀晶上映时间：2011-02-17(韩国)评分:9.0https://p1.meituan.net/movie/ed50b58bf636d207c56989872a91f4cf305138.jpg@160w_220h_1e_1c--------------------排名:98《迁徙的鸟》主演：雅克·贝汉,Philippe Labro上映时间：2001-12-12(法国)评分:9.1https://p1.meituan.net/movie/a1634f4e49c8517ae0a3e4adcac6b0dc43994.jpg@160w_220h_1e_1c--------------------排名:99《阿飞正传》主演：张国荣,张曼玉,刘德华上映时间：2018-06-25评分:8.8https://p0.meituan.net/movie/885fc379c614a2b4175587b95ac98eb95045650.jpg@160w_220h_1e_1c--------------------排名:100《龙猫》主演：帕特·卡洛尔,蒂姆·达利,丽娅·萨隆加上映时间：2018-12-14评分:9.2https://p0.meituan.net/movie/c304c687e287c7c2f9e22cf78257872d277201.jpg@160w_220h_1e_1c--------------------Process finished with exit code 0 保存到txt文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <url>%2F2019%2F01%2F14%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[切片 产生列表的子集字符串、列表、元组都支持切片操作切片的语法：[起始 ： 结束 ：步长]左闭右开 步长表示选取的间隔 默认是 1 1234567字符串切片name = "abcdefghijk"print(name[4:6]) # 取下表4-6，也就是name[4],name[5]print(name[2:]) # 结束缺省，表示取下标为2开始到最后的字符print(name[:3]) # 开始缺省，表示取开始到下标为3之前的字符print(name[1:-1]) # 负数索引返回离列表末尾相应距离的元素print(name[::-1]) # 步长为负， 表示从后往前切片 1234列表切片cars = ['Audi', 'BMW', 'BenZi', 'Toyota']print(cars[::-1]) # 逆序输出列表,实际结构没有发生改变print(cars[1:3]) # 产生列表的子集，切片始于'BMW',终于‘Benzi’ 123456切片的应用# 实现 [1，2，3，4....100]变成[[1,2,3],[4,5,6],...]a = [x for x in range(1, 101)]print(a)b = [a[x:x+3] for x in range(0, len(a), 3)] # 产生列表的子集print(b) 可变的类型 ： 列表List 字典Dict 集合Set列表List1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 列表nameList = ['zhangsan', 'lisi', 1234]# 打印列表print(nameList)# 访问print(nameList[0])# for循环遍历for name in nameList: print(name)# while循环遍历i = 0while i &lt; len(nameList): print(nameList[i]) i += 1# 列表的相关操作# 1. 添加元素# append()A = ['zhangsan', 'lisi', 1234]temp = input("请输入学生姓名:")A.append(temp)print(A)# extend()可以将另一个元素逐一追加到列表中,append是整体添加a = [1, 2]b = [3, 4]a.append(b)print(a)a.extend(b)print(a)# insert() 在指定位置插入元素(位置，元素)c = [0, 1, 2]c.insert(1, '3')print(c)# 2.修改操作A = ['xiaoming', 'xiaohong', 1234]A[1] = '小红'print(A)# 3.查询# in / not in / index / count# innameList = ['xiaoming', 'xiaohong', 1234]findName = input("请输入要查找的姓名")if findName in nameList: print("你要找的人在列表中")else: print("没找到")#index 返回第一次出现的序号#count 返回出现的次数a = ['a', 'b', 'c', 'a', 'b']index = a.index('a')print(index)count = a.count('a')print(count)# 4.删除nameList = ['xiaoming', 'xiaohong', 1234]# del 根据下表删除del nameList[2]print(nameList)# popprint(nameList)nameList.pop()print(nameList)# remove 根据元素的值进行删除a = ['a', 'b', 'c', 'a', 'b']print(a)a.remove('a')print(a)# 排序a = [1, 3, 4, 2]b = [1, 3, 4, 2]# sort()正序a.sort()#a.reverse(sort=True)print(a)# reverse() 逆序 也可以写作sort(reverse=True)，反过来不可以b.sort(reverse=True)#b.reverse()print(a) 1234567891011121314151617181920212223242526# 一个学校，有三个办公室，8位老师等待分配工位，完成随机分配# 定义一个列表import stringimport random# 定义一个列表来保存3个办公室offices = [[], [], []]# 定义一个列表来保存8个教师姓名names = []for i in range(8): names.append(string.ascii_uppercase[i])for name in names: index = random.randint(0, 2) offices[index].append(name)# print(offices)# 遍历展示i = 1for tempNames in offices: print("办公室%d的人数为 %d : " % (i, len(tempNames)), end='') i += 1 for name in tempNames: print("%s" % name, end=' ') print() print('-'*30) 字典Dict12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 字典 &#123;key1: value1, key2: value2&#125;info = &#123;'name': '马云', id: 100, 'sex': 'm', 'address': '杭州'&#125;# 根据键 进行访问# key: valueprint(info[id])# 访问不存在的键会报错#print(info['age']) #keyError: 'age‘# 面向对象的访问, 若不存在，返回默认值age = info.get('age', 18)print(age)print(type(age))# 常见操作# 1. 查看info = &#123;'name': '西卡', 'age': 26&#125;print(info['age'])# 修改age = input("请输入年龄:")info['age'] = ageprint(info)# 添加 键不存在，就会新增这个元素add = input("请输入户籍所在地:")info['address'] = addprint(info)# 删除 del删除字典某个元素 clear()清空字典# del info['address']# print(info)# info.clear()# print(info)# 字典方法# len() 键值对个数 以列表方式储存print(len(info))# keys()返回所有键 values() 返回所有值 以列表方式储存print(info.keys())print(info.values())# items 返回键值对列表 以列表方式储存print(info.items())# 字典的遍历# key()for key in info.keys(): print(key)# valuefor value in info.values(): print(value)# 项 (元素)for item in info.items(): print(item)for key, value in info.items(): print(key, value)# for 循环迭代# chars = ['a', 'b', 'c', 'd']# for i, chr in enumerate(chars):# print(i, chr) 集合Set123456789101112131415161718# 集合# 无序 元素唯一 一般用于元组或列表的元素去重set1 = &#123;1, 2, 3, 4&#125;# 添加元素 add()set1.add(9)print(set1)# 修改元素 update()set1.update('abcd')print(set1)# 删除元素 remove()不存在会报错set1.remove(1)print(set1)# pop 随机删除集合中某个元素set1.pop()print(set1)# discard 丢弃，放弃，不会报错set1.discard(123)print(set1) 不可变的类型 ：数字Num 字符串Str 元组Tuple数字NumPython Number 数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。 字符串StrPython不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。Python访问子字符串，可以使用方括号来截取字符串1234str = 'today is Sunday'print(str[4])print(len(str))print(type(str)) 元组Tuple123456789101112131415161718# 元组 tuple# python 中的元组和列表类似，元组的元素是无法进行修改的# 元组() 列表[]# return a, b, caTuple = ('et', 77 , 3.14)print(aTuple)print(type(aTuple))# 元组中只有一个元素，需要逗号结尾，否则会引起歧异bTuple = (12,)print(type(bTuple))# 访问元组print(aTuple[1])# 修改元组 不支持修改# aTuple[0] = 123# count indexa = ('a', 'b', 'c', 'd')print(a.index('a', 0, 3))print(a.count('b'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell读取文件并批量添加用户]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[在linux中要求从一个文件中读取用户名和密码，并批量添加账户 文件格式：12345[root@localhost jeremy]# cat users.list apple 12345banana 123456orange 123123pear 123123 第一步：读取用户名和密码 创建 user.sh文件 按行读取用户信息12345678910111213[root@localhost jeremy]# vim user.sh[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo echo $linedone[root@localhost jeremy]# ./user.sh apple 12345banana 123456orange 123123pear 123123 读取每一行内容并输出有多种方式12345678910111213141516171819202122232425262728293031&gt; 第一种 while&gt; while read line&gt; do&gt; echo $line&gt; done &lt; filename&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第二种 while&gt; cat filename | while read line&gt; do&gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第三种 for&gt; for line in `cat filename`&gt; do &gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for循环在读取文件时，任何空白字符都可以作为其读取的分隔符.&gt; while使用是换行符作为标记&gt; ex: &gt; for line in $(&lt;users.list) 结果如下&gt; apple&gt; 12345&gt; banana&gt; 123456&gt; orange&gt; 123123&gt; pear&gt; 123123&gt; 第二步：分割用户名和密码123456789101112131415[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` echo -n "USERNAME:$username PASSWORD:$password" echodone [root@localhost jeremy]# ./user.sh USERNAME:apple PASSWORD:12345USERNAME:banana PASSWORD:123456USERNAME:orange PASSWORD:123123USERNAME:pear PASSWORD:123123 第三步：批量添加用户12345678910111213141516171819[root@localhost jeremy]# cat user.sh#!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` useradd $username echo $password | passwd --stdin $usernamedone [root@localhost jeremy]# ./user.sh 更改用户 apple 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 banana 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 orange 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 pear 的密码 。passwd：所有的身份验证令牌已经成功更新。 第四步：完善脚本以上脚本再运行一便，会发现新增用户不行了。但会修改了密码.应该增加一个用户是否存在的判断.另外所有非Shell内建命令都建议使用全路径，以避免由于环境变量的问题造成command not found。最后，脚本主体要尽量少使用变量，所以需要在脚本开头定义变量.如下：12345678910111213141516!/bin/bashUSER_INFO=/home/jeremy/users.listUSERADD=/usr/sbin/useraddPASSWD=/usr/bin/passwdCUT=/bin/cutwhile read LINESdo USERNAME=`echo $LINES | $CUT -f1 -d' '` USERPASS=`echo $LINES | $CUT -f2 -d' '` $USERADD $USERNAME if [ $? -ne 0 ];then echo "$USERNAME exists,skip set password" else echo $USERPASS | $PASSWD --stdin $USERNAME fidone &lt; $USER_INFO]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本编程]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ShellShell 是一个用C语言编写的程序，它既是一种命令语言，又是一种程序设计语言。 Shell ScriptShell脚本，用shell编写的脚本程序 First Shell 创建一个.sh为文件后缀的文件，hello.sh 内容如下1234#!/bin/bash#注释#author : jeremyecho "Hello Shell !" 保存退出 先赋予执行权限 1# chmod a+x hello.sh 执行 1# ./hello.sh 变量定义变量123456variable_name=variable_value等号左右无空格ex:User="Jeremy"Pwd="123456" 访问变量使用美元符号$访问变量,可以给变量加上{ }花括号，帮助解释器识别变量的边界123456#！/bin/shUser="Jeremy"Pwd=“123456”echo $Userecho $&#123;Pwd&#125; 打印 User 和 Pwd 的值 只读变量使用readonly可以将变量定义为只读变量，只读变量的值不能改变1234#！/bin/shUser="Jeremy"readonly User 删除变量使用unset命令可以删除变量1234#！/bin/shUser="Jeremy"unset User 变量类型局部变量局部变量在脚本或命令中定义，仅在当前shell实例中有效 环境变量所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证正常运行，shell脚本也可以定义环境变量 shell变量shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 特殊变量1234567$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 数组ArraysBash Shell只支持一维数组，初始化时不需要定义数组大小1array_name=(value1...valueN) 定义数组123456array_name[index]=valueex:User[0]="apple"User[1]="banana"User[2]="orange" 访问数组和访问变量格式相同1234567891011$&#123;array_name[index]&#125;ex:User[0]="apple"User[1]="banana"User[2]="orange"echo $&#123;User[0]&#125;echo $&#123;User[@]&#125;以下两种方式可以访问数组中的所有项目$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 基本运算符Bourne shell没有任何机制来执行简单的算术，它使用外部程序awk或expr 运算符和表达式之间必须有空格 ` ` 倒逗号之间包含完整的表达式 1234#!/bin/shval=`expr 2 + 2`echo $val 算术运算符a=10b=20 运算符 说明 举例 + 加法 ` expr $a + $b ` 结果为 30。 - 减法 ` expr $a - $b ` 结果为 -10。 * 乘法 ` expr $a * $b ` 结果为 200。 / 除法 ` expr $b / $a ` 结果为 2。 % 取余 ` expr $b % $a ` 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等 [$a==$b] 返回 false。 != 不相等 [$a!=$b] 返回 true。 关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 Shell条件语句if … fishell expression求值，结果是true，statement被执行，否则不执行1234if[ expression ]then Statement(s) to be executed if expression is truefi if … else … fi123456if[ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi if … elif … fi123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi case .. esac这里的字符串字每个模式进行比较，直到找到一个匹配。执行语句匹配模式。如果没有找到匹配，声明退出的情况下不执行任何动作。没有最大数量的模式，但最小是一个。当语句部分执行，命令;; 表明程序流程跳转到结束整个 case 语句。和C编程语言的 break 类似。1234567891011case word in pattern1) Statement(s) to be executed if pattern1 matches ;; pattern2) Statement(s) to be executed if pattern2 matches ;; pattern3) Statement(s) to be executed if pattern3 matches ;;esac Shell循环类型while 循环这里Shell命令进行计算。如果结果值是 true，给定语句被执行。如果命令为 false，那么没有语句将不执行，程序将跳转到done语句后的下一行。1234while commanddo Statement(s) to be executed if command is truedone for 循环var是一个变量，word1 到 wordN 是由空格分隔的字符（字）序列的名称。每次for 循环的执行，变量var的值被设置为下一个单词的列表中的字，word1 到 wordN 。1234for var in word1 word2 ... wordNdo Statement(s) to be executed if command is truedone until 循环这里Shell命令进行评估计算。如果结果值是false，给定语句（s）被执行。如果命令没有语句为true，那么将不执行，程序会跳转到下一行done语句后。1234until commanddo Statement(s) to be executed until command is truedone select 循环var是一个变量，word1 到 wordN是由空格分隔的字符（字）序列的名称。每次for循环的执行，变量var的值被设置为下一个单词的列表中的字，由 word1 到wordN。 对于每一个选择的一组命令将被执行，在循环中。这个循环在ksh，并已被改编成的bash。这不是在sh。1234select var in word1 word2 ... wordNdo Statement(s) to be executed for every word.done]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[列出磁盘使用量df1# df [‐ahikHTm] 目录或文件名 -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes，MBytes，KBytes 等格式显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来 检查磁盘空间使用量du1# du [‐ahskm] 文件或目录名称 -a ：递归列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 ­s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显 磁盘分区fdisk1# fdisk [‐l] 装置名称（或者叫分区名称，下同） -l ：输出后面参数指定装置所有的分区内容。若仅有fdisk -l时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来 磁盘格式化1# mkfs [-t 文件系统格式] 装置名称（系统分区名称） -t ：可以指令文件系统格式，例如 xfs，ext4，ext3，ext2, vfat 等(系统有支持才会生 12将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：# mkfs ‐t ext3 /dev/hdc6 注意：如果一个分区已经格式化，则需要再次格式化时，可以加参数 -f 表示强制再次格式化。注意：如果一个分区已经挂载到一个目录之下，则不能在挂载的情况下进行再次格式化操作 磁盘检验fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck 命令对文件系统进行检查 1# fsck [‐t 文件系统] [‐ACay] 装置名称 -t ： 给定文件系统的格式，若在 /etc/fstab 中已有定义或 kernel 本身已支持的则需加上此参数-s ：依序一个一个地执行 fsck 的指令来检查-A ：对/etc/fstab 中所有列出来的 分区（partition）做检查-C ：显示完整的检查进度-d ：打印出 e2fsck 的 debug 结果-p ：同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R ：同时有 -A 条件时，省略 / 不检查-V ：详细显示模式-a ：如果检查有错则自动修复-r ：如果检查有错则由使用者回答是否修复-y ：选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复 磁盘挂载与卸载Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令 123456789101112131415挂载# mount [‐t 文件系统] [‐L Label名] [‐o 额外选项] [‐n] 装置文件名（也叫分区名称） 挂载点（也叫目录名）将刚刚创建的 /dev/hdc6 分区挂载到 /mnt/hdc6 上面# mkdir /mnt/hdc6# mount /dev/hdc6 /mnt/hdc6# dfFilesystem 1K‐blocks Used Available Use% Mounted on.....中间省略...../dev/hdc6 1976312 42072 1833836 3% /mnt/hd6卸载# umount /dev/hdc6-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况卸除]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux用户管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[系统用户账号的管理添加用户1# useradd &lt;选项&gt; 用户名 #添加新的用户账号 -c comment 指定一段用户注释性描述。-d 目录，指定用户主目录，如果此目录不存在，则同时配合使用-m 选项，可以自动创建主目录。-g 用户组，指定用户所属的用户组（主组）。-G 用户组，指定用户所属的附加组（可指定多个，当然并不建议太多个）。-s Shell 文件，指定用户的登录 Shell。默认是 /bin/bash，注意 /bin/bash 不等于是 /bin/sh。-u 用户号，指定用户的用户号，如果同时有-o 选项，则可以重复使用其它用户的标识 删除用户12# userdel 用户名 #删除用户# userdel -r 用户名 #把用户的主目录一起删除 修改账号1# usermod &lt;选项&gt; 用户名 #修改已有用户的信息 修改用户口令1# passwd &lt;选项&gt; 用户名 -l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令，即清除密码（设置空密码）-f 强迫用户下次登录时修改口令 系统用户组的管理增加用户组1# groupadd &lt;选项&gt; 用户组 -g GID 指定新用户组的组标识号（GID）。-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID相同。 删除用户组1# groupdel 用户组 修改用户组1# groupmod &lt;选项&gt; 用户组 -g GID 为用户组指定新的组标识号。-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。-n 新用户组，将用户组的名字改为新名字 切换用户组1# newgrp 用户组 与用户账号有关的系统文件/etc/passwd12# cat /etc/passwd用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/shadow/etc/shadow 中的记录行与 /etc/passwd 中的一一对应，它由 pwconv 命令根据/etc/passwd 中的数据自动产生。它的文件格式与 /etc/passwd 类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。“最小时间间隔”指的是两次修改口令之间所需的最小天数。“最大时间间隔”指的是口令保持有效的最大天数。“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了 /etc/group用户组的所有信息都存放在 /etc/group 文件中。此文件的格式也类似于 /etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与 /etc/passwd 中的登录名一样，组名不应重复。“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。”组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件基本属性及权限设置]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[文件基本属性123456789101112[jeremy@localhost ~]$ lltotal 0drwxrwxr-x. 2 jeremy jeremy 110 Oct 17 20:11 aaadrwxrwxr-x. 3 jeremy jeremy 30 Oct 6 20:43 bbbdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Desktopdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Documentsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Downloadsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Musicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Picturesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Publicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Templatesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Videos 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录当为[ - ]则是文件；若是[ l ]则表示为链接文件(link file)；若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置 接下来的字符中，以三个为一组，且均为 “rwx” 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 从左至右用 0-9 这些数字来表示。第 0 位确定文件类型，第 1-3 位确定文件属主（该文件的所有者）拥有该文件的权限。第 4-6 位确定文件属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。其中，第 1、4、7 位表示读权限，如果用 “r” 字符表示，则有读权限，如果用 “-“ 字符表示，则没有读权限；第 2、5、8 位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权 文件属主和属组 属主 ：该文件具有所有权的用户，通常时文件的所有者是指创建此文件的用户，或者手动指定的拥有者 属组 ：Linux中，用户时按组分类的，一个用户可以属于一个或者多个组。文件所有者以外的用户，又可以分为文件所有者的同组用户和其它用户。root是顶级用户，可以无视权限，进行任何操作。 更改文件属性chgrp1# chgrp [-R] 属组名 文件名 #更改文件属组，前提是组已经存在 -R : 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改 chown12# chown [-R] 属主名 文件名 #更改文件属主# chown [-R] 属主名：属组名 文件名 #更改文件属主，同时修改文件属组 chmodLinux 文件属性有两种设置方法，一种是数字，一种是符号。 数字类型Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己read/write/execute 权限123r:4w:2x:1 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的， 例如当权限为： [-rwxrwx—] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0 1# chmod [-R] xyz 文件或目录 #修改文件的9个属性 xyz ：为rwx属性数值的相加 R ：进行递归recursive的持续变更，即连同次目录下的所有文件都会变更 12345# ls ‐al .bashrc‐rw‐r‐‐r‐‐ 1 root root 395 Jul 4 11:45 .bashrc# chmod 777 .bashrc# ls ‐al .bashrc‐rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 符号类型基本上就九个权限分别是(1)user (2)group (3)others三种身份，那么我们就可以藉由u，g，o来代表三种身份的权限。此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r，w，x。也就是可以使用底下的方式1234# chmod [ugoa] +/-/= [rwx] 文件或目录+（加入）-(除去) =（设定）将文件权限设置为 -rwxr-xr-- 可以使用 chmod u=rwx,g=rx,o=r 文件名]]></content>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理及操作]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux 系统目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445/bin：bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。实际上是链接到/usr/bin。/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。/dev ：dev 是 Device(设备)的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的DLL文件，几乎所有的应用程序都需要用到这些共享库。64 位系统还有一个lib64，这两个目录连接到 /usr下对应的lib目录。/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。/media：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/ 上，然后进入该目录就可以查看光驱里的内容了。/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all/root：该目录为系统管理员，也称作超级权限者的用户主目录（相当于普通用户的家目录）。/sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。实际上连接到 /usr/sbin/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。/srv：该目录存放一些服务启动之后需要提取的数据。/sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。/tmp：这个目录是用来存放一些临时文件的。/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。/usr/bin：系统用户使用的应用程序。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点.. 来表示。12. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。 文件、目录常用命令绝对路径路径的写法，由根目录/写起，例如：/usr/share/doc这个目录。 相对路径路径的写法，不是由/写起，例如由 /usr/share/doc要到/usr/share/man底下时，可以写成：cd ../man这就是相对路径的写法 显示当前工作目录pwd12# pwd #Print Working Directory 显示当前所在目录# pwd -P #显示出确实的路径，而非使用连接路径 列出目录ls123# ls [‐aAdfFhilnrRSt] 目录名称# ls [‐‐color=&#123;never,auto,always&#125;] 目录名称# ls [‐‐full‐time] 目录名称 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来（常用）-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-l ：以长格式列出，包含文件的属性与权限等等数据；(常用)-i ：在第 1 列显示文件的 inode 节点号 切换目录cd1234567891011121314#使用 mkdir 命令创建 runoob 目录# mkdir runoob#使用绝对路径切换到 runoob 目录# cd /root/runoob/#使用相对路径切换到 runoob 目录# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；# cd .. 创建新目录mkdir1# mkdir [-mp] 目录名称 -m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色。-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来 删除空目录rmdir1# rmdir [-p] 目录名称 -p ：连同上一级的“空的”目录也一起删除 移除文件或目录rm1# rm [-fir] 文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除，最常用的目录删除！这是非常危险的选项 复制文件或目录cp12# cp [‐adfilprsu] 来源档(source) 目标档(destination)# cp [options] source1 source2 source3 .... directory -a：相当于 ­pdr 的意思，至于 pdr 请参考下列说明；(常用)-d：若来源文件为连接文件的属性(link file)，则复制连接文件而非文件本身；-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)-l：进行硬连接(hard link)的文件创建，而非复制文件本身；-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；-r：递归持续复制，用于目录的复制行为；(常用)-s：复制成为符号连接 (symbolic link)，亦即『连接』文件；-u：若 destination 比 source 旧才升级 destination 移动文件与目录，或修改名称mv12# mv [‐fiu] source destination# mv [options] source1 source2 source3 .... directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 文件内容查看cat1# cat [-AbEnTv] #由第一行开始显示文件内容 -A ：相当於 ­vET 的整合选项，可显示出一些特殊字符（如空白字符）；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字节 $ 显示出来；-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符 tactac 与 cat 命令刚好相反，文件内容从最后一行开始向前逐行显示，可以看出 tac 是cat 的倒写 nl1# nl [-bnw] 文件 #显示行号 -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数 more一页页翻动 空白键 (space)：代表向下翻一页；Enter ：代表向下翻『一行』/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；:f ：立刻显示出档名以及目前显示的行数；q ：代表立刻离开 more ，不再显示该文件内容b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用 less一页一页翻动 空白键 ：向下翻动一页；[pagedown]：向下翻动一页；[pageup] ：向上翻动一页；/字串 ：向下搜寻『字串』的功能；?字串 ：向上搜寻『字串』的功能；n ：重复前一个搜寻 (与 / 或 ? 有关！)N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)q ：离开 less 这个程序； head取出文件前面的几行1# head [-n number] 文件 -n ：后面接数字，代表显示几行的意思 tail取出文件后面几行1# tail [-nf number] 文件 -n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[终端12# clear #清空当前终端命令历史记录# exit #退出终端 关机和重启1234# reboot #重启# shutdown -r now #重启。等同reboot# shutdown -h now #关机，慎用，通常情况远程服务器关机后，物理机无法重启# halt #关机，慎用 目录和文件操作12345678910111213141516171819202122232425# cd &lt;directory&gt; #切换到指定目录下，参数可使用通配符，按下 tab 键可自动补足，连按两下 tab 键，则会将所有相关文件列出。directory 既可是绝对路径，也可是相对路径，./ 表示当前路径，../ 表示上一级路径，下同。# ls &lt;directory&gt; #列出指定目录下所有文件，如无参数，则列出当前目录下所有文件。directory 既可是绝对路径，也可是相对路径。# ls -l #以长格式形式列出所有文件，可简写为 ll。长格式规则：第1列：1位文件类型，9位权限标志。第2列：文件索引节点编号，第3列：文件所有者名称，第4列：文件属主所在组名称，第5列：文件大小，第6列：文件最后修改日期，第7列：文件名称。# ls -a #列出所有文件，包括隐藏文件。在 Linux 中，隐藏文件的文件名以 “.”开头。另外，命令参数若有多个可以合写，如ls ‐la。# cp &lt;source&gt; &lt;target&gt; #将 source 文件复制到 target 位置。source和 target 既可是绝对路径，也可是相对路径，支持通配符，下同。第二个参数是目录的话，表示将文件复制到指定目录下，第二个参数如果是文件名称的话，表示将源文件复制成参数2指定的新文件。# cp -r &lt;source&gt; &lt;target&gt; #递归复制，‐f 参数表示静默操作，无提示。有时 ‐f 可能会失效，详细原因见最后附录部分。# mv &lt;source&gt; &lt;target&gt; #移动 source 文件到 target 位置，相当于剪切，重命名也是使用此命令。‐f 参数表示静默操作，无警告提示。mv 没有 ‐r参数。# rm &lt;source&gt; #删除文件# rm -r &lt;source&gt; #递归删除，-f 参数表示静默操作，无警告提示# mkdir &lt;directory&gt; #创建目录# mkdir -p &lt;directory&gt; #递归操作# rmdir #删除空目录# man &lt;命令&gt; #查看命令帮助文档或使用说明，按q 退出说明 查看系统版本123# ll /etc/centos* # ll 命令等同于ls ‐l# ll /etc/centos‐release #按 tab 键可自动补足# cat /etc/centos‐release #cat 命令是直接在终端中显示 查看内核版本123456# uname ‐r #显示内核版本# uname ‐m #查看系统位数# uname ‐a #显示更全面的信息# arch #与 uname ‐m 命令非常类似。如果输出 x86_64 则表示为 64 位系统，如果输出i686 或 i386 则表示为 32 位系统# getconf LONG_BIT #查看系统位数# echo $LANG #查看语言与本地化 查看网络及网卡状态123456# ifconfig #查看网络及网卡状态# nmcli dev show #检查网卡状态# nmcli device show #与之上命令效果等同# nmcli #以简单模式显示网卡状态# nmcli con up ens33 #最后一个参数是网卡名称，执行此命令后，将会激活连接此网卡# nmcli con down ens33 #表示断开此网卡 查看当前系统用户12345# whoami #查看当前系统操作用户身份，本指令等同于执行 id -un 指令 # id -un #查看当前系统操作用户的身份# who am i #查看当前系统登录用户，注意：是登录 id# who ‐m #等同于 who am i# who #显示系统当前登录的所有用户 切换用户12345# su snow #切换到普通snow 账户# su root #切换到 root 账户，切换后相对路径与当前路径一致# su #等同于上一条# su ‐ #切换到 root 账户，切换后相对路径为 ~ ，即家目录。同时会显示最后一次登录时间。# exit #退出当前的临时切换账户状态 CentOS 7.5 系统配置国内 yum 源和 epel 首先进入 /etc/yum.repos.d/目录下，新建一个 repo_bak.d目录，用于保存系统中原来的 repo 文件 123# cd /etc/yum.repos.d/# mkdir repo_bak.d# mv *.repo repo_bak.d/ 在 CentOS 中配置使用网易和阿里的开源镜像点击右上角的网络管理器，连接网络。因为 CentOS 默认是不自动连接网络的。首选使用 su ‐ 命令切换到 root 用户。否则某些操作是无法完成的，需要 root 权限到网易和阿里开源镜像站点下载系统对应版本的 repo 12345# cd yum.repos.d# wget http://mirrors.aliyun.com/repo/Centos‐7.repo# wget http://mirrors.163.com/.help/CentOS7‐Base‐163.repo# lsCentos‐7.repo CentOS‐Base‐163.repo repo.bak 或者手动下载 repo 文件并上传到/etc/yum.repos.d/ 清除系统 yum 缓存并生成新的 yum 12# yum clean all# yum update #更新软件 安装 epel 源 1# yum ‐y install epel‐release 安装压缩、解压缩工具123# yum install zip unzip gzip p7zip #安装压缩与解压缩工具# yum remove zip unzip gzip p7zip #卸载压缩与解压缩工具# yum unzip -0 cp936 xxx.zip #解决使用unzip命令时中文乱码的问题 安装中文输入法1# yum install ibus ibus-table-wubi*]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux修改密码]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[修改/重置普通用户密码 passwd #用于当前操作用户自行修改密码。注意：修改密码时，需要输入当前操作用户的当前密码。root 用户也可使用此命令修改自行修改密码。 passwd &lt;用户名&gt; #此命令只能由 root 用户执行，当前用户是 root时，可更改任意其它用户的密码 修改/重置 root 用户密码重置root密码如果 root 用户密码忘记，需要重置 root 密码的话。可按如下步骤操作（前提，有条可以操作物理机开机重启）： 第一种方法 ： 开机，随意按一个键，进入开机项选择状态，否则 5 秒钟后系统默认选择第一项自动启动。按方向键选中第一项，按 e 进入编辑状态。事实上，选择其它项也可以，只不过，第一项是默认开机项，一般是最新的内核启动 进入编辑模式后。注意，显示的内容有可能并不是全部的内容，可以按方向键上下来查看更多内容 按方向键下，一直到内容的尾部。找到 linux16 这一行，将 ro 更改成rw init=/sysroot/bin/sh，按 ctrl + x 启动。注意：修改属临时修改，仅本次生效，重启电脑，又会恢复到原来的内容 启动后，进入单用户纯文本命令模式，注意：命令提示符是:/# 使用指令chroot /sysroot切换根目录。经测试，此句之前无须执行挂载指令mount ‐o remount,rw /sysroot 使用指令 passwd root ，来重置 root 用户的密码。由于本机安装了中文语言包，而当前文本命令模式不支持中文，所以修改密码时的提示，全部显示成了方块。如果未安装中文语言包的话，提示应该是英文的。不过操作很简单，就是输入两次密码，正确输入即可。注意1：不要输入过于简单的密码。注意2：更改LANG=en_US.UTF-8，依然是中文提示，且中文仍然会显示成方块。 使用touch /.autorelabel命令，会在 / 目录下创建一个 .autorelabel 文件，有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling。 使用命令 exit 退出 chroot 状态，使用命令 reboot 重启，使用 root 新密码登录。如果使用 reboot 不能重启，可以加入 -f 参数， reboot ‐f 强制重启。 重启后，进入以下状态 等待一会，系统会再次重启。正常进入系统。 第二种方法 ： 同样是开机时，按 e 进入编辑状态。将 ro 更改为 rw ，将 LANG=zh_CN.UTF-8 更改为 LANG=en_US.UTF-8，并在末尾追加空格，init=/bin/sh，注意：一定是在末尾添加。 按 Ctrl + x 启动。启动后如下 执行如下指令，修改密码。 123# passwd root# touch /.autorelabel #注意文件名称# exec /sbin/init #重启即可 注意：此种方式，修改 LANG=en_US.UTF-8，是可以显示英文的。注意：本方法命令行前缀是sh‐4.2# 启动后进入以下状态 第三种方法： 按 e 编辑，添加rd.break 启动后，如下状态：注意命令前缀switch_root，这是固定不变（不因不同的机器而变）的 依次输入以下指令，与第一种方法相同。注意指令前缀的变化123456# mount ‐o remount,rw /sysroot #如果不加这一句，是没有效果的。但第一种方法经测试，无须加此句。# chroot /sysroot# passwd root# touch /.autorelabel# exit# reboot #重启 两次重启后就会生效。注意：CentOS 6.x 版本和 7.x 版本，重置 root 密码的方法是不一样的。具体方法可查询网络。重置 root 用户密码是 Redhat RHCE 认证考试必须先完成的第一步操作，很明显，意味着这是最简单的必备技能。第二种方法相对简单一些。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linxu</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说点心情]]></title>
    <url>%2F2018%2F10%2F24%2F1024%E8%AF%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[还有人知道今天给我过节很开心有人记得我]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort快速排序算法]]></title>
    <url>%2F2018%2F10%2F09%2FQuicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序算法思想：二分法，分治法，递归 排序实例6 1 2 7 9 3 4 5 10 86为基准，也就是temp先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。 如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它 找到7 和 56 1 2 7 9 3 4 5 10 8 交换后得到6 1 2 5 9 3 4 7 10 8 依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下6 1 2 5 4 3 9 7 10 8 此时交换基准数与33 1 2 5 4 6 9 7 10 8 这样就保证了基准数6左边都比他小，右边都比他大这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序也就是进行递归排序算法，最终就得到排序结果1 2 3 4 5 6 7 8 9 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;void QuickSort(int* a, int left, int right) &#123; int i = left; int j = right; int temp = a[left]; int t = 0; if (left &gt;= right) return; while (i != j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= temp)//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp j--;//从右向左找第一个小于x的数 while (i &lt; j &amp;&amp; a[i] &lt;= temp)//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp i++;//从左向右找第一个大于x的数 //交换两个数在数组中的位置 if (i &lt; j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //将基准数归位 a[left] = a[i]; a[i] = temp; QuickSort(a, left, i - 1); QuickSort(a, i + 1, right); return;&#125;int main()&#123; int n; int a[101] = &#123;0&#125;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; QuickSort(a, 0, n-1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 测试用例： Input:113 4 5 1 34 61 22 41 111 2 87 Output:1 2 3 4 5 22 34 41 61 87 111]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络物理层]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的主要任务确定与传输媒体的接口有关的一些特性： 机械特性 电气特性 功能特性 过程特性 传输方式的转换 数据在计算机中多采用 并行传输 方式 数据在通信线路上的传输方式一般是 串行传输 数据通信的基础知识数据通信系统的模型 数据通信基本概念 模拟信号（连续信号） ：一般是正弦或余弦波形 数字信号（离散信号）：脉冲信号 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形 模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声 数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积信道及其极限容量 信道：数据传输的通道 单向通信：单工，单向传输 双向交替通信：半双工，一方发，一方收，不能同时 双向同时通信：全双工，同时发送和接收信息，需要两条信道 信道参数 数据传输速率 = 带宽 载波频率：信道对应的频率 采样频率：模拟信号转化为数字信号时采样的速率 量化：对采样信号的数字化 噪声、信噪比： 信噪比（dB）= 10log10(S/N)（dB） Nyquist定理——计算机通信的基本定理比特率 = log2V波特率在无噪信道中，当带宽为H Hz，信号电平为V级： 数据传输速率 = 2Hlog2V (b/s) V：信号电平的级数，在二进制中，仅为0、1两级采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰 香农（Shannon)定理：在噪声信道中，当带宽为H Hz，信噪比为 S/N ：最大数据传输速率（b/s）= Hlog2（1+S/N） 信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法让每一个码元携带更多比特的信息量 数据传输基带传输：​ - 基带信号：信号源产生的原始电信号，也叫基本频带信号​ - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制宽带传输​ - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输​ - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段​ - 宽带传输：多个频带的带通信号在同一个物理媒体上传输​ 数字数据在模拟信道上传输：数字信号——&gt;模拟信号 将数字数据调制成模拟信号进行传输，把0、1用波形表示 通常有三种基本的调制方式 调幅ASK：用载波的两种不同的振幅来表示两个二进制 调频FSK：用载波附近的两种不同的频率来表示两个二级制 调相PSK：用载波的相位移动来表示两个二进制 正交调相QPSK 正交调幅QAM 数字数据的数字信号传输 数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题 常用的数字信号编码方式： 不归零编码NRZ 曼切斯特编码——自同步编码方式 差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1 编码方式的比较： 不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟 曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟 差分曼切斯特编码与曼切斯特编码基本相同 模拟数据在数字信道上传输 模拟数据变成数字数据在数字信道上传递 采用脉冲编码调制（PCM–Pulse Code Modulation）技术 关键点：在接收端还原成模拟数据 PCM以Nyquist采样定理为基础 采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息 信道复用技术频分复用FDMFrequency Division Multiplexing前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和频分复用的所有用户再同样的时间占用不同的带宽资源 时分复用TDMTime Division Multiplexing每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输​ - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。​ - 每一个用户所占用的时隙是周期性地出现​ - TDM信号也称为等时信号​ - 时分复用地所有用户是在不同的时间占用同样的频带宽度 TDM的同步和异步：​ - 同步TDM:​ - 时间片与输入装置一一对应，同步​ - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲​ - 传输介质的传输速率不能低于各个输入信号的数据速率之和​ - 同步TDM可能会造成线路资源的浪费​ - 异步TDM​ - 时间片是按需动态分配的​ - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号​ - 在传输的数据单元中必须包含地址信息，以便寻址目的节点​ - 传输介质的传输速率只要不低于各个输入信号的平均速率即可​ - 异步TDM又称统计TDM(STDM) 波分复用WDMWavelength Division Multiplexing光的频分复用 码分复用CDMCode Division Multiplexing 码分多址（Code Division Multiple Access） 每个用户可以CDMA在同样的时间使用同样的频带进行通信 抗干扰强，频谱类似白噪声，不易被发现 采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等 码片序列（chip sequence） 每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。 通常m取值为64或128（在后面的原理性说明中，取为8） 每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 例如，S 站的 8 bit 码片序列是 00011011。 发送比特 1 时，就发送序列 00011011， 发送比特 0 时，就发送序列 11100100。 为了方便，将码片0写为–1 ，将1写为+1 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。 码片序列的正交关系 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0 交换技术物理媒体中间设备传递数据的技术 电路交换 在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接 一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址 服务质量好 线路的利用率较低 建立连接时间长，因连接建立时冲突概率高 报文交换 无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站 数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞 每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时） 分组交换 与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文 可以为分组在内存预留空间 每个分组中必须包含目的地址，并采用存储-转发机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计 每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置存储转发的速度较报文交换高 接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文 虚电路交换 将电路交换的概念引入到分组交换 信息传递依然采用分组（定义最大分组长度） 引入电路交换的连接建立过程 找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点 发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>物理层</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2018%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[因特网发展的三个阶段第一阶段：从单个网络ARPANET向互联网发展的过程ARPANET： 1969年美国国防部创建的第一个分组交换网 1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生 1990年关闭第二阶段：三级结构的因特网1985年美国国家科学基金会：NSFNET三级计算机网络： 主干网 地区网 校园网（或企业网）第三阶段：多层次ISP结构因特网 第一层：服务面积最大(一般是国家范围)，拥有高速主干网 NAP 第二层：第一层ISP的用户 第三层：又称本地ISP，拥有本地范围的网络 ISP: (Internet Service Provider) 互联网服务提供者（商）NAP:网络接入点NAP (Network Access Point)：分散主干网流量，又称对等点（peering point）IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组 英特网的组成因特网的边缘部分：由所有连接在因特网上的主机组成（通信和资源共享）因特网的核心部分：由大量网络和连接这些网络的路由器（router）组成，为边缘部分提供服务（连通性和交换） 另一种分法：资源子网，通信子网 边缘部分通信方式： 客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程 客户程序特点： 客户程序必须知道服务器程序的地址 不需要特殊的硬件和复杂的操作系统 服务程序特点： 可同时处理多个远地或本地客户的请求 系统启动后自动调用并一直不断的运行着 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器 核心部分三种交换方式： 路由器：实现分组交换的关键构建，转发收到的分组交换（switching）按照某种方式动态地分配传输线路的资源 电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源 通话前先拨号建立连接（经过一个或多个交换机） 通话过程中，通信双方一直占用所建立的连接 通话结束后，挂机释放连接 报文交换 分组交换 在发送端，先把较长的报文划分成较短的固定长度的数据端 每一个数据段前面添加上首部构成分组 依次把各分组发送到接收端 接收端剥去首部，抽出数据部分，还原成报文 每一个分组的首部都含有地址等控制信息结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机 路由器处理分组的过程： 把收到的分组先放入缓存； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去 优点： 高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。 缺点： 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 计算机网络分类1.按照网络的作用分类：​ - 广域网WAN（Wide Area Network）​ - 城域网MAN (Metropolitan Area Network)​ - 局域网LAN (Local Area Network)​ - 个人区域网PAN (Personal Area Network)2.按照网络的使用者分类：​ - 公用网（public network）​ - 专用网 (private network)3.原来把用户接入到互联网的网络：接入网 AN(Access Network) 计算机网络的性能 速率 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒） 带宽 某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ 计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s 吞吐量 表示在单位时间内通过某个网络（或信道、接口）的实际数据量 时延 发送时延主机或路由器发送数据帧所需要的时间​ 发送时延 = 数据帧长度 / 发送速率 传播时延电磁波在信道中传播一定的距离需要花费的时间​ 传播时延 = 信道长度 / 电磁波在信道上的传播速率 处理时延主机或路由器在收到分组时需要花费时间处理 排队时延分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 时延带宽积 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度） 往返时间RTT（Round-Trip Time） 发送时长 = 数据长度 / 发送速率 有效数据率 = 数据长度 / （发送时间 + RTT） 利用率 信道利用率和网络利用率，过高会产生非常大的时延 计算机网络的体系结构实体、协议、服务和服务访问点 实体： 表示任何可发送或接收信息的硬件或软件进程 对等实体peer entity 协议（protocol）： 控制两个对等实体进行通信的规则、标准或约定的集合 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务 网络协议的组成要素 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 同步：事件实现顺序的详细说明 协议与服务： 本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的 协议是”水平的“，协议是控制对等实体之间通信的规则 服务是”垂直的“，服务是由下层向上层通过层间接口提供的 并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语 服务访问点 SAP（Service Access Point）： 同一系统相邻两层实体进行交互的地方称为SAP 服务数据单元SDU(Service Data Unit) OSI/RM体系结构 层次 名称 作用 第七层 应用层(applicationg layer) 约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致 第六层 表示层(presentation layer) 表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义 第五层 会话层(session layer) 建立有关会话的机制，是双向的还是单向对话或重新建立会话 第四层 传输层(transport layer) 提供端到端的通路，应用到应用的通路 第三层 网络层(network layer) 提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括- 选择路由- 拥塞控制- 协议的转换- 分段和重组- 对用户的分组、字符等统计 第二层 数据连路层(data link layer) 提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收- 识别帧的标志- 帧的发送和接收，需校验、确认- 发送方在超时或收到否定性确认后，要重发- 重复帧要丢弃在共享网络中，需解决信道共享问题等——mac层 第一层 物理层(physical layer) 与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换 会话层及以下关心的是信息的传输表示层及以上关心的是信息的理解 TCP/IP的体系结构 层次 名称 作用 第五层 应用层 通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等 第四层 传输层 负责向两台主机中进程之间的通信提供通用的数据传输服务TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付 第三层 网络层 为分组交换网上的不同主机提供通信服务把传输层产生的报文段或用户数据报封装成分组或包进行传送选择合适路由网际协议IP和多路由选择协议 第二层 数据链路层 将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息 第一层 物理层 透明的传送比特流 传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层 数据传递过程 PDU(Protocol Data Unit)：对等层次间传送的数据单位 主机1 应用进程数据先传送到应用层,加上应用层首部，称为PDU 应用层PDU再传送到传输层，加上传输层首部，成为传输层报文 传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组 IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧 数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体 电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层 物理层接收到比特流，上交给数据链路层 数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层 网络层剥去首部，取出数据部分上交给传输层 传输层剥去首部，取出数据部分上交给应用层 应用层剥去首部，取出应用程序数据上交给应用进程主机2]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT 6 添加字数和阅读时间统计]]></title>
    <url>%2F2018%2F09%2F14%2FNexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[打开hexo目录，运行git bush，安装插件$ npm install hexo-symbols-count-time --save 修改博客配置文件，添加以下代码12345symbols_count_time:symbols: truetime: truetotal_symbols: truetotal_time: true 修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码123456symbols_count_time:separated_meta: trueitem_text_post: trueitem_text_total: falseawl: 4wpm: 275 重启服务]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给Hexo正确添加RSS订阅]]></title>
    <url>%2F2018%2F09%2F09%2Fhexo-rss%2F</url>
    <content type="text"><![CDATA[安装feed插件 本地hexo目录下运行git bash here 输入指令npm install hexo-generator-feed 等待安装完成 添加配置文件 打开hexo目录下配置文件_config.yml，末尾添加以下配置 # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 打开主题配置文件_config.yml,搜索rss，添加配置 rss: /atom.xml 发布hexo s]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>rss</tag>
      </tags>
  </entry>
</search>
