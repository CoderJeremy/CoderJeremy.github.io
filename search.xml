<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java语法]]></title>
    <url>%2F2020%2F02%2F01%2FJava%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java初步字节 位（bit): 一个数字0或1 字节（Byte）: 8位=1字节，这是数据存储的最小单位 1KB = 1024 Byte,1MB = 1024 KB 命令提示符 MS-DOS(Microsoft Disk Operating System) 启动 ：win + R 切换盘符 ： [盘符]: 进入文件： cd [文件名] 退回上一层：cd .. 退回根目录：cd \ 显示文件列表: dir 清空屏幕：cls 推出cmd : exit JVM、JRE、JDK JVM : Java Virtual Machine,Java虚拟机，是Java程序的运行环境,系统不同，虚拟机版本不同 JRE : Java Runtime Environment, Java运行时环境，包含JVM 和 核心类库 JDK : Java Development Kit, Java开发工具包，包含JRE 和 开发者工具 JDK &gt;&gt; JRE &gt;&gt; JVM Java环境配置 新建变量：JAVA_HOME，值：jdk安装路径，直到bin的上一级 添加Path：%JAVA_HOME%\bin ,%自动匹配% Java入门Jaava程序运行步骤 java源程序–&gt;编译器–&gt;java字节码文件–&gt;JVM运行 javac.exe : 编译器 java.exe : 解释器 HelloWorld 编写：编写HelloWorld.java 编译：打开CMD，找到程序所在目录，输入javac HelloWorld.java，生成：HelloWorld.class 文件 运行：输入 java HelloWorld ,无需后缀，指定类名 注释 单行注释 ： // 多行注释 ： / / 关键字、标识符 关键字 : 完全小写的字母（public） 标识符 : ·在程序中，自己定义的内容，比如类的名字和变量的名 命名规则: 由 英文字母、0-9、$(美元符)、_（下划线）组成 不能以数字开头 不能是关键字 命名规范: 类名规范：首字母大写，后面每个单词首字母大写（大驼峰） 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰） 方法名规范：同变量名 常量 在程序运行期间，固定不变的量 分类： 字符串常量：双引号引用的部分,例如：”abc”,”123” 整数常量：直接写上数字，没有小数点,例如：100,200 浮点数常量：直接写上数字，有小数点，例如：2.5,-3.14 字符常量：单引号引起来的单个字符，例如：’A’,’中’（没有’’,’AB’，有’ ‘） 布尔常量：只有两种取值，true、false 空常量：null,代表没有任何数据 变量 程序运行期间，内容可以发生改变的量 创建一个变量并且使用的格式： 数据类型 变量名称 //创建了一个变量 变量名称 = 数据值 //赋值交给左边的变量 一步到位 数据类型 变量名称 = 数据值；//创建一个变量的同时，立刻放入指定的数据值 注意事项 ： 如果创建多个变量，变量之间的名称不可以重复 对于float和long类型来说，字母f和L不要漏掉 如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围 没有进行赋值的变量，不能直接使用 变量使用不能超过作用域的范围【作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止】 Java数据类型基本数据类型 整数型 byte short int long 浮点型 float double 字符型 char 布尔型 boolean引用数据类型 字符串 数组 类 接口 Lambda注意事项 字符串不是基本类型，而是引用类型 浮点型可能只是一个近似值，并非精确的值 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节 浮点数当中默认类型是double,如果要用float，需要加上一个后缀F 整数 当中默认类型是int,如果要使用long，需要加上一个后缀L，推荐使用大写字母后缀 数据类型转换 自动类型转换（隐式） 特点：代码不需要进行特殊处理，自动完成。 规则：数据范围从小到大，向上兼容 强制类型转换（显式） 特点: 代码需要进行特殊格式处理，不能自动完成 格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据 注意事项： 强制类型转换一般不推荐使用，因为有可能发生精度损失(小数)、数据溢出(大数) byte/short/char 这三种类型都可以发生数学运算，例如加法”+”。 byte/short/char 这三种类型在运算时，都会被首先提升为int类型，然后再计算。 boolean类型不能发生数据类型转换 对于byte/short/char 三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧范围，编译器自动补上强转。 如果超过左侧范围，编译器会直接报错。 在给变量进行赋值时候，如果右侧地表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 编译器的常量优化 ： short result = 5 + 8; 等号右边全是常量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中相当于直接就是 short result = 13;右侧的常量结果数值，没有超过左侧范围，所以正确。这种成为“编译器的常量优化”。常量计算在编译时已经计算并赋值。一旦表达式右侧有变量参与，则无法进行这种优化。 ASCII码 ASCII : American Standard Code for Information Interchange 美国信息交换标准代码 Unicode : 万国码，也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是128开始包含有更多字符 ‘0’ - ‘48’ , ‘A’ - 65 , ‘a’ - 97 运算符 进行特定操作的符号，例如：+ 表达式：用运算符连起来的式子，例如：a + b 分类： 算数运算符：+ 、 - 、 * 、 / 、 % 、 ++ 、 – 赋值运算符：= 、 += 、-= 、*= 、/= 、%= 比较运算符：== 、&lt; 、 &gt; 、 &lt;= 、 &gt;= 、 != 逻辑运算符：&amp;&amp; 、 || 、 !(取反) 三目运算符：数据类型 变量名称 = 布尔类型表达式 ? 结果1 : 结果2 （true为结果1，false为结果2） 方法入门 定义：若干语句功能的集合，将一个功能抽取出来，形成一个单独的功能，提高代码复用，减少冗余 格式： 123456789/*修饰符 返回值类型 方法名(参数列表)&#123; 方法体 return ;&#125;*/public static void method()&#123; System.out.println("这是一个方法");&#125; 调用: 方法不会自动运行，必须被调用 注意: 方法定义的先后顺序无所谓 方法定义必须是挨着的，不能再一个方法的内部定义另外一个方法 方法必须被调用才会执行 Java9 新特性 JShell : 适合片段代码的测试 启动 ： cmd + JShell 退出 : /exit 流程控制顺序 顺序结构：根据编写顺序，从上到下执行。 判断 if if…else if…else if…else 选择 switch 注意：多个case后面的数值不可以重复 switch小括号当中只能是下列数据类型 基本数据类型 ： byte/short/char/int 引用数据类型 : String字符串、enum枚举 123456789101112switch()&#123; case 常量值1: 语句1; break; case 常量值2: 语句2; break; ... default: 语句体:n+1; break;&#125; case的穿透性：如果case的后面不写break,将出现穿透现象，直接向后运行，直到遇到break; 循环 for while do-while：无条件执行一次循环体，具有一定风险性 12345初始化表达式 do&#123; 循环体 步进表达式 &#125;while(布尔表达式) 区别： 如果条件判断从来没有满足过，for和while将执行0次，do-while至少循环一次 for循环的变量在小括号当中定义，只有循环内可以使用 IDEA快捷键 (自定义)自动补全快捷键:file-settings-keymap-dupulicate(创建副本)-main menu-code-completion-basic(ctrl+alt+?) Alt+Enter : 导入包，自动修正代码 Ctrl+Y : 删除光标所在行 Ctrl+D : 复制光标所在行，插入光标位置下面 Ctrl+ALt+L : 格式化代码 Ctrl+/ : 单行注释 Ctrl+Shift+/ : 多行注释 Alt+Ins : 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 : 移动当前代码行项目结构 Project Module Package Class Java基础方法定义 若干语句功能的集合 参数:进入方法的数据 返回值: 从方法中出来的数据 格式1234修饰符 返回值类型 方法名称(参数类型 参数名称,...)&#123; 方法体 return 返回值;&#125; 修饰符: public static… 返回值类型: void int 方法名称 : 方法名字，小驼峰 参数名称 : 进入方法的数据对应的变量名称 方法体 : 方法需要做的事 return : 停止当前方法，将返回值还给调用处 返回值 : 执行方法后得到的数据结果 注意 : return后面的”返回值“，必须和方法名称前面的返回值类型，保持对应 方法的调用 单独调用: 方法名称(参数),返回值为void,只能单独调用 打印调用: System.out.println(方法名称(参数)); 赋值调用: 数据类型 变量名称 = 方法名称(参数); 方法的重载（Overload） 在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 参数列表: 个数不同，数据类型不同，顺序不同 重载方法调用 : JVM通过方法的参数列表，调用不同的方法。 注意 : 与参数的名称无关 与方法的返回值类型无关 注意 方法应该定义在类中，但是不能在方法中再定义方法，不能嵌套 方法定义的先后顺序无所谓 方法必须被调用才能执行 返回值类型必须和方法的返回值类型对应 数组概念 存储数据长度固定的容器，保证多个数据的数据类型要一致 特点 数组是一种引用数据类型 数组当中的多个数据类型一致 数组的长度在程序运行期间不可改变 初始化 在内存中创建一个数组，并且向其中赋予一些默认值 动态初始化:指定长度 静态初始化:指定内容 动态初始化 数据类型[] 数组名称 = new 数据类型[数组长度] 左侧数据类型:数组中保存的数据类型 左侧的中括号:表示这是一个数组 左侧数组名称:数组的名字 右侧的new : 代表创建数组的动作 右侧数据类型:必须和左边的数据类型保持一致 右侧中括号的长度:数组当中，到底可以保存多少个数据,是一个int数字 1int[] arrayA = new int[200]; 注意: 使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值 整数型:默认值0; 浮点型:默认值0.0; 字符型:’\u0000’; 布尔型:false; 引用型:null. 静态初始化 数据类型[] 数组名称 = new 数据类型[]{元素1, 元素2, 元素3...} 自动分配空间和容量 1int[] arrayB = new int[]&#123;5,10,15&#125; 注意: 静态初始化也有默认值，只不过系统自动马上将默认值替换成大括号中具体值 数组的访问 直接打印数组名称，得到的是数组对应的,内存地址哈希值 访问数组元素的格式: 数组名称 [索引值] 数组的内存 栈(Stack):存放的都是方法中的局部变量。方法的运行一定要在栈中运行。 局部变量:方法的参数，或者是方法{}内部的变量 作用域:一旦超出作用域，立刻从栈内存当中消失 堆(Heap): new出来的东西，都在堆中。 堆内存里面的东西都有一个地址值:16进制 堆内存里面的数据，都有默认值 方法区(Method Area):存储.class相关信息，包含方法的信息 本地方法栈(Native Method Stack):与操作系统相关 寄存器(pc Register): 与CPU相关 数组的常见问题 索引越界异常:如果访问数组元素的时候，索引编号不存在，将会发生数组索引越界异常:ArrayIndexOutOfBoundsException 空指针:数组必须进行new初始化才能使用其中的元素。如果只是赋值了一个null,没有进行new创建，那么将会发生空指针异常:NullPointerException 数组的常用操作 获取数组长度: 数组名称.length，数组一旦创建，程序运行期间，长度不可改变 数组的遍历: 数组名称.fori–&gt;自动补全遍历代码 数组作为方法参数: 传递地址值 数组作为方法返回值: 返回地址值，public static int[] 方法名，return 数组名 注意 方法的参数为基本类型时，传递的是数据值 方法的参数为引用类型时，传递的时地址值 Java中级面向对象思想 面向过程: 当需要实现一个功能时，每一个步骤都需要具体描述出来，强调步骤 面向对象:当需要实现一个功能时，不关心具体步骤，强调过程 封装 继承 多态类和对象类和对象的关系 类:一组相关属性和行为的集合，可以看作是一类事物的模板，使用事物的属性特性和行为特征来描述该类事物。 属性:该事物的状态信息 行为:该事物能够做什么 对象:一类事物的具体体现。对象是类的一个实例,必然具备该类事物的属性和行为。 类与对象的关系: 类是对象的模板，对象是类的实例 类是一类事物的描述，抽象 对象是一类事物的实例，具体 类的定义 格式: 1234public class ClassName&#123; //成员变量 //成员方法&#125; 成员变量(属性):对应事物的属性(事物的状态信息) 成员方法(行为):对应事物的行为(事物能够做什么)对象的使用 通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用 导包：指出所需要使用的类，在什么位置：import 包名称.类名称 创建：类名称 对象名 = new 类名称(); 使用： 使用成员变量：对象名.成员变量名 使用成员方法：对象名.成员方法名(参数) 注意： 当使用一个对象类型作为方法的参数时，传递的就是对象的地址值。 当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值。 成员变量与局部变量的区别 定义的位置不一样 局部变量：方法内部 成员变量：方法外部，直接写在类当中 作用的范围不一样 局部变量：只有方法当中才可以使用 成员变量：整个类可以使用 默认值不一样 局部变量：没有默认值，必须手动赋值 成员变量：如果没有进行赋值，会有默认值，规则和数组一样 内存位置不一样 局部变量；位于栈内存中 成员变量：位于堆内存中 生存周期不一样 局部变量：随着方法进栈儿诞生，随着方法出栈而消失 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失封装 封装性在Java当中的体现 方法就是一种封装 关键字private也是一种封装 封装就是将一些细节信息隐藏起来，对于外界不可见 Private private是一个权限修饰符，代表最小权限 可以修饰成员变量和成员方法 被private修饰后的成员变量和成员方法，只有在本类中访问，超过本类范围就不能被访问 通过设置setXXX(),getXXX()方法来实现外部访问 This this代表所在类的当前对象的引用(地址值),即对象自己的引用 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量 如果需要访问本类当中的成员变量，需要使用格式:this.成员变量名 通过谁调用的方法，谁就是this 构造方法 构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。 格式 123public 类名称(参数类型 参数名称)&#123; 方法体&#125; 注意事项： 构造方法的名称必须和所在类名称完全一致 构造方法不要写返回值类型，连void也不用写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，编译器会默认添加一个无参，无方法体的构造方法 一旦编写了至少一个构造方法，那么编译器将不再默认添加 构造方法也可以进行重载（方法名相同，参数列表不同） 标准类(JavaBean) 格式 所有成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法(快捷键:Alt+insert/CODE-&gt;Generate生成器) 编写一个无参数的构造方法(快捷键：Alt+insert-&gt;Constuctor构造器) 编写一个全参数的构造方法 这样的标准类也叫JavaBean JavaBean：Java语言编写类的一种标准规范。 Java高级常用API API: Application Programming Interface.应用程序编程接口。Java API时一本程序员的字典，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们通过查询API的方式，来学习Java提供的类 API使用步骤： 打开帮助文档 点击显示，找到快速索引，看到输入框 输入需要查找的内容 看包，java.lang下的类不需要导包，其他需要 看类的解释和说明 学习构造方法 使用成员方法 Scanner类 功能：可以实现键盘输入数据，到程序中 引用类型一般使用步骤： 导包: import 包路径.类名称，如果需要使用的目标类和当前类位于同一个包下，则可以省略导包语句不写，只有java.lang包下的内容不需要导包，其他包都需要import语句 创建: 类名称 对象名 = new 类名称() 使用: 对象名·成员方法名() 导包：import java.util.Scanner 创建：Scanner sc = new Scanner(System.in)，System.in表示从键盘进行输入 使用： 获取键盘输入的一个int数字：int num = sc.nextInt(); 获取键盘输入的一个字符串：String str = sc.next(); 匿名对象 创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量 格式：new 类名称(参数列表);，左边没有变量值和赋值号。 应用场景： 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不创建一个新对象，造成浪费 匿名对象可以作为方法的参数和返回值 12345678910111213141516171819202122232425262728293031import java.util.Scanner;/* * 匿名对象 Anonymous * 做参数 * 做返回值 * */public class Anonymous &#123; public static void main(String[] args) &#123;// 做参数 System.out.println("输入的数字是：" + new Scanner(System.in).nextInt());// 使用匿名对象作为参数 methodParam(new Scanner(System.in));// 匿名对象作为返回值 Scanner sc = methodReturn(); System.out.println("第三次输入的是："+sc.nextInt()); &#125; // 匿名对象做参数 public static void methodParam(Scanner sc) &#123; int anInt = sc.nextInt(); System.out.println("输入的第二个数字是:" + anInt); &#125; // 匿名对象做返回值 public static Scanner methodReturn()&#123; return new Scanner(System.in); &#125;&#125; Random类 作用：产生随机数 使用步骤： 查看类：导包，import java.util.Random 查看构造方法：创建，Random r = new Random() 查看成员方法：使用， 获取一个随机的int数字：int num = r.nextInt() 获取一个随机的int数字：(参数代表范围，左闭右开区间)，int num = r.nextInt(3),实代表的范围是 [0,3) ArrayList类 ArrayList集合的长度是可以随便变化的 导包：import java.util.ArrayList 创建：ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); 使用：成员方法 public boolean add()：向集合当中添加元素，参数的类型和泛型一致 public E get(int index)；从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素 public E remove(int index)：从集合中删除元素，参数是索引编号，返回值就是被删除掉的元素 public int size()：获取集合的长度，返回值是集合中元素的个数 注意： 尖括号内的泛型只能是引用类型，不能是基本类型 如果向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的包装类 基本类型 -&gt; 包装类 int -&gt; Integer byte -&gt; Byte short -&gt; Short long -&gt; Long float -&gt; Float double -&gt; Double char -&gt; Character boolean -&gt; Boolean 从JDK1.5开始，支持自动装箱（基本类型-&gt;包装类型），自动拆箱（包装类型-&gt;基本类型） String 特点： 字符串的内容永不可变 字符串可以共享使用 字符串效果上相当于是char[ ]字符数组，但其底层原理是byte[ ]字节数组。 创建字符串： 三种构造方法 public String()：创建一个空白字符串，不含任何内容 public String(char[] array)：根据字符数组的内容，来创建对应的字符串 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串 一种直接创建 String str = &quot;Hello&quot;; //右边直接用双引号 直接写上双引号，就是字符串对象 字符串常量池 对于常量类型来说，==判断的是值 对于引用类型来说，==判断的是地址值 双引号直接写的字符串在常量池当中，new的不在池当中 常用方法字符串比较 public boolean equals(Object obj);//参数可以是任何对象，任何对象都能用object进行接受 注意： 任何对象都能用object进行接收 equals方法具有对称性，也就是a.equals(b)和b.equals(a); 如果比较双方一个常量一个变量，推荐常量写在前面，推荐：&quot;abc&quot;.equals(str),不推荐str.equals(&quot;abc&quot;)；防止str为null，产生空指针异常 public boolean equalsIgnoreCase(String str)：忽略大小写进行内容比较 字符串获取 public int length()：获取字符串当中含有的字符个数，拿到字符串的长度 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串（concatenate级联） public char charAt(int index)：获取指定索引位置的单个字符（索引从0开始） public int indexOf(String str)：查找参数字符串在原本字符串当中首次出现的索引位置，如果不存在，返回-1 字符串截取 public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串，[begin, end)，包含左边，不含右边 字符串转换、替换 public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值 public byte[] getBytes()：获取当前字符串底层的字节数组 public String replace(CharSequence oldString, CharSequence newString)：将所有出现的老字符串替换成为新的字符串,CharSequence意思就是说可以接受字符串类型。 字符串分割方法 public String[] split(String regex)：按照参数规则，将字符串切分为若干部分 注意：split方法的参数其实是一个正则表达式如果要切分&quot;.&quot;，必须写成&quot;\\.&quot; static关键字 static用来修饰成员变量和成员方法，被修饰的成员是属于类，而不是仅仅属于某个对象自己，凡是本类的对象，都共享同一内容。 一旦使用static修饰静态成员方法，那么这种方法就成为了静态方法，静态方法可以直接通过对象名进行调用，也可以直接通过类名称来调用；非静态方法必须通过创建类才能使用 有static，推荐使用类名称进行调用 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 对于本类当中的静态方法，可以省略类名称，编译器会自动补全 注意： 静态不能直接访问非静态，因为在内存当中先有静态内容，后有非静态内容 静态方法不能用this，因为this代表当前对象，通过谁调用方法，谁就是当前对象 静态代码块 格式 12345public class 类名称&#123; static&#123; //静态代码块内容 &#125;&#125; 当第一次用到本类时，静态代码块执行唯一的一次 静态内容总是优先于非静态，所以静态代码块构造方法先执行 用途：用来一次性地对静态成员变量进行赋值 数组根据类：Arrays 作用：与数组相关的工具类，实现数组的常见操作，所有方法都是静态方法，使用非常方便 导包：java.util.Arrays 使用： public static String toString()；将参数数组变成字符串(按照默认格式；[元素1，元素2，元素3…]) public static void sort(数组)：按照默认升序对数组的元素进行排序。 如果是数值，sort默认升序 如果是字符串，sort默认按字母升序 如果是自定义类，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 数学工具类：Math 与数学相关的工具类，里面提供了大量的静态方法，完成于数学运算相关的操作 导包；java.util.Math 使用： public static double abs(double num)：获取绝对值 public static double ceil(double num)：向上取整 public static double floor(double num)：向下取整 public static long round(double num)：四舍五入 Math.PI：圆周率常量 继承定义 继承是多态的前提，如果没有继承，就没有多态 主要解决的问题：共性抽取 子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类的非私有的属性和行为 父类：基类、超类 子类；派生类格式 子类与父类的关系：is-a 父类：(一个普通的类定义) 123public class 父类名称&#123; //...&#125; 子类： 123public class 子类名称 extends 父类名称&#123; //...&#125; 特点成员变量 父类无法使用子类成员变量 子类仅可以直接访问父类的非私有成员变量 成员变成重名： 直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找 间接通过成员方法访问成员变量：方法属于谁就优先用谁，没有则向上找 三种变量重名： 局部变量：直接写成员变量名 本类的成员变量：this.成员变量名 父类的成员变量：super.成员变量名 成员方法 成员方法不重名：正常使用 成员方法重名：创建的对象是谁，优先用谁的方法 注意：无论是成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类 方法重写 重写(Override)【覆盖】：在继承关系当中，方法的名称一样，参数列表也一样 对比： 重载：Overload：方法名称相同，参数列表不同 重写：Override：方法名称相同，参数列表也相同–覆盖 特点：创建的是子类对象，则优先使用子类方法 注意： 必须保证父子类之间的方法名称相同，参数列表也相同 @Override // 写在方法前面，用来检测是不是有效的正确的覆盖重写（注解） // 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写 2. 子类方法的返回值必须**小于等于**父类方法的返回值范围 &gt; `java.lang.Object`类是所有类的公共最高父类，java.lang.String就是Object的子类 3. 子类方法的权限必须**大于等于**父类方法的权限修饰符 &gt; public &gt; protected &gt; (default)(不写) &gt; private 构造方法 继承关系中，父子类构造方法的访问特点； 子类构造方法当中有一个默认隐含的super()调用，所以一定是先调用父类构造，后执行子类的构造 子类构造可以通过super关键字来调用父类重载构造 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造 super关键字 在子类的成员方法中，访问父类的成员变量：super.变量名 在子类的成员方法中，访问父类的成员方法：super.方法名 在子类的构造方法中，访问父类的构造方法：super(); 继承的特征 Java语言是单继承的，一个类的直接父类只能有一个 Java语言可以多级继承（继承体系），顶层都是Object类 一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类 抽象类定义 没有方法主体的方法称为抽象方法，包含抽象方法的类，必须是抽象类 抽象类：包含抽象方法的类 抽象方法：没有方法体的方法，加上abstract关键字，去掉方法体，分号结束 格式 抽象方法： 12// 修饰符 abstract 返回值类型 方法名(参数列表);public abstract void method(); 使用 不能直接创建new抽象类对象 必须用子类继承抽象父类 子类必须覆盖重写抽象父类所有的抽象方法 继承抽象类的子类必须重写父类所有的抽象方法，否则该子类也必须声明为抽象类，最终必须要有子类实现该父类的抽象方法，否则抽象父类到子类的创建全部失效，失去意义 注意 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的 抽象类中，不一定包含抽象方法，但是有抽象方法的类一定是抽象类 抽象类的子类，必须重写抽象父类所有的抽象方法，否则，编译无法通过报错，除非该子类也是抽象类 接口定义 接口就是一种公共的规范标准 接口是一种引用数据类型（数组、类、接口） 格式 123public interface 接口名称&#123; // 接口内容&#125; 备注：换成关键字interface之后，编译生成的字节码文件仍然是：.java-&gt;.class java版本 java7： 常量 抽象方法 java8: 默认方法 静态方法 java9 私有方法 使用 接口不能直接使用，必须有一个“实现类”来“实现”接口 格式：123public class 实现类名称 implements 接口名称&#123; // ...&#125; 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法（否则它必须是一个抽象类） 实现：去掉abstract关键字，加上方法体和大括号 创建实现类的对象，进行使用 接口的抽象方法 注意： 接口当中的抽象方法，修饰符必须是两个固定关键字：public abstract 这两个关键字修饰符，可以选择性省略 方法的三要素，可以随意定义 接口的默认方法 从Java8开始，可以使用默认方法，默认方法可以被实现类继承 作用：解决接口升级的问题（实现类可以重写默认方法） 格式：123public default 返回值类型 方法名称(参数列表)&#123; // 方法体&#125; 接口的静态方法 从Java8开始，接口当中允许定义静态方法 静态与.class文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 格式： 123public static 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 注意：不能通过接口实现类的对象来调用当中的静态方法 正确用法：通过接口名称，直接调用其中的静态方法。 格式：接口名称.静态方法名称(参数) 接口的私有方法 我们需要抽取一个共有方法，用来解决多个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。 从Java9开始，接口当中允许定义私有方法 普通私有方法：解决多个默认方法之间重复代码问题 格式： 123private 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 静态私有方法：解决多个静态方法之间重复代码问题 123private static 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 接口的成员变量（常量） 接口中可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】 格式： public static final 数据类型 常量名称 = 数据值; 一旦使用final关键字进行修饰，说明不可改变 注意： 接口当中的常量，可以省略public static final 接口当中的常量，必须进行赋值，不能不赋值 接口中，常量的名称，使用完全大写的字母，用下划线进行分隔(shift+F6) 总结 在java9+版本中，接口的内容可以有 成员变量其实是常量，格式：[public] [static] [final] 数据类型 常量名称 = 数据值; 注意： 常量必须进行赋值，而且一旦赋值不能改变 常量名称完全大写，用下划线进行分隔 接口中最重要的就是抽象方法，格式： [public] [abstract] 返回值类型 方法名称(参数列表) 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类 从Java8开始，接口里允许定义默认方法，格式：[public] default 返回值类型 方法名称(参数列表){方法体} 注意：默认方法也可以被覆盖重写 从Java8开始，接口里允许定义静态方法，格式：[public] static 返回值类型 方法名称(参数列表){方法体} 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法 从Java9开始，接口里允许定义私有方法，格式： private 返回值类型 方法名称(参数列表){方法体} private static 返回值类型 方法名称(参数列表){方法体} 注意：private方法只有接口自己才能调用，不能被实现类或别人使用 注意 接口不能有静态代码块 接口不能有构造方法 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口 格式： 123public class 实现类 implements 接口A,接口B&#123; // 覆盖重写所有抽象方法&#125; 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类 如果实现类所实现的多个接口，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法（父类&gt;&gt;接口） 接口的多继承 类与类之间是单继承的，直接父类只能有一个 类与接口之间是多实现的，一个类可以实现多个接口 接口与接口之间是多继承的 使用：关键字extends 注意 多个父接口当中的抽象方法如果有重复，没关系 多个父接口当中的默认方法如果有重复，那么子接口必须进行默认方法的覆盖重写，【而且要带着default关键字】 实现类重写接口默认方法，不需要保留default关键字 多态概述 多态性：一个对象拥有多种形态 代码当中体现多态性：【父类引用指向子类对象】 格式： 父类名称 对象名 = new 子类名称(); 或者 接口名称 对象名 = new 实现类名(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误，如果有，执行的是子类重写后方法 多态中的成员变量 直接通过对象名访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 多态中的成员方法 new的是谁，就优先用谁，没有则向上找 注意： 成员方法：编译看左，运行看右 成员变量：编译看左，运行看左 多态的优点 方法调用相同（编译时），用谁找谁（运行时），动态过程 引用类型转换向上转型 向上转型：多态本身是子类类型向父类类型向上转型的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型 格式：父类名称 对象名 = new 子类名称(); 注意：向上转型一定是安全的。从小范围–&gt;大范围 缺陷：无法调用子类特有的内容 向下转型 向下转型：父类类型向子类类型向下转型的过程(还原)，这个过程是强制的 格式：子类名称 对象名 = (子类名称)父类对象; 含义：将父类对象，还原成原本的子类对象 注意： 要还原的对象必须是原来创建的对象，才能向下转型 要还原的对象如果不是原来创建的对象，而是其他对象，就会报错（运行异常，ClassCastException） instance of关键字 作用：返回一个boolean值，判断前面的对象能不能当作后面类型的实例 格式：变量名 instance of 数据类型 final关键字 含义：代表最终、不可改变的 使用： 修饰一个类，不能被继承 修饰一个方法，不能被重写 修饰一个局部变量，不能被重新赋值 修饰一个成员变量，不能被重新赋值 修饰类 格式： 123public final class 类名称()&#123; // ...&#125; 作用：当前这个类不能有任何的子类（final类不能作为父类） 注意：final类的所有成员方法都无法进行覆盖重写 修饰方法 格式： 123public final 返回值 方法名(参数列表)&#123; // 方法体&#125; 作用：当前方法就是最终方法，不能再被覆盖重写 注意：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾 修饰局部变量 格式： 1final 数据类型 数据名 = 数据值; 作用：当前局部变量，不能进行更改，一次赋值，终生不变 注意：对于基本类型，不可变说的是变量当中的数据不可变；对于引用类型来说，不可变说的是变量当中的地址值不可变 修饰成员变量 格式： 1final 数据类型 数据名 = 数据值; 作用：当前成员变量，不能进行更改，但成员变量有默认值，用了final后必须进行手动赋值 注意： 对于final的成员变量，要么使用直接赋值，要么使用构造方法赋值（二选一） 必须保证类当中所有重载构造方法，都最终会对final的成员变量进行赋值 权限修饰符 public protected (default) private 同一个类 YES YES YES YES 同一个包 YES YES YES NO 不同包子类 YES YES NO NO 不同包非子类 YES NO NO NO 内部类 定义：将一个类A定义在另一个类B里面，A被称为内部类，B被称为外部类 成员内部类：定义在类中方法外的类 分类： 成员内部类 局部内部类(包含匿名内部类) 注意：内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。比如，Person$Heart.class 成员内部类 定义在一个类内成员方法外的类 格式： 123456修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; //... &#125; //...&#125; 使用： 直接：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称() 间接：在外部类的方法中，使用内部类：然后main只是调用外部类的方法 注意； 内用外，随意访问，外用内，需要内部类对象 同名变量访问：（重名）外部类名称.this.外部类成员变量名 局部内部类 定义在一个方法内部的类，“局部”：只有当前所属方法才能使用，出了方法无法使用 格式： 1234567修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称(参数列表)&#123; class 局部内部类名称&#123; //... &#125; &#125;&#125; 使用：方法内创建局部类对象，main直接调用外部类方法 注意：权限修饰符 外部类：public/(default) 成员内部类：public / protected / (default) / private 局部内部类：无法使用修饰符 局部内部类的final问题 局部内部类，如果希望访问所在方法的局部变量，那么这份局部变量必须是有效final的(从Java8开始，只要局部变量事实不变，那么final关键字可以省略) 原因： new出来的对象在堆内存当中 局部变量是跟着方法走到，在栈内存中 方法运行结束之后，立刻出栈，局部变量就会立刻消失 new出来的对象会在堆中持续存在，直到垃圾回收消失 匿名内部类 如果接口的实现类(或者是父类的子类)，只需要使用唯一的一次，那么这种情况就可以省略掉该类的定义，改用匿名内部类 格式： 123接口名称 对象名 = new 接口名称()&#123; // 覆盖重写所有抽象方法&#125;; 对”new 接口名称(){…};”解析: new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 注意： 匿名内部类，在创建对象的时候，只能使用唯一一次，如果希望多次创建对象，而且内容一样，那么就必须使用单独的实现类 匿名对象，在调用方法的时候，只能调用一次，如果希望同一个对象，调用多次方法，必须要给对象取名 匿名内部类省略了实现类/子类，匿名对象省略了对象名称 匿名内部类和匿名对象不是一回事 常用API-2Object类 类Object是类层次结构的根(父)类。每个类都使用Object作为超(父)类，所有对象（包括数组）都实现这个类的方法 导包：java.lang.Object 使用 public String toString()：返回该对象的字符串表示 public boolean equals(Object obj)：指示其他某个对象是否与此对象”相等” toString方法 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值 直接打印对象的名字，其实就是调用对象的toString 覆盖重写 在IDEA中，可以使用alt+insert，点击toString() 看一个类是否重写了toString,直接打印这个类的对象即可，如果没有重写toString方法，那么打印的是对象的地址值equals方法 如果没有重写equals方法，默认比较对象的地址值，如果需要比较内容，需要覆盖重写 参数： Object obj：可以传递任意的对象 this ；调用的对象 obj ；参数 基本数据类型：比较地址值 引用数据类型；比较对象的地址值 覆盖重写： 问题：隐含一个多态，无法使用子类特有的内容（属性和方法） 解决：向下转型（强转） alt+insert ,equals() and hashCode() Objects类 JDK7中添加的工具类，其中的方法是null-save(空指针安全)或null-tolerant(容忍空指针)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象 Objects.equals方法：防止出现空指针异常123public static boolean equals(Object a, Object b)&#123; return (a==b)||(a!=null&amp;&amp;a.equals(b));&#125; Date类 表示特定的瞬间，精确到毫秒（千分之一秒 1000毫秒=1秒） 毫秒值的作用：可以对时间和日期进行计算（0毫秒：1970年1月1日 00:00:00） 中国属于东八区，会把时间+8小时 导包：java.util.Date构造方法 public Date()：获取当前系统的日期和时间 public Date(Long date):传递毫秒值，把毫秒值转换为Date日期成员方法 public long getTime():把日期转换为毫秒值(相当于System.currentTimeMillis()方法)，返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数DateFormat类 定义：日期/时间格式化子类的抽象类，可以实现日期和文不之间的转换（Date-&gt;String） 作用：格式化（日期-&gt;文本）、解析（文本-&gt;日期） 导包：java.text.DateFormat 成员方法： String format(Date date)：按照指定的模式，把Date日期，格式化为符合模式的字符串 Date parse(String source)：把符合模式的字符串，解析(parse)为Date日期 DateFormat是抽象类，无法之间创建对象使用，可以使用DateFormat的子类（SimpleDateFormat） parse方法声明了一个异常叫ParseException，如果字符串和构造方法的模式不一样，那么程序就会抛出此异常，调用一个抛出了异常的方法，就必须处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理 SimpleDateFormat: java.text.SimpleDateFormat extends DateFormat 构造方法：SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造 注意：模式中的字母不能更改，连接模式的符号可以改 Calendar类 本身是抽象类，已知子类GregorianCalendar，提供了很多操作日历字段的方法(YEAR\MONTH\DAT_OF_MONTH\HOUR) Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance()，此方法返回了Calendar类的子类对象 static Calendar getInstance() 使用默认时区和语言环境获得一个日历常用方法 public int get(int field)：返回给定日历字段的值 public void set(int field, int value)；将给定的日历字段设置为给定值 public abstract void add(int field, int amount)；根据日历的规则，为给定的日历字段添加或减去指定的时间量 public Date getTime()；返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象 注意；int field；日历类的字段，可以使用Calendar类的静态成员变量获取 System类 导包：java.lang.System 获取与系统相关的信息或系统级操作常用方法 public static long currentTimeMillis()；返回以毫秒为单位的当前时间 public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length)；将数组中指定的数据拷贝到另一个数组中 StringBuilder类 字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），底层也是一个数组，但是没有final修饰，可以改成长度 在内存中始终是一个数组，占用空间少（byte[] value = new byte[16]），效率高，如果超出，自动扩容 java.lang.Builder构造方法 StringBuilder()；构造一个不带任何字符的字符串生成器，其初始容量为16个字符 StringBuilder(String str)；构造一个字符串生成器，并初始化为指定的字符串内容成员方法 public StringBuilder append(...)；添加任意类型数据的字符串形式，并返回当前对象自身 public String toString()；将当前StringBuilder对象转换为String对象注意 String-&gt;StringBuilder；可以使用StringBuilder的构造方法 StringBuilder-&gt;String；可以使用StringBuilder的toString方法 基本类型包装类 使用一个类，将基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类，我们可以使用类中的方法来操作这些基本类型的数据装箱与拆箱 装箱；把基本类型的数据，包装到包装类中 构造方法： Integer(int value)；构造一个新分配的Integer对象，它表示指定的int值 Integer(String s)；构造一个新分配的Integer对象，它表示String参数所指示的int值（注意：传递的字符串，必须是基本类型的字符串，否则会抛出异常‘100’正确，‘0’异常） 静态方法 static Integer valueOf(int i)；返回一个表示指定的int值的Integer对象 static Integer valueOf(String s)；返回保存指定的String的值的Integer对象 拆箱；在包装类中取出基本类型的数据 成员方法；int intvalue()；以int类型返回该Integer值 自动装箱与自动拆箱 基本类型的数据和包装类之间可以自动地相互转换（JDK1.5之后） 基本类型与字符串类型的转换 基本类型-&gt;字符串； 基本类型的值+”” 包装类的静态方法toString(参数)，不是Object类的toString()方法，发生了重载 String类的静态方法valueOf(参数) 字符串-&gt;基本类型； 包装类的静态方法；parseXXX(“数值类型的字符串”) 集合概述 数组长度固定；集合长度可变 数组存储同一类型元素；集合只能存储对象，类型可以不一致 框架 Collection接口；所有单列集合中共性的方法\所有的单列集合都可以使用共性的方法\没有索引的方法 List接口；有序的集合（存储和取出元素顺序相同）\允许存储重复元素\有索引，可以使用普通的for循环遍历 Vector集合 ArrayList集合 LinkedList集合 Set接口；不允许存储重复元素\没有索引（不能使用普通的for循环遍历） TreeSet集合 HashSet集合 LinkedHashSet集合(存取一致) Collection集合常用方法 public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() ；清空集合中所有的元素。 public boolean remove(E e)；把给定的对象在当前集合中删除。 public boolean contains(E e)；判断当前集合中是否包含给定的对象。 public boolean isEmpty()；判断当前集合是否为空。 public int size()；返回集合中元素的个数。 public Object[] toArray()；把集合中的元素，存储到数组中。 Iterator迭代器 为了遍历集合中所有元素 java.util.Iterator Iterator接口 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 常用方法； boolean hasNext()；如果仍有元素可以迭代，返回true E next() ；返回迭代的下一个元素 注意：Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象。Colletion接口中有一个方法，叫iterator()，返回的就是迭代器的实现类对象 使用步骤； 使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态），注意迭代器也有泛型，跟着集合走 使用Iterator接口中的方法hasNext判断还有没有下一个元素 使用Iterator接口中的方法next取出集合中的下一个元素 增强for循环 底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，jdk1.5之后 Collection&lt;E&gt;extends Iterable&lt;E&gt;；所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;；实现这个接口允许对象成为”foreach”语句的目标 格式 123for(集合/数组的数据类型 变量名:集合名/数组名)&#123; sout(变量名);&#125; 注意；新for循环必须有被遍历的目标，目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现 泛型(Generic)概述 一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型 泛型可以看作是一个变量，用来接收数据类型 E e；Element元素 T t；Type类型 创建集合对象的时候，就会确定泛型的数据类型优点 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型 把运行期间异常ClassCastException，提升到了编译时期的编译失败 但是泛型是什么类型，只能存储什么类型的数据定义与使用 含有泛型的类 格式：123修饰符 class 类名&lt;泛型&gt;&#123; //...&#125; 含有泛型的方法 格式；123456789// 普通方法修饰符 &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123; 方法体;&#125;// 静态方法修饰符 static &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123; 方法体;&#125; 含有泛型的接口 格式； 123修饰符 interface 接口名&lt;泛型&gt;&#123; 抽象方法(泛型 参数名,...);&#125; 使用： 定义类时确定泛型的类型 始终不确定泛型的类型，直到创建对象时，确定泛型的类型泛型通配符 ？；代表任意的数据类型 使用： 不能创建对象使用 只能作为方法的参数使用 注意：泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 泛型的上限限定 ? extends E；代表使用的泛型只能是E的子类/本身 泛型的下限限定 ? super E；代表使用的泛型只能是E类型的父类/本身 List集合 java.util.List extends Collection List接口继承Collection接口特点 有序的集合，存储元素和取出元素的顺序是一致的 有索引，包含了一些带索引的方法 允许存储重复的元素常用方法 public void add(int index, E element)；将指定的元素，添加到该集合中的指定位置上 public E get(int index)；返回集合中指定位置的元素 public E remove(int index)；移除列表中指定位置的元素，返回的是被移除的元素 public E set(int index, E element)；用指定元素替换集合中指定位置的元素，返回以前在指定位置的元素 注意：操作索引的时候，一定要防止索引越界异常子类 ArrayList；List接口的数组实现，元素增删慢，查找快。此实现是不同步的（多线程）。 LinkedList；List接口的链表列表实现。元素添加快，查找慢。 双向链表 含有大量操作首尾元素的方法，因此不要使用多态 常用方法： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst() :返回此列表的第一个元素。 public E getLast() :返回此列表的最后一个元素。 public E removeFirst() :移除并返回此列表的第一个元素。 public E removeLast() :移除并返回此列表的最后一个元素。 public E pop() :从此列表所表示的堆栈处弹出一个元素。 public void push(E e) :将元素推入此列表所表示的堆栈。 public boolean isEmpty() ：如果列表不包含元素，则返回true。 Vector；单线程，与ArrayList原理一样，已被ArrayList替代 Set集合 java.util.Set extends Collection Set接口继承Collection接口特点 不允于存储重复的元素 原理；add方法会调用元素的hashCode方法和equals方法，判断元素值是否重复(前提；存储的元素必须重写hashCode和equals方法)，哈希值不同，直接存入集合，哈希值相同，比较equals，true为相同值，不存入集合 没有索引，没有带索引的方法，也不能使用普通的for循环遍历 子类HashSet 特点； 由哈希表支持，不保证迭代顺序 是一个无序的集合，存储元素和取出元素的顺序有可能不一致 底层是一个哈希表结构(查询速度快) 哈希值； 是一个十进制的整数，由系统随机给出(对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址) 在Object类中由一个方法，可以获取对象的哈希值；int hashCode() hashCode()；public native int hashCode()，native代表该方法调用的是本地操作系统的方法 String类的哈希值；String类重写了Object类的hashCode()方法（”重地和通话”哈希值相同） 数据结构； 哈希表； jdk1.8版本之前；哈希表= 数组+链表 jdk1.8版本之后；哈希表=数组+链表+红黑树（提高了查询速度） 存储数据到集合中(先计算元素的哈希值) 把元素进行分组，相同哈希值链接到一起 哈希冲突：元素不同，哈希值相同 如果链表的长度超过8位，那么就会把链表转换为红黑树 存储自定义类型元素 重写hashCode和equals方法 LinkedHashSet java.util.LinkedHashSet extends HashSet,继承父类HashSet 可预知迭代顺序的Set接口的哈希表和链接列表实现 底层是一个哈希表（数组+链表/红黑树）+链表；多了一条链表记录元素的存储顺序，保证元素有序 可变参数 JDK1.5之后出现的新特性 使用前提；当前方法的参数列表数据类型已经确定，但是参数的个数不确定，使用可变参数 格式；修饰符 返回值类型 方法名(数据类型...变量名){} 原理；可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个,1,2…多个 注意； 一个方法的参数列表，只能有一个可变参数 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾 终极写法；(Object...obj) Collections工具类 java.util.Collections；集合工具类常用方法 public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T...elements)；往集合中添加一些元素 public static void shuffle(List&lt;?&gt; list)；打乱集合顺序 public static &lt;T&gt; void sort(List&lt;T&gt; list)；将集合中元素按照默认规则（升序）排序 public static &lt;T&gt; void sort(List&lt;T&gt; list ,Comparetor&lt;? super T&gt;)；将集合中元素按照指定规则排序 注意； sort(List&lt;T&gt; list)被排序的集合里面存储的元素，必须实现Comparable接口，重写接口中的compareTo()定义排序规则 Comparable接口的排序规则；自己(this)-参数；升序 Comparator和Comparable的区别 Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法 Comparator；找一个第三方的裁判 Comparator排序规则；o1-o2升序，o2-o1降序 Map集合 java.util.Map&lt;k,v&gt; 特点； Map集合是一个双列集合，一个元素包含两个值(一个key,一个value) Map集合中的元素，key和value的数据类型可以相同，也可以不同 Map集合中的元素，key是不允许重复的，value是可以重复的 Map集合中的元素，key和value是一一对应的 和Collection的区别： Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 Map常用子类 HashMap&lt;K,V&gt;； HashMap底层是哈希表，查询速度快，元素的存储顺序不能保证一致 为了保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法 JDK1.8之前；数组+单向链表 JDK1.8之后；数组+单向链表/红黑树（链表的长度超过8时） LinkedHashMap&lt;K,V&gt;； 是HashMap的子类，底层是哈希表+链表 是一个有序的集合，存储元素和取出元素的顺序是一致的，需要重写hashCode()、equals()方法 注意；Map接口中的集合都有两个泛型变量&lt;K,V&gt;，在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 Map常用方法 public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值V: 存储键值对的时候，key不重复，返回值V是null 存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值V: key存在，返回被删除的值 key不存在，返回null public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值V: key存在，返回对应value值 key不存在，返回null boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map遍历key找value方式 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keySet() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) Entry键值对对象 Map.Entry&lt;K,V&gt;；在Map接口中有一个内部接口Entry 作用；当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键与值得映射关系） Entry对象的常用方法； public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 HashMap存储自定义类型键值 Map集合保证Key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一 LinkedHashMap&lt;K,V&gt; LinkedHashMap&lt;K,V&gt;继承HashMap&lt;K,V&gt; 底层原理；哈希表+链表（记录顺序） HashTable&lt;K,V&gt; 底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢 HashTable不能存null值,null键 HashTable和Vector在jdk1.2之后被取代（HashMap,ArrayList） HashTable的子类Properties依然在使用 JDK9对集合添加的优化 JDK9的新特性； List接口、Set接口、Map接口；增加了一个静态方法of，可以给集合一次性添加多个元素 前提；集合中存储的元素的个数已经确定，不再改变 注意； of方法值适用于List、Set、Map接口，不适用于接口的实现类 of方法的返回值是一个不能改变的集合，集合不能再使用add、put方法添加元素，会抛出异常 Set接口和Map接口再调用of方法的时候，不能有重复的元素，否则会抛出异常 Debug调试 Debug调试程序； 可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug 使用方式； 在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里） 右键，选择Debug执行程序 执行程序； f8；逐行执行程序 f7；进入到方法中 shift+f8；跳出方法 f9；跳到下一个断点，如果没有下一个断点，那么就结束程序 ctrl+f2；退出Debug模式，停止程序 Console；切换到控制台 异常与多线程异常 异常；程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止 异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象，Javac处理异常的方式是中断处理异常体系 Throwable；Java.lang.Throwable Error；工程师无法处理，只能尽力避免 Exception；编译期异常，由于使用不当导致，可以避免 RuntimeException；运行期异常,Java程序运行过程中出现的问题 异常处理 常用关键字；try,catch,finally,throw,throws throw 在指定的方法中抛出指定的异常 格式；throw new xxxException(&quot;异常产生的原因&quot;) 注意； throw关键字必须写在方法内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，(运行期异常)可以不处理，默认交给JVM处理（打印异常对象，中断程序） throw关键字后边创建的是编译异常，我们就必须处理这个异常，要么throw,要么try...catch 声明异常throws 异常处理的第一种方式，交给别人处理 当方法内部抛出异常对象的时候，必须处理这个异常对象 可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理 格式； 12345修饰符 返回值 方法名(参数列表) throws AAAException, BBBException...&#123; throw new AAAException("产生原因"); throw new BBBException("产生原因"); ...&#125; 注意； throws关键字必须写在方法声明处 throws关键字后边声明的异常必须是Exception或者是Exception的子类 方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常。（如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可） 调用了一个声明抛出异常的方法，我们就必须处理声明的异常。（要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM，要么try...catch自己处理异常） 捕获异常try…catch 格式； 123456789try&#123; 可能产生异常的代码&#125;catch(异常类型 变量名)&#123; //用来接收try中抛出的异常对象 处理异常的代码（一般把异常信息记录到一个日志中）&#125;...catch(异常类型 变量名)&#123;&#125; 注意； try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try…catch之后的代码 如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑 Throwable常用方法 public void printStackTrace()；打印异常的详细信息 public String getMessage()；获取发生异常的原因 public String toString()；获取异常的类型和异常描述信息（不用） finally代码块 格式 1234567try&#123; 可能发生异常的代码&#125;catch(异常类型 变量名)&#123;&#125;finally&#123; 无论是否出现异常都会执行&#125; 注意； finally 不能单独使用，必须和try一起使用 finally 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源（IO） 异常的注意事项 多个异常使用捕获该如何处理 多个异常分别处理 多个异常一次捕获，多次处理 注意；一个try,多个catch,如果catch定义的异常变量，具有父子类的关系，子类的异常变量必须写在上面，否则会报错 多个异常一次捕获（catch异常对象的父类），一次处理 如果finally有return语句,永远返回finally中的结果,避免该情况 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类重写父类方法时 抛出和父类相同的异常 抛出父类异常的子类异常 不抛 父类没有抛出异常，子类也不能抛出异常，如果出现异常，只能捕获处理，不可抛出 自定义异常类 格式 12345public class XXXException extends Exception|RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法&#125; 注意； 自定义异常类一般都是Exception结尾，说明该类是一个异常类 自定义异常类，必须的继承Exception或者RuntimeException 继承Exception；自定义的异常类是一个编译器异常，如果方法内抛出了编译器异常，必须处理这个异常，要么抛出要么捕获 继承RuntimeException；自定义的异常类是一个运行期异常，无需处理，交给JVM（中断处理） 多线程并发与并行 并发；指两个或多个事件在同一个时间段内发生(交替执行) 并行；指两个或多个事件在同一时刻发(同时发生)线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度； 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的是抢占式调度 单线程程序：Java程序中只有一个线程 主线程：执行主（main）方法的线程创建线程类方式一：创建Thread类的子类 java.lang.Thread；描述线程的类，要实现多线程程序，必须继承Thread类 实现步骤： 创建一个Thread子类 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程做什么） 创建Thread类的子类对象 调用Thread类中的方法start()方法，开启新的线程（开辟新的栈空间），执行run方法方式二：实现Runnable接口 java.lang.Runnable 实现步骤： 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法实现Runnable接口创建多线程的好处 避免了单继承的局限性 一个类只能继承一个类，类继承了Thread类就不能继承其他的类，实现Runnable接口，还可以继承其他的类，实现其他的接口 增强了程序的扩展性，降低了程序的耦合性（解耦） 实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离(解耦)。实现类中，重写了run方法：用来设置线程任务；创建Thread类对象，调用start()方法：用来开启新线程 Thread类 构造方法 常用方法 public String getName()；获取当前线程名称 public void start()；导致此线程开始执行，Java虚拟机调用此线程的run方法 public void run()；此线程要执行的任务在此处定义代码 public static Thread currentThread()；返回当前正在执行的线程对象的引用 public static void sleep(long millis)；使当前正在执行的线程以指定的毫秒数暂停 设置线程名称 使用Thread类中的方法void setName(String name) 创建一个带参数的构造方法，参数传递线程的名称，调用父类的带参构造方法（super(name)）,把线程名称传递给父类，让父类（Thread）给子线程改名字（Thread(String name)） 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。匿名内部类方式实现线程的创建 格式： 1234new 父类/接口（）&#123; @Override 重写父类/接口中的方法&#125; eg: 123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 线程任务 &#125; &#125;).start(); 线程安全线程同步 当使用多线程访问同一资源的时候，多个线程对资源有写操作，就容易出现线程安全问题 Java提供了同步机制（Synchronized）解决线程同步机制同步代码块 格式： 123synchronized(锁对象)&#123; 需要同步操作的代码&#125; 注意； 同步代码块中的锁对象，可以使用任意的对象 必须保证多个线程使用的锁对象是同一个 锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行，其他线程被阻塞（BLOCKED） 频繁的上锁、解锁会降低程序效率，但是提供程序安全性 同步方法 使用synchronized修饰的方法，就叫同步方法 格式： 123public synchronized 返回值类型 方法名()&#123; 可能会产生线程安全问题的代码&#125; 同步方法也会把方法内部打代码锁住 同步锁是谁?对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 Lock锁 java.util.concurrent.locks.Lock Lock 实现了比 synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象 创建对象 Lock 锁名 = new ReentrantLock(); 常用方法； public void lock() :加同步锁。 public void unlock() :释放同步锁 线程状态 java.lang.Thread.State六种状态| 线程状态 | 导致状态发生的条件 ||—|—||NEW(新建)|线程刚被创建，但是并未启动。还没调用start方法||Runnable(可运行)|线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于CPU||Blocked(锁阻塞)|当一个线程试图获取一个对象锁，而对象锁被其他的线程持有，则该线程进入Blocked状态；当线程持有锁时，该线程变成Runnable状态||Waiting(无限等待)|一个线程在等待另一个线程执行（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒||TimedWaiting(计时等待)|同waiting状态，有几个方法有超时参数，调用他们将进入TimeWaiting状态，这一状态将一致保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有：Thread.sleep(),Object.wait()||Teminated(被终止)|因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡|Timed Waiting 计时等待 Thread.sleep(long m)；强制当前正在执行的线程休眠，线程进入Runnable/Blocked状态 锁对象.wait(long m)；在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程进入Runnable/Blocked状态 注意；sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。Blocked 锁阻塞 线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态Waiting 无限等待 等待唤醒 只有锁对象才能调用void wait()和void notify()方法 void notifyAll()；全部唤醒 等待唤醒机制线程间通信 多个线程在处理同一个资源，但是处理的动作（线程的任务）却不同 多个线程并发执行，CPU默认随机切换线程，为了让他们有规律执行，需要进行协调通信 等待唤醒机制；使各个线程能有效利用资源等待唤醒机制 多个线程间的一种协作机制 wait/notify就是线程间的一种协作机制 等待唤醒中的方法： wait：线程不再活动，不再参与调度，进入wait set中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：选取所通知对象的 wait set中的一个线程释放 notifyAll；释放所通知对象的 wait set上的全部线程。 注意： wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法 线程池 线程池；可以容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源 优点； 降低资源消耗 提高响应速度 提高线程的可管理性 线程池的使用 jdk1.5之后提供 java.util.concurrent.Executors；线程池的工厂类，用来生成线程池 Executors类中的静态方法； static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用固定线程数的线程池 参数；int nThreads；创建线程池中包含的线程数量 返回值；ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口接收) java.util.concurrent.ExecutorService；线程池接口 用来从线程池中获取线程，调用start()方法，执行线程任务 submit(Runnable task)提交一个Runnable任务用于执行 关闭/销毁线程池的方法 void shutdown() 线程池的使用步骤 使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类，实现Runnable接口，重写run方法，设置线程任务 调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法 调用ExecutorService中的方法shutdown销毁线程池（不建议执行） Lambda表达式函数式编程思想 面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程Lambda Java8 实现多线程：12345678910// 匿名内部类实现多线程new Thread(new Runnable()&#123; @Override public void run()&#123; 线程任务 &#125; &#125;).start();// Lambda表达式实现多线程new Thread(()-&gt;&#123;线程任务&#125;).start();//启动线程 Lambda表达式标准格式 组成； 一些参数 一个箭头 一段代码 格式； (参数列表)-&gt;{一些重写方法的代码} 解释； ()；接口中抽象方法的参数列表，没有参数就空着，有参数就写处参数，多个参数用逗号分隔 -&gt;；床底的意思，把参数传递给方法体{} {}；重写接口的抽象方法的方法体 Lambda省略格式 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为函数式接口 File类与IO流]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础-02(语法)]]></title>
    <url>%2F2019%2F12%2F31%2FC-%E5%9F%BA%E7%A1%80-02-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分类 值类型：存放到栈中，每次存取都会在内存中操作 引用类型：首先在栈中创建一个引用变量，绕后在堆中创建对象本身，再把这个对象所在内存的首地址赋给引用变量。 值类型- 整型 - 浮点型 - 字符型 - 布尔型 - 枚举型 整型- sbyte ：有符号，1字节， - byte ：无符号，1字节 - short ：有符号，2字节 - ushort ：无符号，2字节 - int ：有符号，4字节（C#整型 默认值） - uint : 无符号，4字节 - long : 有符号，8字节 - ulong : 无符号，8字节 浮点型- float ：单精度浮点，4字节，最多保留7位小数，123.45f/123.345F - double ： 双精度浮点，8字节，最多保留16位小数，默认double类型 字符型- char : 2字节，存放一字符、汉字,单引号表示，&apos;a&apos; 布尔型- bool : true/false 枚举型引用类型- 类 - 接口 - 数组 - 委托 - 字符串 类接口数组委托字符串- string ： 存放多个字符，双引号表示，“abc”]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令]]></title>
    <url>%2F2019%2F12%2F29%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git工作区域 远程仓库（Remote） 备份代码，实现代码的远程管理 仓库区/本地仓库（Respository） 确定的文件保存到仓库，成为一个新的版本，并且对他人可见 暂存区(Index/unStage) 暂存已经修改的文件，最后统一提交到git仓库 工作区（Workspace） 添加、编辑、修改文件 Git命令新建代码库 在当前目录新建一个Git代码库git init 新建一个目录，将其初始化为Git代码库git init [project-name] 下载一个项目git clone [url] 配置 显示当前配置git config --list 显示文件状态git status 增加/删除文件 添加当前目录所有文件(work)到暂存区(index)git add 添加指定文件到暂存区git add [filename] 代码提交 提交暂存区(index)到仓库（repo）git commit -m [Message提交描述] 分支 列出所有本地分支git branch 列出所有远程分支git branch -r 远程同步 更新远程仓库git remote update 取回远程仓库的变化，并与本地分支合并git pull [remote][branch] 上传本地指定分支到远程仓库git push [remote][branch]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础-01]]></title>
    <url>%2F2019%2F12%2F29%2FC-%E5%9F%BA%E7%A1%80-01%2F</url>
    <content type="text"><![CDATA[C# 基础C# 是什么？- MicroSoft开发。创始人Anders - 面向对象编程 C# 的特点？- 简单、安全 - 面向对象 - 封装：将代码看作一个整体，只提供对象名和参数，提高安全性 - 继承：C#仅支持单继承 - 多态：通过继承和实现接口的方式，让类或接口中的成员表现出不同作用 - 跨平台 - 开发多种类型的程序 C# 和 Java、C++的区别C# 和 .NET- .NET是一个开发平台，而C#是一种在.NET开发平台上使用的编程语言 - .NET框架是一个多语言组件和执行环境，它提供一个跨语言的统一编程环境 - .NET框架的目的是便于开发人员容易建立Web应用程序和Web服务，使得Internet上的各应用程序之间可以使用Web服务进行沟通 .NET Framework定义一个可以快速开发、部署网站服务及应用程序的开发平台，是Windows中的一个组件 - 公共语言运行时（CLR）虚拟系统 - .NET Framework类库 优点- 提供标准的面向对象开发环境 - 提供优化的代码执行环境、兼容性高 - 使用JIT(just in time)技术，提高代码运行速度 体系结构1. 编程语言：C#、VB、C++、JScript 2.Common Language Specification(CLS):公共语言运行规范，定义一组规则：可以通过不同的编程语言来创建Windows应用程序、ASP.NET网站程序以及在.NET Framework中所有支持的程序。 3.Framework Class Library(FCL)：在FCL中包括Windows Forms（窗体程序）、ASP.NET(网站程序)、WPF(windows界面程序的框架)、WCF(Windows平台上的工作流程序)等所用到的类库文件。 4.Common Language Runtime(CLR)：.NET Framework的基础，用户可以将CLR看作一个在执行时管理代码的代码，它提供内存管理、线程管理和远程处理等核心服务，并且还强制实施严格类型安全以及可靠性的管理。(类似Java虚拟机)，以CLR为目标的代码称为托管代码，不以CLR为目标的代码称为非托管代码。 5.Windows API、COM+ Service：application programming interface应用程序接口 6.OS]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#学习笔记(一)]]></title>
    <url>%2F2019%2F12%2F19%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[C#简介 Microsoft开发 面向对象 结构化 C# 功能 布尔条件（Boolean Conditions) 自动垃圾回收(Automatic Garbase Collection) 标准库(Standard Library) 组件版本(Assembly Versioning) 属性(Properties）和事件（Events） 委托（Delegates) 和事件管理（Events Management) 泛型（Generics） 索引器(Indexers) 条件编译（Conditional Compilation) 简单的多线程(Multithreading) LINQ和Lambda表达式 集成Winodws C# 环境.Net框架（.Net Framework)用于开发 Windows应用程序 Web 应用程序 Web 服务]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO常用指令]]></title>
    <url>%2F2019%2F07%2F09%2FHEXO%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令 打开hexo目录：右键 git bash here 新建文章：hexo new 文章名称 新建草稿：hexo publish 文章名称 生成：hexo g 本地服务器：hexo s 部署：hexo d]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取猫眼电影排行榜]]></title>
    <url>%2F2019%2F01%2F18%2FPython%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C%E6%A6%9C%2F</url>
    <content type="text"><![CDATA[Python爬取猫眼电影排行榜 requests 获取 html lxml 解析 html xpath 定位元素 json 存文件 自己写的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import requestsfrom lxml import htmlimport json# 存储排名的列表rank_list = []def spider(offset): '''爬取猫眼电影排行榜''' url = "https://maoyan.com/board/4?offset=&#123;offset&#125;".format(offset=offset) html_data = requests.get(url).text # print(html_data) selector = html.fromstring(html_data) # print(selector) topper = selector.xpath('//dd') # print(topper) temp = [] for movie in topper: # 排名 rank = movie.xpath('i/text()')[0] print("排名:&#123;&#125;".format(rank)) # 电影名 name = movie.xpath('div/div/div/p/a/@title')[0] print("《&#123;&#125;》".format(name)) # 主演 star = movie.xpath('div/div/div/p[@class="star"]/text()')[0].strip() print(star) # 上映时间 time = movie.xpath('div/div/div/p[@class="releasetime"]/text()')[0] print(time) # 评分 score1 = movie.xpath('div/div/div/p[@class="score"]/i[1]/text()')[0] print("评分:&#123;&#125;".format(score1), end='') score2 = movie.xpath('div/div/div/p[@class="score"]/i[2]/text()')[0] print("&#123;&#125;".format(score2)) # 封面,网站两个&lt;img&gt;标签，两个src资源无法区分，通过pycharm获取html源代码,src标签是不一样的 image = movie.xpath('a[@class="image-link"]/img/@data-src')[0] print(image) print("-"*20) rank_list.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1+score2, 'image': image &#125;) temp.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1 + score2, 'image': image &#125;) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) return temp# 爬一次写一次，爬一页写一次，爬完写一次def write_to_file(content): '''写入文件''' with open('Maoyan_Rank.txt', 'a', encoding='utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False)+'\n')if __name__ == '__main__': #spider() for i in range(0, 100, 10): for item in spider(i): write_to_file(item) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) # f = open('Maoyan_Rank.txt', 'w') # f.write(item for item in rank_list) 书上用的正则表达式，这里跳过12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import requestsfrom lxml import htmlimport jsondef get_one_page(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' &#125; res = requests.get(url, headers=headers) # print(res) # get 请求 成功返回 状态码 = 200 if res.status_code == 200: # print(res.text) return res.text return Nonedef spider(offset): '''爬取猫眼电影排行榜''' url = "https://maoyan.com/board/4?offset=&#123;&#125;".format(offset) html_data = get_one_page(url) # print(html_data) selector = html.fromstring(html_data) # print(selector) topper = selector.xpath('//dd') # print(topper) rank_list = [] for movie in topper: # 排名 rank = movie.xpath('i/text()')[0] print("排名:&#123;&#125;".format(rank)) # 电影名 name = movie.xpath('div/div/div/p/a/@title')[0] print("《&#123;&#125;》".format(name)) # 主演 star = movie.xpath('div/div/div/p[@class="star"]/text()')[0].strip() print(star) # 上映时间 time = movie.xpath('div/div/div/p[@class="releasetime"]/text()')[0] print(time) # 评分 score1 = movie.xpath('div/div/div/p[@class="score"]/i[1]/text()')[0] print("评分:&#123;&#125;".format(score1), end='') score2 = movie.xpath('div/div/div/p[@class="score"]/i[2]/text()')[0] print("&#123;&#125;".format(score2)) # 封面,网站两个&lt;img&gt;标签，两个src资源无法区分，通过pycharm获取html源代码,src标签是不一样的 image = movie.xpath('a[@class="image-link"]/img/@data-src')[0] print(image) print("-"*20) rank_list.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1+score2, 'image': image &#125;) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) return rank_listdef write_to_file(content): '''写入文件''' with open('result.txt', 'a', encoding='utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False)+'\n\n')if __name__ == '__main__': #spider() for i in range(0, 100, 10): for item in spider(i): write_to_file(item) 爬取结果输出结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703C:\ProgramData\Anaconda3\python.exe F:/Python+/Spider/Maoyan.py排名:1《霸王别姬》主演：张国荣,张丰毅,巩俐上映时间：1993-01-01评分:9.6https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c--------------------排名:2《肖申克的救赎》主演：蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿上映时间：1994-10-14(美国)评分:9.5https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@160w_220h_1e_1c--------------------排名:3《罗马假日》主演：格利高里·派克,奥黛丽·赫本,埃迪·艾伯特上映时间：1953-09-02(美国)评分:9.1https://p0.meituan.net/movie/54617769d96807e4d81804284ffe2a27239007.jpg@160w_220h_1e_1c--------------------排名:4《这个杀手不太冷》主演：让·雷诺,加里·奥德曼,娜塔莉·波特曼上映时间：1994-09-14(法国)评分:9.5https://p0.meituan.net/movie/e55ec5d18ccc83ba7db68caae54f165f95924.jpg@160w_220h_1e_1c--------------------排名:5《教父》主演：马龙·白兰度,阿尔·帕西诺,詹姆斯·肯恩上映时间：1972-03-24(美国)评分:9.3https://p1.meituan.net/movie/f5a924f362f050881f2b8f82e852747c118515.jpg@160w_220h_1e_1c--------------------排名:6《泰坦尼克号》主演：莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩上映时间：1998-04-03评分:9.5https://p1.meituan.net/movie/0699ac97c82cf01638aa5023562d6134351277.jpg@160w_220h_1e_1c--------------------排名:7《唐伯虎点秋香》主演：周星驰,巩俐,郑佩佩上映时间：1993-07-01(中国香港)评分:9.2https://p0.meituan.net/movie/da64660f82b98cdc1b8a3804e69609e041108.jpg@160w_220h_1e_1c--------------------排名:8《千与千寻》主演：柊瑠美,入野自由,夏木真理上映时间：2001-07-20(日本)评分:9.3https://p0.meituan.net/movie/b076ce63e9860ecf1ee9839badee5228329384.jpg@160w_220h_1e_1c--------------------排名:9《魂断蓝桥》主演：费雯·丽,罗伯特·泰勒,露塞尔·沃特森上映时间：1940-05-17(美国)评分:9.2https://p0.meituan.net/movie/46c29a8b8d8424bdda7715e6fd779c66235684.jpg@160w_220h_1e_1c--------------------排名:10《乱世佳人》主演：费雯·丽,克拉克·盖博,奥利维娅·德哈维兰上映时间：1939-12-15(美国)评分:9.1https://p0.meituan.net/movie/230e71d398e0c54730d58dc4bb6e4cca51662.jpg@160w_220h_1e_1c--------------------排名:11《天空之城》主演：寺田农,鹫尾真知子,龟山助清上映时间：1992评分:9.1https://p1.meituan.net/movie/ba1ed511668402605ed369350ab779d6319397.jpg@160w_220h_1e_1c--------------------排名:12《喜剧之王》主演：周星驰,莫文蔚,张柏芝上映时间：1999-02-13(中国香港)评分:9.2https://p1.meituan.net/movie/18e3191039d5e71562477659301f04aa61905.jpg@160w_220h_1e_1c--------------------排名:13《辛德勒的名单》主演：连姆·尼森,拉尔夫·费因斯,本·金斯利上映时间：1993-12-15(美国)评分:9.2https://p1.meituan.net/movie/39ed7a0941a3604bba78d299b11a18ce119679.jpg@160w_220h_1e_1c--------------------排名:14《大闹天宫》主演：邱岳峰,毕克,富润生上映时间：1965-12-31评分:9.0https://p1.meituan.net/movie/14a7b337e8063e3ce05a5993ed80176b74208.jpg@160w_220h_1e_1c--------------------排名:15《音乐之声》主演：朱莉·安德鲁斯,克里斯托弗·普卢默,埃琳诺·帕克上映时间：1965-03-02(美国)评分:9.0https://p1.meituan.net/movie/6bc004d57358ee6875faa5e9a1239140128550.jpg@160w_220h_1e_1c--------------------排名:16《剪刀手爱德华》主演：约翰尼·德普,薇诺娜·瑞德,黛安·韦斯特上映时间：1990-12-06(美国)评分:8.8https://p1.meituan.net/movie/0e91ffcfa7e53449216cc29ee8af513a75791.jpg@160w_220h_1e_1c--------------------排名:17《春光乍泄》主演：张国荣,梁朝伟,张震上映时间：1997-05-30(中国香港)评分:9.2https://p0.meituan.net/movie/ae7245920d95c03765fe1615f3a1fe3865785.jpg@160w_220h_1e_1c--------------------排名:18《美丽人生》主演：罗伯托·贝尼尼,尼可莱塔·布拉斯基,乔治·坎塔里尼上映时间：1997-12-20(意大利)评分:9.3https://p0.meituan.net/movie/43d259ecbcd53e8bbe902632772281d6327525.jpg@160w_220h_1e_1c--------------------排名:19《海上钢琴师》主演：蒂姆·罗斯,普路特·泰勒·文斯,比尔·努恩上映时间：1998-10-28(意大利)评分:9.2https://p1.meituan.net/movie/c15b7623cce2f51c75562a3baefe507b68290.jpg@160w_220h_1e_1c--------------------排名:20《黑客帝国》主演：基努·里维斯,凯瑞-安·莫斯,劳伦斯·菲什伯恩上映时间：2000-01-14评分:9.0https://p1.meituan.net/movie/d981a12f59d3cc92ff666094404ad8f0211220.jpg@160w_220h_1e_1c--------------------排名:21《加勒比海盗》主演：约翰尼·德普,凯拉·奈特莉,奥兰多·布鲁姆上映时间：2003-11-21评分:8.9https://p1.meituan.net/movie/b449893ebc63d5c54eb4a5b60341f334383831.jpg@160w_220h_1e_1c--------------------排名:22《指环王3：王者无敌》主演：伊莱贾·伍德,伊恩·麦克莱恩,丽芙·泰勒上映时间：2004-03-15评分:9.2https://p0.meituan.net/movie/932bdfbef5be3543e6b136246aeb99b8123736.jpg@160w_220h_1e_1c--------------------排名:23《哈利·波特与魔法石》主演：丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃特森上映时间：2002-01-26评分:9.1https://p1.meituan.net/movie/aacb9ed2a6601bfe515ef0970add1715623792.jpg@160w_220h_1e_1c--------------------排名:24《无间道》主演：刘德华,梁朝伟,黄秋生上映时间：2003-09-05评分:9.1https://p1.meituan.net/movie/0d93b5b585ce29c6688e43f3989fb41f86421.jpg@160w_220h_1e_1c--------------------排名:25《射雕英雄传之东成西就》主演：张国荣,梁朝伟,张学友上映时间：1993-02-05(中国香港)评分:8.9https://p1.meituan.net/movie/53b6f0b66882a53b08896c92076515a8236400.jpg@160w_220h_1e_1c--------------------排名:26《楚门的世界》主演：金·凯瑞,劳拉·琳妮,诺亚·艾默里奇上映时间：1998-06-01(美国)评分:8.9https://p0.meituan.net/movie/8959888ee0c399b0fe53a714bc8a5a17460048.jpg@160w_220h_1e_1c--------------------排名:27《蝙蝠侠：黑暗骑士》主演：克里斯蒂安·贝尔,希斯·莱杰,阿伦·伊克哈特上映时间：2008-07-18(美国)评分:9.3https://p0.meituan.net/movie/d12a1c198ad9ffac72b5db57feacb449294699.jpg@160w_220h_1e_1c--------------------排名:28《教父2》主演：阿尔·帕西诺,罗伯特·德尼罗,黛安·基顿上映时间：1974-12-12(美国)评分:9.0https://p1.meituan.net/movie/7bac8bfa6739c18620065132ce9c64fa85110.jpg@160w_220h_1e_1c--------------------排名:29《指环王2：双塔奇兵》主演：伊莱贾·伍德,伊恩·麦克莱恩,丽芙·泰勒上映时间：2003-04-25评分:9.1https://p0.meituan.net/movie/5cfa597a98b35ee4ee598695942641ba287922.jpg@160w_220h_1e_1c--------------------排名:30《机器人总动员》主演：本·贝尔特,艾丽莎·奈特,杰夫·格尔林上映时间：2008-06-27(美国)评分:9.3https://p1.meituan.net/movie/4592eef6b6dffcd1d950f55f41ab098f239816.jpg@160w_220h_1e_1c--------------------排名:31《天堂电影院》主演：菲利浦·诺瓦雷,赛尔乔·卡斯特利托,蒂兹亚娜·罗达托上映时间：1988-11-17(意大利)评分:9.2https://p1.meituan.net/movie/618e57ddb3173de6bbf2e278946b11f279679.jpg@160w_220h_1e_1c--------------------排名:32《活着》主演：葛优,巩俐,牛犇上映时间：1994-05-18(法国)评分:9.0https://p0.meituan.net/movie/4c41068ef7608c1d4fbfbe6016e589f7204391.jpg@160w_220h_1e_1c--------------------排名:33《拯救大兵瑞恩》主演：汤姆·汉克斯,马特·达蒙,汤姆·塞兹摩尔上映时间：1998-07-24(美国)评分:8.9https://p1.meituan.net/movie/779bcc212a50a2526343362778f6b63c334618.jpg@160w_220h_1e_1c--------------------排名:34《哈尔的移动城堡》主演：倍赏千惠子,木村拓哉,美轮明宏上映时间：2004-11-20(日本)评分:9.0https://p0.meituan.net/movie/0127b451d5b8f0679c6f81c8ed414bb2432442.jpg@160w_220h_1e_1c--------------------排名:35《阿凡达》主演：萨姆·沃辛顿,佐伊·索尔达娜,米歇尔·罗德里格兹上映时间：2010-01-04评分:9.1https://p1.meituan.net/movie/91f575ec93f019f428d1f33e3ceca7c5115495.jpg@160w_220h_1e_1c--------------------排名:36《盗梦空间》主演：莱昂纳多·迪卡普里奥,渡边谦,约瑟夫·高登-莱维特上映时间：2010-09-01评分:9.2https://p1.meituan.net/movie/2f344a9f9575edbcae9f0abe0578bc90339773.jpg@160w_220h_1e_1c--------------------排名:37《忠犬八公的故事》主演：Forest,理查·基尔,琼·艾伦上映时间：2010-03-12(英国)评分:9.3https://p0.meituan.net/movie/7787c10ad5e95b03cf83ef9473500d8e282796.jpg@160w_220h_1e_1c--------------------排名:38《幽灵公主》主演：松田洋治,石田百合子,田中裕子上映时间：1997-07-12(日本)评分:8.9https://p0.meituan.net/movie/6ab1882a217e848acceb240365043d53329196.jpg@160w_220h_1e_1c--------------------排名:39《搏击俱乐部》主演：爱德华·哈里森·诺顿,布拉德·皮特,海伦娜·伯翰·卡特上映时间：1999-10-15(美国)评分:8.8https://p1.meituan.net/movie/c5e76795bf7a78b12a2ffabb4a0c5c11112921.jpg@160w_220h_1e_1c--------------------排名:40《东邪西毒》主演：张国荣,梁朝伟,刘嘉玲上映时间：1994-09-17评分:8.8https://p1.meituan.net/movie/7e471a9171a410ebc9413b2f1de67afc130067.jpg@160w_220h_1e_1c--------------------排名:41《风之谷》主演：岛本须美,永井一郎,坂本千夏上映时间：1992评分:8.9https://p0.meituan.net/movie/4f9638ba234c3fb673f23a09968db875371576.jpg@160w_220h_1e_1c--------------------排名:42《疯狂原始人》主演：尼古拉斯·凯奇,艾玛·斯通,瑞安·雷诺兹上映时间：2013-04-20评分:9.5https://p1.meituan.net/movie/d5e5e53ef9bbd98223e83df261b51b84103223.jpg@160w_220h_1e_1c--------------------排名:43《当幸福来敲门》主演：威尔·史密斯,贾登·史密斯,坦迪·牛顿上映时间：2008-01-17评分:8.9https://p1.meituan.net/movie/5896de3c1474277730e321c9b1db04a9205644.jpg@160w_220h_1e_1c--------------------排名:44《V字仇杀队》主演：娜塔莉·波特曼,雨果·维文,斯蒂芬·瑞上映时间：2006-03-17(美国)评分:8.8https://p1.meituan.net/movie/4a4c84aa103ab47202f1aa907c5542a4128882.jpg@160w_220h_1e_1c--------------------排名:45《十二怒汉》主演：亨利·方达,李·科布,马丁·鲍尔萨姆上映时间：1957-04-13(美国)评分:9.1https://p0.meituan.net/movie/df15efd261060d3094a73ef679888d4f238149.jpg@160w_220h_1e_1c--------------------排名:46《放牛班的春天》主演：热拉尔·朱尼奥,让-巴蒂斯特·莫尼耶,玛丽·布奈尔上映时间：2004-10-16评分:8.8https://p0.meituan.net/movie/7cd18fcf0b4f9180500124711e81492994030.jpg@160w_220h_1e_1c--------------------排名:47《三傻大闹宝莱坞》主演：阿米尔·汗,黄渤,卡琳娜·卡普上映时间：2011-12-08评分:9.1https://p0.meituan.net/movie/4bb144bc0a674ba6908349018fd092e6330929.jpg@160w_220h_1e_1c--------------------排名:48《勇敢的心》主演：梅尔·吉布森,苏菲·玛索,帕特里克·麦高汉上映时间：1995-05-24(美国)评分:8.8https://p1.meituan.net/movie/f8e9d5a90224746d15dfdbd53d4fae3d209420.jpg@160w_220h_1e_1c--------------------排名:49《黑客帝国3：矩阵革命》主演：基努·里维斯,雨果·维文,凯瑞-安·莫斯上映时间：2003-11-05评分:8.8https://p1.meituan.net/movie/5ca6ffcbb994a51cd6215e7c4fff2d9b71039.jpg@160w_220h_1e_1c--------------------排名:50《速度与激情5》主演：范·迪塞尔,保罗·沃克,道恩·强森上映时间：2011-05-12评分:9.2https://p1.meituan.net/movie/1d0fa86bcf7a44484b9c16ac6af5be68191952.jpg@160w_220h_1e_1c--------------------排名:51《驯龙高手》主演：杰伊·巴鲁切尔,杰拉德·巴特勒,亚美莉卡·费雷拉上映时间：2010-05-14评分:9.0https://p1.meituan.net/movie/8194ae885ed9419aadf35c196af86ba4239039.jpg@160w_220h_1e_1c--------------------排名:52《少年派的奇幻漂流》主演：苏拉·沙玛,伊尔凡·可汗,塔布上映时间：2012-11-22评分:9.1https://p0.meituan.net/movie/34998e31c6d07475f1add6b8b16fd21d192579.jpg@160w_220h_1e_1c--------------------排名:53《神偷奶爸》主演：史蒂夫·卡瑞尔,杰森·席格尔,拉塞尔·布兰德上映时间：2010-07-09(美国)评分:9.0https://p0.meituan.net/movie/85c2bfba6025bfbfb53291ae5924c215308805.jpg@160w_220h_1e_1c--------------------排名:54《闻香识女人》主演：阿尔·帕西诺,克里斯·奥唐纳,加布里埃尔·安瓦尔上映时间：1992-12-23(美国)评分:8.8https://p0.meituan.net/movie/7cb7965469cb7ff95613714389f1ea3d87743.jpg@160w_220h_1e_1c--------------------排名:55《断背山》主演：希斯·莱杰,杰克·吉伦哈尔,米歇尔·威廉姆斯上映时间：2006-01-13(美国)评分:9.0https://p0.meituan.net/movie/e71affe126eeb4f8bfcc738cbddeebc8288766.jpg@160w_220h_1e_1c--------------------排名:56《飞屋环游记》主演：爱德华·阿斯纳,乔丹·长井,鲍勃·彼德森上映时间：2009-08-04评分:8.9https://p0.meituan.net/movie/47dd790e19dad72b50580641de5608c5199014.jpg@160w_220h_1e_1c--------------------排名:57《大话西游之月光宝盒》主演：周星驰,莫文蔚,吴孟达上映时间：2014-10-24评分:9.6https://p0.meituan.net/movie/92eb862c42c49f8e41e459c369c4512b226610.jpg@160w_220h_1e_1c--------------------排名:58《飞越疯人院》主演：杰克·尼科尔森,路易丝·弗莱彻,威尔·萨姆森上映时间：1975-11-19(美国)评分:8.8https://p1.meituan.net/movie/4dddd98730274c3b1464ff0a0ad195e5233381.jpg@160w_220h_1e_1c--------------------排名:59《怦然心动》主演：玛德琳·卡罗尔,卡兰·麦克奥利菲,艾丹·奎因上映时间：2010-08-06(美国)评分:8.9https://p0.meituan.net/movie/457a35fda360cb72090fa6dcbd1db3c1275333.jpg@160w_220h_1e_1c--------------------排名:60《美国往事》主演：罗伯特·德尼罗,詹姆斯·伍兹,伊丽莎白·麦戈文上映时间：1984-02-17(美国)评分:9.1https://p1.meituan.net/movie/92198a6fc8c3f5d13aa1bdf203572c0f99438.jpg@160w_220h_1e_1c--------------------排名:61《致命魔术》主演：休·杰克曼,克里斯蒂安·贝尔,迈克尔·凯恩上映时间：2006-10-20(美国)评分:8.8https://p1.meituan.net/movie/75c0d3eb584be030a01f2e26741a8f41251454.jpg@160w_220h_1e_1c--------------------排名:62《鬼子来了》主演：姜文,姜宏波,陈强上映时间：2000-05-12(法国戛纳)评分:8.9https://p1.meituan.net/movie/0b507aa44c4dfbbcc91949b69b1b39a168922.jpg@160w_220h_1e_1c--------------------排名:63《无敌破坏王》主演：约翰·C·赖利,萨拉·西尔弗曼,简·林奇上映时间：2012-11-06评分:9.1https://p0.meituan.net/movie/fcc17667b8343131101eeb4c67d90bf9150883.jpg@160w_220h_1e_1c--------------------排名:64《美丽心灵》主演：罗素·克洛,詹妮弗·康纳利,艾德·哈里斯上映时间：2001-12-21(美国)评分:8.8https://p0.meituan.net/movie/7b7d1f8aa36d7a15463ce6942708a1a7265296.jpg@160w_220h_1e_1c--------------------排名:65《蝙蝠侠：黑暗骑士崛起》主演：克里斯蒂安·贝尔,迈克尔·凯恩,加里·奥德曼上映时间：2012-08-27评分:8.9https://p1.meituan.net/movie/96bb58f3e9d213fb0438987d16d27561379209.jpg@160w_220h_1e_1c--------------------排名:66《夜访吸血鬼》主演：汤姆·克鲁斯,布拉德·皮特,克尔斯滕·邓斯特上映时间：1994-11-11(美国)评分:8.8https://p0.meituan.net/movie/7ec873ba943f13e3c63789d899bd0e23256871.jpg@160w_220h_1e_1c--------------------排名:67《倩女幽魂》主演：张国荣,王祖贤,午马上映时间：2011-04-30评分:9.2https://p1.meituan.net/movie/6d0510f326bf145dcf49a901fb949b77278838.jpg@160w_220h_1e_1c--------------------排名:68《哈利·波特与死亡圣器（下）》主演：丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃特森上映时间：2011-08-04评分:9.0https://p1.meituan.net/movie/68fa7db99e958c47d7aa07d015845a6f335154.jpg@160w_220h_1e_1c--------------------排名:69《本杰明·巴顿奇事》主演：布拉德·皮特,凯特·布兰切特,塔拉吉·P·汉森上映时间：2008-12-25(美国)评分:8.8https://p0.meituan.net/movie/2526f77c650bf7cf3d5ee2dccdeac332244951.jpg@160w_220h_1e_1c--------------------排名:70《钢琴家》主演：艾德里安·布洛迪,艾米莉娅·福克斯,米哈乌·热布罗夫斯基上映时间：2002-09-25(法国)评分:8.8https://p1.meituan.net/movie/484171372de45945e8bbbcc97db57e09136701.jpg@160w_220h_1e_1c--------------------排名:71《触不可及》主演：弗朗索瓦·克鲁塞,奥玛·希,安娜·勒尼上映时间：2011-11-02(法国)评分:9.1https://p0.meituan.net/movie/7874ba1378033b0b491df0cc56c43d25221208.jpg@160w_220h_1e_1c--------------------排名:72《熔炉》主演：孔刘,郑有美,金智英上映时间：2011-09-22(韩国)评分:8.8https://p1.meituan.net/movie/4ad513be2e9419ec7d7d63ba8cc2b6cc134065.jpg@160w_220h_1e_1c--------------------排名:73《初恋这件小事》主演：马里奥·毛瑞尔,平采娜·乐维瑟派布恩,阿查拉那·阿瑞亚卫考上映时间：2012-06-05评分:8.8https://p1.meituan.net/movie/7ed07b8ea8c0e0d0c7b685d20e3ec64e232004.jpg@160w_220h_1e_1c--------------------排名:74《大话西游之大圣娶亲》主演：周星驰,朱茵,莫文蔚上映时间：2014-10-24评分:8.8https://p1.meituan.net/movie/dc2246233a6f5ac1e34c7176b602c8ca174557.jpg@160w_220h_1e_1c--------------------排名:75《新龙门客栈》主演：张曼玉,梁家辉,甄子丹上映时间：2012-02-24评分:8.8https://p0.meituan.net/movie/9e9f12cfc1f54c973dda6c85bd3a139d334520.jpg@160w_220h_1e_1c--------------------排名:76《甜蜜蜜》主演：黎明,张曼玉,曾志伟上映时间：2015-02-13评分:9.2https://p1.meituan.net/movie/8ad5a0f521fb15637dfdf9cab38d414453783.jpg@160w_220h_1e_1c--------------------排名:77《小鞋子》主演：默罕默德·阿米尔·纳吉,Kamal Mirkarimi,Behzad Rafi上映时间：1999-01-22(美国)评分:9.1https://p1.meituan.net/movie/bc7b6ababa54e11577d45c05e84a33af54072.jpg@160w_220h_1e_1c--------------------排名:78《素媛》主演：李来,薛耿求,严志媛上映时间：2013-10-02(韩国)评分:9.1https://p0.meituan.net/movie/4cc4c55c29b77b090485ce9943bf6f87274708.jpg@160w_220h_1e_1c--------------------排名:79《萤火之森》主演：内山昂辉,佐仓绫音,后藤弘树上映时间：2011-09-17(日本)评分:9.0https://p0.meituan.net/movie/5420be40e3b755ffe04779b9b199e935256906.jpg@160w_220h_1e_1c--------------------排名:80《时空恋旅人》主演：瑞秋·麦克亚当斯,多姆纳尔·格里森,比尔·奈伊上映时间：2013-09-04(英国)评分:8.9https://p0.meituan.net/movie/4abc8c932cfacfc0089e2883765d02d1295222.jpg@160w_220h_1e_1c--------------------排名:81《穿条纹睡衣的男孩》主演：阿沙·巴特菲尔德,维拉·法梅加,大卫·休里斯上映时间：2008-09-12(英国)评分:9.0https://p1.meituan.net/movie/a0e0426a4390f5ecb49d25770a184dc0150779.jpg@160w_220h_1e_1c--------------------排名:82《窃听风暴》主演：乌尔里希·穆埃,塞巴斯蒂安·科赫,马蒂娜·格德克上映时间：2006-03-23(德国)评分:9.0https://p0.meituan.net/movie/3985eaf3858bea0f2a3d966bf7ee2103178217.jpg@160w_220h_1e_1c--------------------排名:83《借东西的小人阿莉埃蒂》主演：志田未来,神木隆之介,大竹忍上映时间：2010-07-17(日本)评分:8.8https://p0.meituan.net/movie/ce262f261f69fc3d679020402336a4af270365.jpg@160w_220h_1e_1c--------------------排名:84《恐怖直播》主演：河正宇,李璟荣,李大为上映时间：2013-07-31(韩国)评分:8.8https://p0.meituan.net/movie/b5ff0216e689b3fcc065590c48cd5105255305.jpg@160w_220h_1e_1c--------------------排名:85《7号房的礼物》主演：柳承龙,郑镇荣,朴信惠上映时间：2013-01-23(韩国)评分:8.9https://p1.meituan.net/movie/6a6e74b2c289f9fa4433dd2dc04a7741331638.jpg@160w_220h_1e_1c--------------------排名:86《海豚湾》主演：里克·奥巴瑞,路易·西霍尤斯,哈迪·琼斯上映时间：2009-07-31(美国)评分:8.9https://p0.meituan.net/movie/7373dbba07b50ce6f24336edb96b2ea4271536.jpg@160w_220h_1e_1c--------------------排名:87《忠犬八公物语》主演：仲代达矢,春川真澄,井川比佐志上映时间：1987-08-01(日本)评分:9.0https://p1.meituan.net/movie/c835b3588d0061ed3b992388a0a96f15160913.jpg@160w_220h_1e_1c--------------------排名:88《上帝之城》主演：亚历桑德雷·罗德里格斯,艾莉丝·布拉加,莱安德鲁·菲尔米诺上映时间：2002-08-30(巴西)评分:8.9https://p1.meituan.net/movie/b553d13f30100db731ab6cf45668e52d94703.jpg@160w_220h_1e_1c--------------------排名:89《辩护人》主演：宋康昊,郭度沅,吴达洙上映时间：2013-12-18(韩国)评分:8.8https://p0.meituan.net/movie/8fabf3894b7d12d3d2f6e66404813670265761.jpg@160w_220h_1e_1c--------------------排名:90《七武士》主演：三船敏郎,志村乔,千秋实上映时间：1954-04-26(日本)评分:9.1https://p1.meituan.net/movie/73349facab53529ab9e079c6c8c7c059281729.jpg@160w_220h_1e_1c--------------------排名:91《英雄本色》主演：狄龙,张国荣,周润发上映时间：2017-11-17评分:9.2https://p0.meituan.net/movie/3e5f5f3aa4b7e5576521e26c2c7c894d253975.jpg@160w_220h_1e_1c--------------------排名:92《一一》主演：吴念真,金燕玲,李凯莉上映时间：2000-09-20(法国)评分:8.9https://p1.meituan.net/movie/2c0a5fedf4b43d142121b91c6ccabe1b59051.jpg@160w_220h_1e_1c--------------------排名:93《完美的世界》主演：凯文·科斯特纳,克林特·伊斯特伍德,T·J·劳瑟上映时间：1993-11-24(美国)评分:8.9https://p1.meituan.net/movie/30310858fdab34c7a17cfd7ec8ad8bfc112201.jpg@160w_220h_1e_1c--------------------排名:94《海洋》主演：雅克·贝汉,姜文,兰斯洛特·佩林上映时间：2011-08-12评分:9.0https://p0.meituan.net/movie/0018b57299d0d4540330a31244c880a9112971.jpg@160w_220h_1e_1c--------------------排名:95《爱·回家》主演：俞承豪,金艺芬,童孝熙上映时间：2002-04-05(韩国)评分:9.0https://p1.meituan.net/movie/36a893c53a13f9bb934071b86ae3b5c492427.jpg@160w_220h_1e_1c--------------------排名:96《黄金三镖客》主演：克林特·伊斯特伍德,李·范·克里夫,埃里·瓦拉赫上映时间：1966-12-23(意大利)评分:8.9https://p1.meituan.net/movie/9bff56ed3ea38bb1825daa1d354bc92352781.jpg@160w_220h_1e_1c--------------------排名:97《我爱你》主演：宋在浩,李顺才,尹秀晶上映时间：2011-02-17(韩国)评分:9.0https://p1.meituan.net/movie/ed50b58bf636d207c56989872a91f4cf305138.jpg@160w_220h_1e_1c--------------------排名:98《迁徙的鸟》主演：雅克·贝汉,Philippe Labro上映时间：2001-12-12(法国)评分:9.1https://p1.meituan.net/movie/a1634f4e49c8517ae0a3e4adcac6b0dc43994.jpg@160w_220h_1e_1c--------------------排名:99《阿飞正传》主演：张国荣,张曼玉,刘德华上映时间：2018-06-25评分:8.8https://p0.meituan.net/movie/885fc379c614a2b4175587b95ac98eb95045650.jpg@160w_220h_1e_1c--------------------排名:100《龙猫》主演：帕特·卡洛尔,蒂姆·达利,丽娅·萨隆加上映时间：2018-12-14评分:9.2https://p0.meituan.net/movie/c304c687e287c7c2f9e22cf78257872d277201.jpg@160w_220h_1e_1c--------------------Process finished with exit code 0 保存到txt文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <url>%2F2019%2F01%2F14%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[切片 产生列表的子集字符串、列表、元组都支持切片操作切片的语法：[起始 ： 结束 ：步长]左闭右开 步长表示选取的间隔 默认是 1 1234567字符串切片name = "abcdefghijk"print(name[4:6]) # 取下表4-6，也就是name[4],name[5]print(name[2:]) # 结束缺省，表示取下标为2开始到最后的字符print(name[:3]) # 开始缺省，表示取开始到下标为3之前的字符print(name[1:-1]) # 负数索引返回离列表末尾相应距离的元素print(name[::-1]) # 步长为负， 表示从后往前切片 1234列表切片cars = ['Audi', 'BMW', 'BenZi', 'Toyota']print(cars[::-1]) # 逆序输出列表,实际结构没有发生改变print(cars[1:3]) # 产生列表的子集，切片始于'BMW',终于‘Benzi’ 123456切片的应用# 实现 [1，2，3，4....100]变成[[1,2,3],[4,5,6],...]a = [x for x in range(1, 101)]print(a)b = [a[x:x+3] for x in range(0, len(a), 3)] # 产生列表的子集print(b) 可变的类型 ： 列表List 字典Dict 集合Set列表List1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 列表nameList = ['zhangsan', 'lisi', 1234]# 打印列表print(nameList)# 访问print(nameList[0])# for循环遍历for name in nameList: print(name)# while循环遍历i = 0while i &lt; len(nameList): print(nameList[i]) i += 1# 列表的相关操作# 1. 添加元素# append()A = ['zhangsan', 'lisi', 1234]temp = input("请输入学生姓名:")A.append(temp)print(A)# extend()可以将另一个元素逐一追加到列表中,append是整体添加a = [1, 2]b = [3, 4]a.append(b)print(a)a.extend(b)print(a)# insert() 在指定位置插入元素(位置，元素)c = [0, 1, 2]c.insert(1, '3')print(c)# 2.修改操作A = ['xiaoming', 'xiaohong', 1234]A[1] = '小红'print(A)# 3.查询# in / not in / index / count# innameList = ['xiaoming', 'xiaohong', 1234]findName = input("请输入要查找的姓名")if findName in nameList: print("你要找的人在列表中")else: print("没找到")#index 返回第一次出现的序号#count 返回出现的次数a = ['a', 'b', 'c', 'a', 'b']index = a.index('a')print(index)count = a.count('a')print(count)# 4.删除nameList = ['xiaoming', 'xiaohong', 1234]# del 根据下表删除del nameList[2]print(nameList)# popprint(nameList)nameList.pop()print(nameList)# remove 根据元素的值进行删除a = ['a', 'b', 'c', 'a', 'b']print(a)a.remove('a')print(a)# 排序a = [1, 3, 4, 2]b = [1, 3, 4, 2]# sort()正序a.sort()#a.reverse(sort=True)print(a)# reverse() 逆序 也可以写作sort(reverse=True)，反过来不可以b.sort(reverse=True)#b.reverse()print(a) 1234567891011121314151617181920212223242526# 一个学校，有三个办公室，8位老师等待分配工位，完成随机分配# 定义一个列表import stringimport random# 定义一个列表来保存3个办公室offices = [[], [], []]# 定义一个列表来保存8个教师姓名names = []for i in range(8): names.append(string.ascii_uppercase[i])for name in names: index = random.randint(0, 2) offices[index].append(name)# print(offices)# 遍历展示i = 1for tempNames in offices: print("办公室%d的人数为 %d : " % (i, len(tempNames)), end='') i += 1 for name in tempNames: print("%s" % name, end=' ') print() print('-'*30) 字典Dict12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 字典 &#123;key1: value1, key2: value2&#125;info = &#123;'name': '马云', id: 100, 'sex': 'm', 'address': '杭州'&#125;# 根据键 进行访问# key: valueprint(info[id])# 访问不存在的键会报错#print(info['age']) #keyError: 'age‘# 面向对象的访问, 若不存在，返回默认值age = info.get('age', 18)print(age)print(type(age))# 常见操作# 1. 查看info = &#123;'name': '西卡', 'age': 26&#125;print(info['age'])# 修改age = input("请输入年龄:")info['age'] = ageprint(info)# 添加 键不存在，就会新增这个元素add = input("请输入户籍所在地:")info['address'] = addprint(info)# 删除 del删除字典某个元素 clear()清空字典# del info['address']# print(info)# info.clear()# print(info)# 字典方法# len() 键值对个数 以列表方式储存print(len(info))# keys()返回所有键 values() 返回所有值 以列表方式储存print(info.keys())print(info.values())# items 返回键值对列表 以列表方式储存print(info.items())# 字典的遍历# key()for key in info.keys(): print(key)# valuefor value in info.values(): print(value)# 项 (元素)for item in info.items(): print(item)for key, value in info.items(): print(key, value)# for 循环迭代# chars = ['a', 'b', 'c', 'd']# for i, chr in enumerate(chars):# print(i, chr) 集合Set123456789101112131415161718# 集合# 无序 元素唯一 一般用于元组或列表的元素去重set1 = &#123;1, 2, 3, 4&#125;# 添加元素 add()set1.add(9)print(set1)# 修改元素 update()set1.update('abcd')print(set1)# 删除元素 remove()不存在会报错set1.remove(1)print(set1)# pop 随机删除集合中某个元素set1.pop()print(set1)# discard 丢弃，放弃，不会报错set1.discard(123)print(set1) 不可变的类型 ：数字Num 字符串Str 元组Tuple数字NumPython Number 数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。 字符串StrPython不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。Python访问子字符串，可以使用方括号来截取字符串1234str = 'today is Sunday'print(str[4])print(len(str))print(type(str)) 元组Tuple123456789101112131415161718# 元组 tuple# python 中的元组和列表类似，元组的元素是无法进行修改的# 元组() 列表[]# return a, b, caTuple = ('et', 77 , 3.14)print(aTuple)print(type(aTuple))# 元组中只有一个元素，需要逗号结尾，否则会引起歧异bTuple = (12,)print(type(bTuple))# 访问元组print(aTuple[1])# 修改元组 不支持修改# aTuple[0] = 123# count indexa = ('a', 'b', 'c', 'd')print(a.index('a', 0, 3))print(a.count('b'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell读取文件并批量添加用户]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[在linux中要求从一个文件中读取用户名和密码，并批量添加账户 文件格式：12345[root@localhost jeremy]# cat users.list apple 12345banana 123456orange 123123pear 123123 第一步：读取用户名和密码 创建 user.sh文件 按行读取用户信息12345678910111213[root@localhost jeremy]# vim user.sh[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo echo $linedone[root@localhost jeremy]# ./user.sh apple 12345banana 123456orange 123123pear 123123 读取每一行内容并输出有多种方式12345678910111213141516171819202122232425262728293031&gt; 第一种 while&gt; while read line&gt; do&gt; echo $line&gt; done &lt; filename&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第二种 while&gt; cat filename | while read line&gt; do&gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第三种 for&gt; for line in `cat filename`&gt; do &gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for循环在读取文件时，任何空白字符都可以作为其读取的分隔符.&gt; while使用是换行符作为标记&gt; ex: &gt; for line in $(&lt;users.list) 结果如下&gt; apple&gt; 12345&gt; banana&gt; 123456&gt; orange&gt; 123123&gt; pear&gt; 123123&gt; 第二步：分割用户名和密码123456789101112131415[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` echo -n "USERNAME:$username PASSWORD:$password" echodone [root@localhost jeremy]# ./user.sh USERNAME:apple PASSWORD:12345USERNAME:banana PASSWORD:123456USERNAME:orange PASSWORD:123123USERNAME:pear PASSWORD:123123 第三步：批量添加用户12345678910111213141516171819[root@localhost jeremy]# cat user.sh#!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` useradd $username echo $password | passwd --stdin $usernamedone [root@localhost jeremy]# ./user.sh 更改用户 apple 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 banana 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 orange 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 pear 的密码 。passwd：所有的身份验证令牌已经成功更新。 第四步：完善脚本以上脚本再运行一便，会发现新增用户不行了。但会修改了密码.应该增加一个用户是否存在的判断.另外所有非Shell内建命令都建议使用全路径，以避免由于环境变量的问题造成command not found。最后，脚本主体要尽量少使用变量，所以需要在脚本开头定义变量.如下：12345678910111213141516!/bin/bashUSER_INFO=/home/jeremy/users.listUSERADD=/usr/sbin/useraddPASSWD=/usr/bin/passwdCUT=/bin/cutwhile read LINESdo USERNAME=`echo $LINES | $CUT -f1 -d' '` USERPASS=`echo $LINES | $CUT -f2 -d' '` $USERADD $USERNAME if [ $? -ne 0 ];then echo "$USERNAME exists,skip set password" else echo $USERPASS | $PASSWD --stdin $USERNAME fidone &lt; $USER_INFO]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本编程]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ShellShell 是一个用C语言编写的程序，它既是一种命令语言，又是一种程序设计语言。 Shell ScriptShell脚本，用shell编写的脚本程序 First Shell 创建一个.sh为文件后缀的文件，hello.sh 内容如下1234#!/bin/bash#注释#author : jeremyecho "Hello Shell !" 保存退出 先赋予执行权限 1# chmod a+x hello.sh 执行 1# ./hello.sh 变量定义变量123456variable_name=variable_value等号左右无空格ex:User="Jeremy"Pwd="123456" 访问变量使用美元符号$访问变量,可以给变量加上{ }花括号，帮助解释器识别变量的边界123456#！/bin/shUser="Jeremy"Pwd=“123456”echo $Userecho $&#123;Pwd&#125; 打印 User 和 Pwd 的值 只读变量使用readonly可以将变量定义为只读变量，只读变量的值不能改变1234#！/bin/shUser="Jeremy"readonly User 删除变量使用unset命令可以删除变量1234#！/bin/shUser="Jeremy"unset User 变量类型局部变量局部变量在脚本或命令中定义，仅在当前shell实例中有效 环境变量所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证正常运行，shell脚本也可以定义环境变量 shell变量shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 特殊变量1234567$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 数组ArraysBash Shell只支持一维数组，初始化时不需要定义数组大小1array_name=(value1...valueN) 定义数组123456array_name[index]=valueex:User[0]="apple"User[1]="banana"User[2]="orange" 访问数组和访问变量格式相同1234567891011$&#123;array_name[index]&#125;ex:User[0]="apple"User[1]="banana"User[2]="orange"echo $&#123;User[0]&#125;echo $&#123;User[@]&#125;以下两种方式可以访问数组中的所有项目$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 基本运算符Bourne shell没有任何机制来执行简单的算术，它使用外部程序awk或expr 运算符和表达式之间必须有空格 ` ` 倒逗号之间包含完整的表达式 1234#!/bin/shval=`expr 2 + 2`echo $val 算术运算符a=10b=20 运算符 说明 举例 + 加法 ` expr $a + $b ` 结果为 30。 - 减法 ` expr $a - $b ` 结果为 -10。 * 乘法 ` expr $a * $b ` 结果为 200。 / 除法 ` expr $b / $a ` 结果为 2。 % 取余 ` expr $b % $a ` 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等 [$a==$b] 返回 false。 != 不相等 [$a!=$b] 返回 true。 关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 Shell条件语句if … fishell expression求值，结果是true，statement被执行，否则不执行1234if[ expression ]then Statement(s) to be executed if expression is truefi if … else … fi123456if[ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi if … elif … fi123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi case .. esac这里的字符串字每个模式进行比较，直到找到一个匹配。执行语句匹配模式。如果没有找到匹配，声明退出的情况下不执行任何动作。没有最大数量的模式，但最小是一个。当语句部分执行，命令;; 表明程序流程跳转到结束整个 case 语句。和C编程语言的 break 类似。1234567891011case word in pattern1) Statement(s) to be executed if pattern1 matches ;; pattern2) Statement(s) to be executed if pattern2 matches ;; pattern3) Statement(s) to be executed if pattern3 matches ;;esac Shell循环类型while 循环这里Shell命令进行计算。如果结果值是 true，给定语句被执行。如果命令为 false，那么没有语句将不执行，程序将跳转到done语句后的下一行。1234while commanddo Statement(s) to be executed if command is truedone for 循环var是一个变量，word1 到 wordN 是由空格分隔的字符（字）序列的名称。每次for 循环的执行，变量var的值被设置为下一个单词的列表中的字，word1 到 wordN 。1234for var in word1 word2 ... wordNdo Statement(s) to be executed if command is truedone until 循环这里Shell命令进行评估计算。如果结果值是false，给定语句（s）被执行。如果命令没有语句为true，那么将不执行，程序会跳转到下一行done语句后。1234until commanddo Statement(s) to be executed until command is truedone select 循环var是一个变量，word1 到 wordN是由空格分隔的字符（字）序列的名称。每次for循环的执行，变量var的值被设置为下一个单词的列表中的字，由 word1 到wordN。 对于每一个选择的一组命令将被执行，在循环中。这个循环在ksh，并已被改编成的bash。这不是在sh。1234select var in word1 word2 ... wordNdo Statement(s) to be executed for every word.done]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[列出磁盘使用量df1# df [‐ahikHTm] 目录或文件名 -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes，MBytes，KBytes 等格式显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来 检查磁盘空间使用量du1# du [‐ahskm] 文件或目录名称 -a ：递归列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 ­s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显 磁盘分区fdisk1# fdisk [‐l] 装置名称（或者叫分区名称，下同） -l ：输出后面参数指定装置所有的分区内容。若仅有fdisk -l时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来 磁盘格式化1# mkfs [-t 文件系统格式] 装置名称（系统分区名称） -t ：可以指令文件系统格式，例如 xfs，ext4，ext3，ext2, vfat 等(系统有支持才会生 12将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：# mkfs ‐t ext3 /dev/hdc6 注意：如果一个分区已经格式化，则需要再次格式化时，可以加参数 -f 表示强制再次格式化。注意：如果一个分区已经挂载到一个目录之下，则不能在挂载的情况下进行再次格式化操作 磁盘检验fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck 命令对文件系统进行检查 1# fsck [‐t 文件系统] [‐ACay] 装置名称 -t ： 给定文件系统的格式，若在 /etc/fstab 中已有定义或 kernel 本身已支持的则需加上此参数-s ：依序一个一个地执行 fsck 的指令来检查-A ：对/etc/fstab 中所有列出来的 分区（partition）做检查-C ：显示完整的检查进度-d ：打印出 e2fsck 的 debug 结果-p ：同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R ：同时有 -A 条件时，省略 / 不检查-V ：详细显示模式-a ：如果检查有错则自动修复-r ：如果检查有错则由使用者回答是否修复-y ：选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复 磁盘挂载与卸载Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令 123456789101112131415挂载# mount [‐t 文件系统] [‐L Label名] [‐o 额外选项] [‐n] 装置文件名（也叫分区名称） 挂载点（也叫目录名）将刚刚创建的 /dev/hdc6 分区挂载到 /mnt/hdc6 上面# mkdir /mnt/hdc6# mount /dev/hdc6 /mnt/hdc6# dfFilesystem 1K‐blocks Used Available Use% Mounted on.....中间省略...../dev/hdc6 1976312 42072 1833836 3% /mnt/hd6卸载# umount /dev/hdc6-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况卸除]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux用户管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[系统用户账号的管理添加用户1# useradd &lt;选项&gt; 用户名 #添加新的用户账号 -c comment 指定一段用户注释性描述。-d 目录，指定用户主目录，如果此目录不存在，则同时配合使用-m 选项，可以自动创建主目录。-g 用户组，指定用户所属的用户组（主组）。-G 用户组，指定用户所属的附加组（可指定多个，当然并不建议太多个）。-s Shell 文件，指定用户的登录 Shell。默认是 /bin/bash，注意 /bin/bash 不等于是 /bin/sh。-u 用户号，指定用户的用户号，如果同时有-o 选项，则可以重复使用其它用户的标识 删除用户12# userdel 用户名 #删除用户# userdel -r 用户名 #把用户的主目录一起删除 修改账号1# usermod &lt;选项&gt; 用户名 #修改已有用户的信息 修改用户口令1# passwd &lt;选项&gt; 用户名 -l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令，即清除密码（设置空密码）-f 强迫用户下次登录时修改口令 系统用户组的管理增加用户组1# groupadd &lt;选项&gt; 用户组 -g GID 指定新用户组的组标识号（GID）。-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID相同。 删除用户组1# groupdel 用户组 修改用户组1# groupmod &lt;选项&gt; 用户组 -g GID 为用户组指定新的组标识号。-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。-n 新用户组，将用户组的名字改为新名字 切换用户组1# newgrp 用户组 与用户账号有关的系统文件/etc/passwd12# cat /etc/passwd用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/shadow/etc/shadow 中的记录行与 /etc/passwd 中的一一对应，它由 pwconv 命令根据/etc/passwd 中的数据自动产生。它的文件格式与 /etc/passwd 类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。“最小时间间隔”指的是两次修改口令之间所需的最小天数。“最大时间间隔”指的是口令保持有效的最大天数。“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了 /etc/group用户组的所有信息都存放在 /etc/group 文件中。此文件的格式也类似于 /etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与 /etc/passwd 中的登录名一样，组名不应重复。“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。”组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件基本属性及权限设置]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[文件基本属性123456789101112[jeremy@localhost ~]$ lltotal 0drwxrwxr-x. 2 jeremy jeremy 110 Oct 17 20:11 aaadrwxrwxr-x. 3 jeremy jeremy 30 Oct 6 20:43 bbbdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Desktopdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Documentsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Downloadsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Musicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Picturesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Publicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Templatesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Videos 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录当为[ - ]则是文件；若是[ l ]则表示为链接文件(link file)；若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置 接下来的字符中，以三个为一组，且均为 “rwx” 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 从左至右用 0-9 这些数字来表示。第 0 位确定文件类型，第 1-3 位确定文件属主（该文件的所有者）拥有该文件的权限。第 4-6 位确定文件属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。其中，第 1、4、7 位表示读权限，如果用 “r” 字符表示，则有读权限，如果用 “-“ 字符表示，则没有读权限；第 2、5、8 位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权 文件属主和属组 属主 ：该文件具有所有权的用户，通常时文件的所有者是指创建此文件的用户，或者手动指定的拥有者 属组 ：Linux中，用户时按组分类的，一个用户可以属于一个或者多个组。文件所有者以外的用户，又可以分为文件所有者的同组用户和其它用户。root是顶级用户，可以无视权限，进行任何操作。 更改文件属性chgrp1# chgrp [-R] 属组名 文件名 #更改文件属组，前提是组已经存在 -R : 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改 chown12# chown [-R] 属主名 文件名 #更改文件属主# chown [-R] 属主名：属组名 文件名 #更改文件属主，同时修改文件属组 chmodLinux 文件属性有两种设置方法，一种是数字，一种是符号。 数字类型Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己read/write/execute 权限123r:4w:2x:1 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的， 例如当权限为： [-rwxrwx—] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0 1# chmod [-R] xyz 文件或目录 #修改文件的9个属性 xyz ：为rwx属性数值的相加 R ：进行递归recursive的持续变更，即连同次目录下的所有文件都会变更 12345# ls ‐al .bashrc‐rw‐r‐‐r‐‐ 1 root root 395 Jul 4 11:45 .bashrc# chmod 777 .bashrc# ls ‐al .bashrc‐rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 符号类型基本上就九个权限分别是(1)user (2)group (3)others三种身份，那么我们就可以藉由u，g，o来代表三种身份的权限。此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r，w，x。也就是可以使用底下的方式1234# chmod [ugoa] +/-/= [rwx] 文件或目录+（加入）-(除去) =（设定）将文件权限设置为 -rwxr-xr-- 可以使用 chmod u=rwx,g=rx,o=r 文件名]]></content>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理及操作]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux 系统目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445/bin：bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。实际上是链接到/usr/bin。/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。/dev ：dev 是 Device(设备)的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的DLL文件，几乎所有的应用程序都需要用到这些共享库。64 位系统还有一个lib64，这两个目录连接到 /usr下对应的lib目录。/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。/media：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/ 上，然后进入该目录就可以查看光驱里的内容了。/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all/root：该目录为系统管理员，也称作超级权限者的用户主目录（相当于普通用户的家目录）。/sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。实际上连接到 /usr/sbin/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。/srv：该目录存放一些服务启动之后需要提取的数据。/sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。/tmp：这个目录是用来存放一些临时文件的。/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。/usr/bin：系统用户使用的应用程序。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点.. 来表示。12. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。 文件、目录常用命令绝对路径路径的写法，由根目录/写起，例如：/usr/share/doc这个目录。 相对路径路径的写法，不是由/写起，例如由 /usr/share/doc要到/usr/share/man底下时，可以写成：cd ../man这就是相对路径的写法 显示当前工作目录pwd12# pwd #Print Working Directory 显示当前所在目录# pwd -P #显示出确实的路径，而非使用连接路径 列出目录ls123# ls [‐aAdfFhilnrRSt] 目录名称# ls [‐‐color=&#123;never,auto,always&#125;] 目录名称# ls [‐‐full‐time] 目录名称 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来（常用）-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-l ：以长格式列出，包含文件的属性与权限等等数据；(常用)-i ：在第 1 列显示文件的 inode 节点号 切换目录cd1234567891011121314#使用 mkdir 命令创建 runoob 目录# mkdir runoob#使用绝对路径切换到 runoob 目录# cd /root/runoob/#使用相对路径切换到 runoob 目录# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；# cd .. 创建新目录mkdir1# mkdir [-mp] 目录名称 -m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色。-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来 删除空目录rmdir1# rmdir [-p] 目录名称 -p ：连同上一级的“空的”目录也一起删除 移除文件或目录rm1# rm [-fir] 文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除，最常用的目录删除！这是非常危险的选项 复制文件或目录cp12# cp [‐adfilprsu] 来源档(source) 目标档(destination)# cp [options] source1 source2 source3 .... directory -a：相当于 ­pdr 的意思，至于 pdr 请参考下列说明；(常用)-d：若来源文件为连接文件的属性(link file)，则复制连接文件而非文件本身；-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)-l：进行硬连接(hard link)的文件创建，而非复制文件本身；-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；-r：递归持续复制，用于目录的复制行为；(常用)-s：复制成为符号连接 (symbolic link)，亦即『连接』文件；-u：若 destination 比 source 旧才升级 destination 移动文件与目录，或修改名称mv12# mv [‐fiu] source destination# mv [options] source1 source2 source3 .... directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 文件内容查看cat1# cat [-AbEnTv] #由第一行开始显示文件内容 -A ：相当於 ­vET 的整合选项，可显示出一些特殊字符（如空白字符）；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字节 $ 显示出来；-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符 tactac 与 cat 命令刚好相反，文件内容从最后一行开始向前逐行显示，可以看出 tac 是cat 的倒写 nl1# nl [-bnw] 文件 #显示行号 -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数 more一页页翻动 空白键 (space)：代表向下翻一页；Enter ：代表向下翻『一行』/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；:f ：立刻显示出档名以及目前显示的行数；q ：代表立刻离开 more ，不再显示该文件内容b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用 less一页一页翻动 空白键 ：向下翻动一页；[pagedown]：向下翻动一页；[pageup] ：向上翻动一页；/字串 ：向下搜寻『字串』的功能；?字串 ：向上搜寻『字串』的功能；n ：重复前一个搜寻 (与 / 或 ? 有关！)N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)q ：离开 less 这个程序； head取出文件前面的几行1# head [-n number] 文件 -n ：后面接数字，代表显示几行的意思 tail取出文件后面几行1# tail [-nf number] 文件 -n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[终端12# clear #清空当前终端命令历史记录# exit #退出终端 关机和重启1234# reboot #重启# shutdown -r now #重启。等同reboot# shutdown -h now #关机，慎用，通常情况远程服务器关机后，物理机无法重启# halt #关机，慎用 目录和文件操作12345678910111213141516171819202122232425# cd &lt;directory&gt; #切换到指定目录下，参数可使用通配符，按下 tab 键可自动补足，连按两下 tab 键，则会将所有相关文件列出。directory 既可是绝对路径，也可是相对路径，./ 表示当前路径，../ 表示上一级路径，下同。# ls &lt;directory&gt; #列出指定目录下所有文件，如无参数，则列出当前目录下所有文件。directory 既可是绝对路径，也可是相对路径。# ls -l #以长格式形式列出所有文件，可简写为 ll。长格式规则：第1列：1位文件类型，9位权限标志。第2列：文件索引节点编号，第3列：文件所有者名称，第4列：文件属主所在组名称，第5列：文件大小，第6列：文件最后修改日期，第7列：文件名称。# ls -a #列出所有文件，包括隐藏文件。在 Linux 中，隐藏文件的文件名以 “.”开头。另外，命令参数若有多个可以合写，如ls ‐la。# cp &lt;source&gt; &lt;target&gt; #将 source 文件复制到 target 位置。source和 target 既可是绝对路径，也可是相对路径，支持通配符，下同。第二个参数是目录的话，表示将文件复制到指定目录下，第二个参数如果是文件名称的话，表示将源文件复制成参数2指定的新文件。# cp -r &lt;source&gt; &lt;target&gt; #递归复制，‐f 参数表示静默操作，无提示。有时 ‐f 可能会失效，详细原因见最后附录部分。# mv &lt;source&gt; &lt;target&gt; #移动 source 文件到 target 位置，相当于剪切，重命名也是使用此命令。‐f 参数表示静默操作，无警告提示。mv 没有 ‐r参数。# rm &lt;source&gt; #删除文件# rm -r &lt;source&gt; #递归删除，-f 参数表示静默操作，无警告提示# mkdir &lt;directory&gt; #创建目录# mkdir -p &lt;directory&gt; #递归操作# rmdir #删除空目录# man &lt;命令&gt; #查看命令帮助文档或使用说明，按q 退出说明 查看系统版本123# ll /etc/centos* # ll 命令等同于ls ‐l# ll /etc/centos‐release #按 tab 键可自动补足# cat /etc/centos‐release #cat 命令是直接在终端中显示 查看内核版本123456# uname ‐r #显示内核版本# uname ‐m #查看系统位数# uname ‐a #显示更全面的信息# arch #与 uname ‐m 命令非常类似。如果输出 x86_64 则表示为 64 位系统，如果输出i686 或 i386 则表示为 32 位系统# getconf LONG_BIT #查看系统位数# echo $LANG #查看语言与本地化 查看网络及网卡状态123456# ifconfig #查看网络及网卡状态# nmcli dev show #检查网卡状态# nmcli device show #与之上命令效果等同# nmcli #以简单模式显示网卡状态# nmcli con up ens33 #最后一个参数是网卡名称，执行此命令后，将会激活连接此网卡# nmcli con down ens33 #表示断开此网卡 查看当前系统用户12345# whoami #查看当前系统操作用户身份，本指令等同于执行 id -un 指令 # id -un #查看当前系统操作用户的身份# who am i #查看当前系统登录用户，注意：是登录 id# who ‐m #等同于 who am i# who #显示系统当前登录的所有用户 切换用户12345# su snow #切换到普通snow 账户# su root #切换到 root 账户，切换后相对路径与当前路径一致# su #等同于上一条# su ‐ #切换到 root 账户，切换后相对路径为 ~ ，即家目录。同时会显示最后一次登录时间。# exit #退出当前的临时切换账户状态 CentOS 7.5 系统配置国内 yum 源和 epel 首先进入 /etc/yum.repos.d/目录下，新建一个 repo_bak.d目录，用于保存系统中原来的 repo 文件 123# cd /etc/yum.repos.d/# mkdir repo_bak.d# mv *.repo repo_bak.d/ 在 CentOS 中配置使用网易和阿里的开源镜像点击右上角的网络管理器，连接网络。因为 CentOS 默认是不自动连接网络的。首选使用 su ‐ 命令切换到 root 用户。否则某些操作是无法完成的，需要 root 权限到网易和阿里开源镜像站点下载系统对应版本的 repo 12345# cd yum.repos.d# wget http://mirrors.aliyun.com/repo/Centos‐7.repo# wget http://mirrors.163.com/.help/CentOS7‐Base‐163.repo# lsCentos‐7.repo CentOS‐Base‐163.repo repo.bak 或者手动下载 repo 文件并上传到/etc/yum.repos.d/ 清除系统 yum 缓存并生成新的 yum 12# yum clean all# yum update #更新软件 安装 epel 源 1# yum ‐y install epel‐release 安装压缩、解压缩工具123# yum install zip unzip gzip p7zip #安装压缩与解压缩工具# yum remove zip unzip gzip p7zip #卸载压缩与解压缩工具# yum unzip -0 cp936 xxx.zip #解决使用unzip命令时中文乱码的问题 安装中文输入法1# yum install ibus ibus-table-wubi*]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux修改密码]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[修改/重置普通用户密码 passwd #用于当前操作用户自行修改密码。注意：修改密码时，需要输入当前操作用户的当前密码。root 用户也可使用此命令修改自行修改密码。 passwd &lt;用户名&gt; #此命令只能由 root 用户执行，当前用户是 root时，可更改任意其它用户的密码 修改/重置 root 用户密码重置root密码如果 root 用户密码忘记，需要重置 root 密码的话。可按如下步骤操作（前提，有条可以操作物理机开机重启）： 第一种方法 ： 开机，随意按一个键，进入开机项选择状态，否则 5 秒钟后系统默认选择第一项自动启动。按方向键选中第一项，按 e 进入编辑状态。事实上，选择其它项也可以，只不过，第一项是默认开机项，一般是最新的内核启动 进入编辑模式后。注意，显示的内容有可能并不是全部的内容，可以按方向键上下来查看更多内容 按方向键下，一直到内容的尾部。找到 linux16 这一行，将 ro 更改成rw init=/sysroot/bin/sh，按 ctrl + x 启动。注意：修改属临时修改，仅本次生效，重启电脑，又会恢复到原来的内容 启动后，进入单用户纯文本命令模式，注意：命令提示符是:/# 使用指令chroot /sysroot切换根目录。经测试，此句之前无须执行挂载指令mount ‐o remount,rw /sysroot 使用指令 passwd root ，来重置 root 用户的密码。由于本机安装了中文语言包，而当前文本命令模式不支持中文，所以修改密码时的提示，全部显示成了方块。如果未安装中文语言包的话，提示应该是英文的。不过操作很简单，就是输入两次密码，正确输入即可。注意1：不要输入过于简单的密码。注意2：更改LANG=en_US.UTF-8，依然是中文提示，且中文仍然会显示成方块。 使用touch /.autorelabel命令，会在 / 目录下创建一个 .autorelabel 文件，有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling。 使用命令 exit 退出 chroot 状态，使用命令 reboot 重启，使用 root 新密码登录。如果使用 reboot 不能重启，可以加入 -f 参数， reboot ‐f 强制重启。 重启后，进入以下状态 等待一会，系统会再次重启。正常进入系统。 第二种方法 ： 同样是开机时，按 e 进入编辑状态。将 ro 更改为 rw ，将 LANG=zh_CN.UTF-8 更改为 LANG=en_US.UTF-8，并在末尾追加空格，init=/bin/sh，注意：一定是在末尾添加。 按 Ctrl + x 启动。启动后如下 执行如下指令，修改密码。 123# passwd root# touch /.autorelabel #注意文件名称# exec /sbin/init #重启即可 注意：此种方式，修改 LANG=en_US.UTF-8，是可以显示英文的。注意：本方法命令行前缀是sh‐4.2# 启动后进入以下状态 第三种方法： 按 e 编辑，添加rd.break 启动后，如下状态：注意命令前缀switch_root，这是固定不变（不因不同的机器而变）的 依次输入以下指令，与第一种方法相同。注意指令前缀的变化123456# mount ‐o remount,rw /sysroot #如果不加这一句，是没有效果的。但第一种方法经测试，无须加此句。# chroot /sysroot# passwd root# touch /.autorelabel# exit# reboot #重启 两次重启后就会生效。注意：CentOS 6.x 版本和 7.x 版本，重置 root 密码的方法是不一样的。具体方法可查询网络。重置 root 用户密码是 Redhat RHCE 认证考试必须先完成的第一步操作，很明显，意味着这是最简单的必备技能。第二种方法相对简单一些。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linxu</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说点心情]]></title>
    <url>%2F2018%2F10%2F24%2F1024%E8%AF%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[还有人知道今天给我过节很开心有人记得我]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort快速排序算法]]></title>
    <url>%2F2018%2F10%2F09%2FQuicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序算法思想：二分法，分治法，递归 排序实例6 1 2 7 9 3 4 5 10 86为基准，也就是temp先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。 如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它 找到7 和 56 1 2 7 9 3 4 5 10 8 交换后得到6 1 2 5 9 3 4 7 10 8 依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下6 1 2 5 4 3 9 7 10 8 此时交换基准数与33 1 2 5 4 6 9 7 10 8 这样就保证了基准数6左边都比他小，右边都比他大这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序也就是进行递归排序算法，最终就得到排序结果1 2 3 4 5 6 7 8 9 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;void QuickSort(int* a, int left, int right) &#123; int i = left; int j = right; int temp = a[left]; int t = 0; if (left &gt;= right) return; while (i != j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= temp)//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp j--;//从右向左找第一个小于x的数 while (i &lt; j &amp;&amp; a[i] &lt;= temp)//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp i++;//从左向右找第一个大于x的数 //交换两个数在数组中的位置 if (i &lt; j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //将基准数归位 a[left] = a[i]; a[i] = temp; QuickSort(a, left, i - 1); QuickSort(a, i + 1, right); return;&#125;int main()&#123; int n; int a[101] = &#123;0&#125;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; QuickSort(a, 0, n-1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 测试用例： Input:113 4 5 1 34 61 22 41 111 2 87 Output:1 2 3 4 5 22 34 41 61 87 111]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络物理层]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的主要任务确定与传输媒体的接口有关的一些特性： 机械特性 电气特性 功能特性 过程特性 传输方式的转换 数据在计算机中多采用 并行传输 方式 数据在通信线路上的传输方式一般是 串行传输 数据通信的基础知识数据通信系统的模型 数据通信基本概念 模拟信号（连续信号） ：一般是正弦或余弦波形 数字信号（离散信号）：脉冲信号 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形 模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声 数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积信道及其极限容量 信道：数据传输的通道 单向通信：单工，单向传输 双向交替通信：半双工，一方发，一方收，不能同时 双向同时通信：全双工，同时发送和接收信息，需要两条信道 信道参数 数据传输速率 = 带宽 载波频率：信道对应的频率 采样频率：模拟信号转化为数字信号时采样的速率 量化：对采样信号的数字化 噪声、信噪比： 信噪比（dB）= 10log10(S/N)（dB） Nyquist定理——计算机通信的基本定理比特率 = log2V波特率在无噪信道中，当带宽为H Hz，信号电平为V级： 数据传输速率 = 2Hlog2V (b/s) V：信号电平的级数，在二进制中，仅为0、1两级采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰 香农（Shannon)定理：在噪声信道中，当带宽为H Hz，信噪比为 S/N ：最大数据传输速率（b/s）= Hlog2（1+S/N） 信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法让每一个码元携带更多比特的信息量 数据传输基带传输：​ - 基带信号：信号源产生的原始电信号，也叫基本频带信号​ - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制宽带传输​ - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输​ - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段​ - 宽带传输：多个频带的带通信号在同一个物理媒体上传输​ 数字数据在模拟信道上传输：数字信号——&gt;模拟信号 将数字数据调制成模拟信号进行传输，把0、1用波形表示 通常有三种基本的调制方式 调幅ASK：用载波的两种不同的振幅来表示两个二进制 调频FSK：用载波附近的两种不同的频率来表示两个二级制 调相PSK：用载波的相位移动来表示两个二进制 正交调相QPSK 正交调幅QAM 数字数据的数字信号传输 数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题 常用的数字信号编码方式： 不归零编码NRZ 曼切斯特编码——自同步编码方式 差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1 编码方式的比较： 不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟 曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟 差分曼切斯特编码与曼切斯特编码基本相同 模拟数据在数字信道上传输 模拟数据变成数字数据在数字信道上传递 采用脉冲编码调制（PCM–Pulse Code Modulation）技术 关键点：在接收端还原成模拟数据 PCM以Nyquist采样定理为基础 采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息 信道复用技术频分复用FDMFrequency Division Multiplexing前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和频分复用的所有用户再同样的时间占用不同的带宽资源 时分复用TDMTime Division Multiplexing每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输​ - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。​ - 每一个用户所占用的时隙是周期性地出现​ - TDM信号也称为等时信号​ - 时分复用地所有用户是在不同的时间占用同样的频带宽度 TDM的同步和异步：​ - 同步TDM:​ - 时间片与输入装置一一对应，同步​ - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲​ - 传输介质的传输速率不能低于各个输入信号的数据速率之和​ - 同步TDM可能会造成线路资源的浪费​ - 异步TDM​ - 时间片是按需动态分配的​ - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号​ - 在传输的数据单元中必须包含地址信息，以便寻址目的节点​ - 传输介质的传输速率只要不低于各个输入信号的平均速率即可​ - 异步TDM又称统计TDM(STDM) 波分复用WDMWavelength Division Multiplexing光的频分复用 码分复用CDMCode Division Multiplexing 码分多址（Code Division Multiple Access） 每个用户可以CDMA在同样的时间使用同样的频带进行通信 抗干扰强，频谱类似白噪声，不易被发现 采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等 码片序列（chip sequence） 每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。 通常m取值为64或128（在后面的原理性说明中，取为8） 每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 例如，S 站的 8 bit 码片序列是 00011011。 发送比特 1 时，就发送序列 00011011， 发送比特 0 时，就发送序列 11100100。 为了方便，将码片0写为–1 ，将1写为+1 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。 码片序列的正交关系 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0 交换技术物理媒体中间设备传递数据的技术 电路交换 在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接 一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址 服务质量好 线路的利用率较低 建立连接时间长，因连接建立时冲突概率高 报文交换 无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站 数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞 每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时） 分组交换 与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文 可以为分组在内存预留空间 每个分组中必须包含目的地址，并采用存储-转发机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计 每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置存储转发的速度较报文交换高 接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文 虚电路交换 将电路交换的概念引入到分组交换 信息传递依然采用分组（定义最大分组长度） 引入电路交换的连接建立过程 找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点 发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2018%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[因特网发展的三个阶段第一阶段：从单个网络ARPANET向互联网发展的过程ARPANET： 1969年美国国防部创建的第一个分组交换网 1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生 1990年关闭第二阶段：三级结构的因特网1985年美国国家科学基金会：NSFNET三级计算机网络： 主干网 地区网 校园网（或企业网）第三阶段：多层次ISP结构因特网 第一层：服务面积最大(一般是国家范围)，拥有高速主干网 NAP 第二层：第一层ISP的用户 第三层：又称本地ISP，拥有本地范围的网络 ISP: (Internet Service Provider) 互联网服务提供者（商）NAP:网络接入点NAP (Network Access Point)：分散主干网流量，又称对等点（peering point）IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组 英特网的组成因特网的边缘部分：由所有连接在因特网上的主机组成（通信和资源共享）因特网的核心部分：由大量网络和连接这些网络的路由器（router）组成，为边缘部分提供服务（连通性和交换） 另一种分法：资源子网，通信子网 边缘部分通信方式： 客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程 客户程序特点： 客户程序必须知道服务器程序的地址 不需要特殊的硬件和复杂的操作系统 服务程序特点： 可同时处理多个远地或本地客户的请求 系统启动后自动调用并一直不断的运行着 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器 核心部分三种交换方式： 路由器：实现分组交换的关键构建，转发收到的分组交换（switching）按照某种方式动态地分配传输线路的资源 电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源 通话前先拨号建立连接（经过一个或多个交换机） 通话过程中，通信双方一直占用所建立的连接 通话结束后，挂机释放连接 报文交换 分组交换 在发送端，先把较长的报文划分成较短的固定长度的数据端 每一个数据段前面添加上首部构成分组 依次把各分组发送到接收端 接收端剥去首部，抽出数据部分，还原成报文 每一个分组的首部都含有地址等控制信息结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机 路由器处理分组的过程： 把收到的分组先放入缓存； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去 优点： 高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。 缺点： 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 计算机网络分类1.按照网络的作用分类：​ - 广域网WAN（Wide Area Network）​ - 城域网MAN (Metropolitan Area Network)​ - 局域网LAN (Local Area Network)​ - 个人区域网PAN (Personal Area Network)2.按照网络的使用者分类：​ - 公用网（public network）​ - 专用网 (private network)3.原来把用户接入到互联网的网络：接入网 AN(Access Network) 计算机网络的性能 速率 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒） 带宽 某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ 计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s 吞吐量 表示在单位时间内通过某个网络（或信道、接口）的实际数据量 时延 发送时延主机或路由器发送数据帧所需要的时间​ 发送时延 = 数据帧长度 / 发送速率 传播时延电磁波在信道中传播一定的距离需要花费的时间​ 传播时延 = 信道长度 / 电磁波在信道上的传播速率 处理时延主机或路由器在收到分组时需要花费时间处理 排队时延分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 时延带宽积 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度） 往返时间RTT（Round-Trip Time） 发送时长 = 数据长度 / 发送速率 有效数据率 = 数据长度 / （发送时间 + RTT） 利用率 信道利用率和网络利用率，过高会产生非常大的时延 计算机网络的体系结构实体、协议、服务和服务访问点 实体： 表示任何可发送或接收信息的硬件或软件进程 对等实体peer entity 协议（protocol）： 控制两个对等实体进行通信的规则、标准或约定的集合 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务 网络协议的组成要素 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 同步：事件实现顺序的详细说明 协议与服务： 本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的 协议是”水平的“，协议是控制对等实体之间通信的规则 服务是”垂直的“，服务是由下层向上层通过层间接口提供的 并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语 服务访问点 SAP（Service Access Point）： 同一系统相邻两层实体进行交互的地方称为SAP 服务数据单元SDU(Service Data Unit) OSI/RM体系结构 层次 名称 作用 第七层 应用层(applicationg layer) 约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致 第六层 表示层(presentation layer) 表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义 第五层 会话层(session layer) 建立有关会话的机制，是双向的还是单向对话或重新建立会话 第四层 传输层(transport layer) 提供端到端的通路，应用到应用的通路 第三层 网络层(network layer) 提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括- 选择路由- 拥塞控制- 协议的转换- 分段和重组- 对用户的分组、字符等统计 第二层 数据连路层(data link layer) 提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收- 识别帧的标志- 帧的发送和接收，需校验、确认- 发送方在超时或收到否定性确认后，要重发- 重复帧要丢弃在共享网络中，需解决信道共享问题等——mac层 第一层 物理层(physical layer) 与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换 会话层及以下关心的是信息的传输表示层及以上关心的是信息的理解 TCP/IP的体系结构 层次 名称 作用 第五层 应用层 通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等 第四层 传输层 负责向两台主机中进程之间的通信提供通用的数据传输服务TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付 第三层 网络层 为分组交换网上的不同主机提供通信服务把传输层产生的报文段或用户数据报封装成分组或包进行传送选择合适路由网际协议IP和多路由选择协议 第二层 数据链路层 将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息 第一层 物理层 透明的传送比特流 传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层 数据传递过程 PDU(Protocol Data Unit)：对等层次间传送的数据单位 主机1 应用进程数据先传送到应用层,加上应用层首部，称为PDU 应用层PDU再传送到传输层，加上传输层首部，成为传输层报文 传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组 IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧 数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体 电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层 物理层接收到比特流，上交给数据链路层 数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层 网络层剥去首部，取出数据部分上交给传输层 传输层剥去首部，取出数据部分上交给应用层 应用层剥去首部，取出应用程序数据上交给应用进程主机2]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT 6 添加字数和阅读时间统计]]></title>
    <url>%2F2018%2F09%2F14%2FNexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[打开hexo目录，运行git bush，安装插件$ npm install hexo-symbols-count-time --save 修改博客配置文件，添加以下代码12345symbols_count_time:symbols: truetime: truetotal_symbols: truetotal_time: true 修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码123456symbols_count_time:separated_meta: trueitem_text_post: trueitem_text_total: falseawl: 4wpm: 275 重启服务]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给Hexo正确添加RSS订阅]]></title>
    <url>%2F2018%2F09%2F09%2Fhexo-rss%2F</url>
    <content type="text"><![CDATA[安装feed插件 本地hexo目录下运行git bash here 输入指令npm install hexo-generator-feed 等待安装完成 添加配置文件 打开hexo目录下配置文件_config.yml，末尾添加以下配置 # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 打开主题配置文件_config.yml,搜索rss，添加配置 rss: /atom.xml 发布hexo s]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>rss</tag>
      </tags>
  </entry>
</search>
