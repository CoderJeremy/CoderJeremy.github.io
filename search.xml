<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell读取文件并批量添加用户]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[在linux中要求从一个文件中读取用户名和密码，并批量添加账户 文件格式：12345[root@localhost jeremy]# cat users.list apple 12345banana 123456orange 123123pear 123123 第一步：读取用户名和密码 创建 user.sh文件 按行读取用户信息12345678910111213[root@localhost jeremy]# vim user.sh[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo echo $linedone[root@localhost jeremy]# ./user.sh apple 12345banana 123456orange 123123pear 123123 读取每一行内容并输出有多种方式12345678910111213141516171819202122232425262728293031&gt; 第一种 while&gt; while read line&gt; do&gt; echo $line&gt; done &lt; filename&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第二种 while&gt; cat filename | while read line&gt; do&gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第三种 for&gt; for line in `cat filename`&gt; do &gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for循环在读取文件时，任何空白字符都可以作为其读取的分隔符.&gt; while使用是换行符作为标记&gt; ex: &gt; for line in $(&lt;users.list) 结果如下&gt; apple&gt; 12345&gt; banana&gt; 123456&gt; orange&gt; 123123&gt; pear&gt; 123123&gt; 第二步：分割用户名和密码123456789101112131415[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` echo -n "USERNAME:$username PASSWORD:$password" echodone [root@localhost jeremy]# ./user.sh USERNAME:apple PASSWORD:12345USERNAME:banana PASSWORD:123456USERNAME:orange PASSWORD:123123USERNAME:pear PASSWORD:123123 第三步：批量添加用户12345678910111213141516171819[root@localhost jeremy]# cat user.sh#!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` useradd $username echo $password | passwd --stdin $usernamedone [root@localhost jeremy]# ./user.sh 更改用户 apple 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 banana 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 orange 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 pear 的密码 。passwd：所有的身份验证令牌已经成功更新。 第四步：完善脚本以上脚本再运行一便，会发现新增用户不行了。但会修改了密码.应该增加一个用户是否存在的判断.另外所有非Shell内建命令都建议使用全路径，以避免由于环境变量的问题造成command not found。最后，脚本主体要尽量少使用变量，所以需要在脚本开头定义变量.如下：12345678910111213141516!/bin/bashUSER_INFO=/home/jeremy/users.listUSERADD=/usr/sbin/useraddPASSWD=/usr/bin/passwdCUT=/bin/cutwhile read LINESdo USERNAME=`echo $LINES | $CUT -f1 -d' '` USERPASS=`echo $LINES | $CUT -f2 -d' '` $USERADD $USERNAME if [ $? -ne 0 ];then echo "$USERNAME exists,skip set password" else echo $USERPASS | $PASSWD --stdin $USERNAME fidone &lt; $USER_INFO]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本编程]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ShellShell 是一个用C语言编写的程序，它既是一种命令语言，又是一种程序设计语言。 Shell ScriptShell脚本，用shell编写的脚本程序 First Shell 创建一个.sh为文件后缀的文件，hello.sh 内容如下1234#!/bin/bash#注释#author : jeremyecho "Hello Shell !" 保存退出 先赋予执行权限 1# chmod a+x hello.sh 执行 1# ./hello.sh 变量定义变量123456variable_name=variable_value等号左右无空格ex:User="Jeremy"Pwd="123456" 访问变量使用美元符号$访问变量,可以给变量加上{ }花括号，帮助解释器识别变量的边界123456#！/bin/shUser="Jeremy"Pwd=“123456”echo $Userecho $&#123;Pwd&#125; 打印 User 和 Pwd 的值 只读变量使用readonly可以将变量定义为只读变量，只读变量的值不能改变1234#！/bin/shUser="Jeremy"readonly User 删除变量使用unset命令可以删除变量1234#！/bin/shUser="Jeremy"unset User 变量类型局部变量局部变量在脚本或命令中定义，仅在当前shell实例中有效 环境变量所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证正常运行，shell脚本也可以定义环境变量 shell变量shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 特殊变量1234567$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 数组ArraysBash Shell只支持一维数组，初始化时不需要定义数组大小1array_name=(value1...valueN) 定义数组123456array_name[index]=valueex:User[0]="apple"User[1]="banana"User[2]="orange" 访问数组和访问变量格式相同1234567891011$&#123;array_name[index]&#125;ex:User[0]="apple"User[1]="banana"User[2]="orange"echo $&#123;User[0]&#125;echo $&#123;User[@]&#125;以下两种方式可以访问数组中的所有项目$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 基本运算符Bourne shell没有任何机制来执行简单的算术，它使用外部程序awk或expr 运算符和表达式之间必须有空格 ` ` 倒逗号之间包含完整的表达式 1234#!/bin/shval=`expr 2 + 2`echo $val 算术运算符a=10b=20 运算符 说明 举例 + 加法 ` expr $a + $b ` 结果为 30。 - 减法 ` expr $a - $b ` 结果为 -10。 * 乘法 ` expr $a * $b ` 结果为 200。 / 除法 ` expr $b / $a ` 结果为 2。 % 取余 ` expr $b % $a ` 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等 [$a==$b] 返回 false。 != 不相等 [$a!=$b] 返回 true。 关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 Shell条件语句if … fishell expression求值，结果是true，statement被执行，否则不执行1234if[ expression ]then Statement(s) to be executed if expression is truefi if … else … fi123456if[ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi if … elif … fi123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi case .. esac这里的字符串字每个模式进行比较，直到找到一个匹配。执行语句匹配模式。如果没有找到匹配，声明退出的情况下不执行任何动作。没有最大数量的模式，但最小是一个。当语句部分执行，命令;; 表明程序流程跳转到结束整个 case 语句。和C编程语言的 break 类似。1234567891011case word in pattern1) Statement(s) to be executed if pattern1 matches ;; pattern2) Statement(s) to be executed if pattern2 matches ;; pattern3) Statement(s) to be executed if pattern3 matches ;;esac Shell循环类型while 循环这里Shell命令进行计算。如果结果值是 true，给定语句被执行。如果命令为 false，那么没有语句将不执行，程序将跳转到done语句后的下一行。1234while commanddo Statement(s) to be executed if command is truedone for 循环var是一个变量，word1 到 wordN 是由空格分隔的字符（字）序列的名称。每次for 循环的执行，变量var的值被设置为下一个单词的列表中的字，word1 到 wordN 。1234for var in word1 word2 ... wordNdo Statement(s) to be executed if command is truedone until 循环这里Shell命令进行评估计算。如果结果值是false，给定语句（s）被执行。如果命令没有语句为true，那么将不执行，程序会跳转到下一行done语句后。1234until commanddo Statement(s) to be executed until command is truedone select 循环var是一个变量，word1 到 wordN是由空格分隔的字符（字）序列的名称。每次for循环的执行，变量var的值被设置为下一个单词的列表中的字，由 word1 到wordN。 对于每一个选择的一组命令将被执行，在循环中。这个循环在ksh，并已被改编成的bash。这不是在sh。1234select var in word1 word2 ... wordNdo Statement(s) to be executed for every word.done]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[列出磁盘使用量df1# df [‐ahikHTm] 目录或文件名 -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes，MBytes，KBytes 等格式显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来 检查磁盘空间使用量du1# du [‐ahskm] 文件或目录名称 -a ：递归列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 ­s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显 磁盘分区fdisk1# fdisk [‐l] 装置名称（或者叫分区名称，下同） -l ：输出后面参数指定装置所有的分区内容。若仅有fdisk -l时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来 磁盘格式化1# mkfs [-t 文件系统格式] 装置名称（系统分区名称） -t ：可以指令文件系统格式，例如 xfs，ext4，ext3，ext2, vfat 等(系统有支持才会生 12将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：# mkfs ‐t ext3 /dev/hdc6 注意：如果一个分区已经格式化，则需要再次格式化时，可以加参数 -f 表示强制再次格式化。注意：如果一个分区已经挂载到一个目录之下，则不能在挂载的情况下进行再次格式化操作 磁盘检验fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck 命令对文件系统进行检查 1# fsck [‐t 文件系统] [‐ACay] 装置名称 -t ： 给定文件系统的格式，若在 /etc/fstab 中已有定义或 kernel 本身已支持的则需加上此参数-s ：依序一个一个地执行 fsck 的指令来检查-A ：对/etc/fstab 中所有列出来的 分区（partition）做检查-C ：显示完整的检查进度-d ：打印出 e2fsck 的 debug 结果-p ：同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R ：同时有 -A 条件时，省略 / 不检查-V ：详细显示模式-a ：如果检查有错则自动修复-r ：如果检查有错则由使用者回答是否修复-y ：选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复 磁盘挂载与卸载Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令 123456789101112131415挂载# mount [‐t 文件系统] [‐L Label名] [‐o 额外选项] [‐n] 装置文件名（也叫分区名称） 挂载点（也叫目录名）将刚刚创建的 /dev/hdc6 分区挂载到 /mnt/hdc6 上面# mkdir /mnt/hdc6# mount /dev/hdc6 /mnt/hdc6# dfFilesystem 1K‐blocks Used Available Use% Mounted on.....中间省略...../dev/hdc6 1976312 42072 1833836 3% /mnt/hd6卸载# umount /dev/hdc6-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况卸除]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux用户管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[系统用户账号的管理添加用户1# useradd &lt;选项&gt; 用户名 #添加新的用户账号 -c comment 指定一段用户注释性描述。-d 目录，指定用户主目录，如果此目录不存在，则同时配合使用-m 选项，可以自动创建主目录。-g 用户组，指定用户所属的用户组（主组）。-G 用户组，指定用户所属的附加组（可指定多个，当然并不建议太多个）。-s Shell 文件，指定用户的登录 Shell。默认是 /bin/bash，注意 /bin/bash 不等于是 /bin/sh。-u 用户号，指定用户的用户号，如果同时有-o 选项，则可以重复使用其它用户的标识 删除用户12# userdel 用户名 #删除用户# userdel -r 用户名 #把用户的主目录一起删除 修改账号1# usermod &lt;选项&gt; 用户名 #修改已有用户的信息 修改用户口令1# passwd &lt;选项&gt; 用户名 -l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令，即清除密码（设置空密码）-f 强迫用户下次登录时修改口令 系统用户组的管理增加用户组1# groupadd &lt;选项&gt; 用户组 -g GID 指定新用户组的组标识号（GID）。-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID相同。 删除用户组1# groupdel 用户组 修改用户组1# groupmod &lt;选项&gt; 用户组 -g GID 为用户组指定新的组标识号。-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。-n 新用户组，将用户组的名字改为新名字 切换用户组1# newgrp 用户组 与用户账号有关的系统文件/etc/passwd12# cat /etc/passwd用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/shadow/etc/shadow 中的记录行与 /etc/passwd 中的一一对应，它由 pwconv 命令根据/etc/passwd 中的数据自动产生。它的文件格式与 /etc/passwd 类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。“最小时间间隔”指的是两次修改口令之间所需的最小天数。“最大时间间隔”指的是口令保持有效的最大天数。“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了 /etc/group用户组的所有信息都存放在 /etc/group 文件中。此文件的格式也类似于 /etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与 /etc/passwd 中的登录名一样，组名不应重复。“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。”组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件基本属性及权限设置]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[文件基本属性123456789101112[jeremy@localhost ~]$ lltotal 0drwxrwxr-x. 2 jeremy jeremy 110 Oct 17 20:11 aaadrwxrwxr-x. 3 jeremy jeremy 30 Oct 6 20:43 bbbdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Desktopdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Documentsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Downloadsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Musicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Picturesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Publicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Templatesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Videos 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录当为[ - ]则是文件；若是[ l ]则表示为链接文件(link file)；若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置 接下来的字符中，以三个为一组，且均为 “rwx” 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 从左至右用 0-9 这些数字来表示。第 0 位确定文件类型，第 1-3 位确定文件属主（该文件的所有者）拥有该文件的权限。第 4-6 位确定文件属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。其中，第 1、4、7 位表示读权限，如果用 “r” 字符表示，则有读权限，如果用 “-“ 字符表示，则没有读权限；第 2、5、8 位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权 文件属主和属组 属主 ：该文件具有所有权的用户，通常时文件的所有者是指创建此文件的用户，或者手动指定的拥有者 属组 ：Linux中，用户时按组分类的，一个用户可以属于一个或者多个组。文件所有者以外的用户，又可以分为文件所有者的同组用户和其它用户。root是顶级用户，可以无视权限，进行任何操作。 更改文件属性chgrp1# chgrp [-R] 属组名 文件名 #更改文件属组，前提是组已经存在 -R : 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改 chown12# chown [-R] 属主名 文件名 #更改文件属主# chown [-R] 属主名：属组名 文件名 #更改文件属主，同时修改文件属组 chmodLinux 文件属性有两种设置方法，一种是数字，一种是符号。 数字类型Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己read/write/execute 权限123r:4w:2x:1 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的， 例如当权限为： [-rwxrwx—] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0 1# chmod [-R] xyz 文件或目录 #修改文件的9个属性 xyz ：为rwx属性数值的相加 R ：进行递归recursive的持续变更，即连同次目录下的所有文件都会变更 12345# ls ‐al .bashrc‐rw‐r‐‐r‐‐ 1 root root 395 Jul 4 11:45 .bashrc# chmod 777 .bashrc# ls ‐al .bashrc‐rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 符号类型基本上就九个权限分别是(1)user (2)group (3)others三种身份，那么我们就可以藉由u，g，o来代表三种身份的权限。此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r，w，x。也就是可以使用底下的方式1234# chmod [ugoa] +/-/= [rwx] 文件或目录+（加入）-(除去) =（设定）将文件权限设置为 -rwxr-xr-- 可以使用 chmod u=rwx,g=rx,o=r 文件名]]></content>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理及操作]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux 系统目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445/bin：bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。实际上是链接到/usr/bin。/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。/dev ：dev 是 Device(设备)的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的DLL文件，几乎所有的应用程序都需要用到这些共享库。64 位系统还有一个lib64，这两个目录连接到 /usr下对应的lib目录。/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。/media：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/ 上，然后进入该目录就可以查看光驱里的内容了。/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all/root：该目录为系统管理员，也称作超级权限者的用户主目录（相当于普通用户的家目录）。/sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。实际上连接到 /usr/sbin/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。/srv：该目录存放一些服务启动之后需要提取的数据。/sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。/tmp：这个目录是用来存放一些临时文件的。/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。/usr/bin：系统用户使用的应用程序。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点.. 来表示。12. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。 文件、目录常用命令绝对路径路径的写法，由根目录/写起，例如：/usr/share/doc这个目录。 相对路径路径的写法，不是由/写起，例如由 /usr/share/doc要到/usr/share/man底下时，可以写成：cd ../man这就是相对路径的写法 显示当前工作目录pwd12# pwd #Print Working Directory 显示当前所在目录# pwd -P #显示出确实的路径，而非使用连接路径 列出目录ls123# ls [‐aAdfFhilnrRSt] 目录名称# ls [‐‐color=&#123;never,auto,always&#125;] 目录名称# ls [‐‐full‐time] 目录名称 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来（常用）-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-l ：以长格式列出，包含文件的属性与权限等等数据；(常用)-i ：在第 1 列显示文件的 inode 节点号 切换目录cd1234567891011121314#使用 mkdir 命令创建 runoob 目录# mkdir runoob#使用绝对路径切换到 runoob 目录# cd /root/runoob/#使用相对路径切换到 runoob 目录# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；# cd .. 创建新目录mkdir1# mkdir [-mp] 目录名称 -m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色。-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来 删除空目录rmdir1# rmdir [-p] 目录名称 -p ：连同上一级的“空的”目录也一起删除 移除文件或目录rm1# rm [-fir] 文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除，最常用的目录删除！这是非常危险的选项 复制文件或目录cp12# cp [‐adfilprsu] 来源档(source) 目标档(destination)# cp [options] source1 source2 source3 .... directory -a：相当于 ­pdr 的意思，至于 pdr 请参考下列说明；(常用)-d：若来源文件为连接文件的属性(link file)，则复制连接文件而非文件本身；-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)-l：进行硬连接(hard link)的文件创建，而非复制文件本身；-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；-r：递归持续复制，用于目录的复制行为；(常用)-s：复制成为符号连接 (symbolic link)，亦即『连接』文件；-u：若 destination 比 source 旧才升级 destination 移动文件与目录，或修改名称mv12# mv [‐fiu] source destination# mv [options] source1 source2 source3 .... directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 文件内容查看cat1# cat [-AbEnTv] #由第一行开始显示文件内容 -A ：相当於 ­vET 的整合选项，可显示出一些特殊字符（如空白字符）；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字节 $ 显示出来；-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符 tactac 与 cat 命令刚好相反，文件内容从最后一行开始向前逐行显示，可以看出 tac 是cat 的倒写 nl1# nl [-bnw] 文件 #显示行号 -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数 more一页页翻动 空白键 (space)：代表向下翻一页；Enter ：代表向下翻『一行』/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；:f ：立刻显示出档名以及目前显示的行数；q ：代表立刻离开 more ，不再显示该文件内容b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用 less一页一页翻动 空白键 ：向下翻动一页；[pagedown]：向下翻动一页；[pageup] ：向上翻动一页；/字串 ：向下搜寻『字串』的功能；?字串 ：向上搜寻『字串』的功能；n ：重复前一个搜寻 (与 / 或 ? 有关！)N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)q ：离开 less 这个程序； head取出文件前面的几行1# head [-n number] 文件 -n ：后面接数字，代表显示几行的意思 tail取出文件后面几行1# tail [-nf number] 文件 -n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[终端12# clear #清空当前终端命令历史记录# exit #退出终端 关机和重启1234# reboot #重启# shutdown -r now #重启。等同reboot# shutdown -h now #关机，慎用，通常情况远程服务器关机后，物理机无法重启# halt #关机，慎用 目录和文件操作12345678910111213141516171819202122232425# cd &lt;directory&gt; #切换到指定目录下，参数可使用通配符，按下 tab 键可自动补足，连按两下 tab 键，则会将所有相关文件列出。directory 既可是绝对路径，也可是相对路径，./ 表示当前路径，../ 表示上一级路径，下同。# ls &lt;directory&gt; #列出指定目录下所有文件，如无参数，则列出当前目录下所有文件。directory 既可是绝对路径，也可是相对路径。# ls -l #以长格式形式列出所有文件，可简写为 ll。长格式规则：第1列：1位文件类型，9位权限标志。第2列：文件索引节点编号，第3列：文件所有者名称，第4列：文件属主所在组名称，第5列：文件大小，第6列：文件最后修改日期，第7列：文件名称。# ls -a #列出所有文件，包括隐藏文件。在 Linux 中，隐藏文件的文件名以 “.”开头。另外，命令参数若有多个可以合写，如ls ‐la。# cp &lt;source&gt; &lt;target&gt; #将 source 文件复制到 target 位置。source和 target 既可是绝对路径，也可是相对路径，支持通配符，下同。第二个参数是目录的话，表示将文件复制到指定目录下，第二个参数如果是文件名称的话，表示将源文件复制成参数2指定的新文件。# cp -r &lt;source&gt; &lt;target&gt; #递归复制，‐f 参数表示静默操作，无提示。有时 ‐f 可能会失效，详细原因见最后附录部分。# mv &lt;source&gt; &lt;target&gt; #移动 source 文件到 target 位置，相当于剪切，重命名也是使用此命令。‐f 参数表示静默操作，无警告提示。mv 没有 ‐r参数。# rm &lt;source&gt; #删除文件# rm -r &lt;source&gt; #递归删除，-f 参数表示静默操作，无警告提示# mkdir &lt;directory&gt; #创建目录# mkdir -p &lt;directory&gt; #递归操作# rmdir #删除空目录# man &lt;命令&gt; #查看命令帮助文档或使用说明，按q 退出说明 查看系统版本123# ll /etc/centos* # ll 命令等同于ls ‐l# ll /etc/centos‐release #按 tab 键可自动补足# cat /etc/centos‐release #cat 命令是直接在终端中显示 查看内核版本123456# uname ‐r #显示内核版本# uname ‐m #查看系统位数# uname ‐a #显示更全面的信息# arch #与 uname ‐m 命令非常类似。如果输出 x86_64 则表示为 64 位系统，如果输出i686 或 i386 则表示为 32 位系统# getconf LONG_BIT #查看系统位数# echo $LANG #查看语言与本地化 查看网络及网卡状态123456# ifconfig #查看网络及网卡状态# nmcli dev show #检查网卡状态# nmcli device show #与之上命令效果等同# nmcli #以简单模式显示网卡状态# nmcli con up ens33 #最后一个参数是网卡名称，执行此命令后，将会激活连接此网卡# nmcli con down ens33 #表示断开此网卡 查看当前系统用户12345# whoami #查看当前系统操作用户身份，本指令等同于执行 id -un 指令 # id -un #查看当前系统操作用户的身份# who am i #查看当前系统登录用户，注意：是登录 id# who ‐m #等同于 who am i# who #显示系统当前登录的所有用户 切换用户12345# su snow #切换到普通snow 账户# su root #切换到 root 账户，切换后相对路径与当前路径一致# su #等同于上一条# su ‐ #切换到 root 账户，切换后相对路径为 ~ ，即家目录。同时会显示最后一次登录时间。# exit #退出当前的临时切换账户状态 CentOS 7.5 系统配置国内 yum 源和 epel 首先进入 /etc/yum.repos.d/目录下，新建一个 repo_bak.d目录，用于保存系统中原来的 repo 文件 123# cd /etc/yum.repos.d/# mkdir repo_bak.d# mv *.repo repo_bak.d/ 在 CentOS 中配置使用网易和阿里的开源镜像点击右上角的网络管理器，连接网络。因为 CentOS 默认是不自动连接网络的。首选使用 su ‐ 命令切换到 root 用户。否则某些操作是无法完成的，需要 root 权限到网易和阿里开源镜像站点下载系统对应版本的 repo 12345# cd yum.repos.d# wget http://mirrors.aliyun.com/repo/Centos‐7.repo# wget http://mirrors.163.com/.help/CentOS7‐Base‐163.repo# lsCentos‐7.repo CentOS‐Base‐163.repo repo.bak 或者手动下载 repo 文件并上传到/etc/yum.repos.d/ 清除系统 yum 缓存并生成新的 yum 12# yum clean all# yum update #更新软件 安装 epel 源 1# yum ‐y install epel‐release 安装压缩、解压缩工具123# yum install zip unzip gzip p7zip #安装压缩与解压缩工具# yum remove zip unzip gzip p7zip #卸载压缩与解压缩工具# yum unzip -0 cp936 xxx.zip #解决使用unzip命令时中文乱码的问题 安装中文输入法1# yum install ibus ibus-table-wubi*]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux修改密码]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[修改/重置普通用户密码 passwd #用于当前操作用户自行修改密码。注意：修改密码时，需要输入当前操作用户的当前密码。root 用户也可使用此命令修改自行修改密码。 passwd &lt;用户名&gt; #此命令只能由 root 用户执行，当前用户是 root时，可更改任意其它用户的密码 修改/重置 root 用户密码重置root密码如果 root 用户密码忘记，需要重置 root 密码的话。可按如下步骤操作（前提，有条可以操作物理机开机重启）： 第一种方法 ： 开机，随意按一个键，进入开机项选择状态，否则 5 秒钟后系统默认选择第一项自动启动。按方向键选中第一项，按 e 进入编辑状态。事实上，选择其它项也可以，只不过，第一项是默认开机项，一般是最新的内核启动 进入编辑模式后。注意，显示的内容有可能并不是全部的内容，可以按方向键上下来查看更多内容 按方向键下，一直到内容的尾部。找到 linux16 这一行，将 ro 更改成rw init=/sysroot/bin/sh，按 ctrl + x 启动。注意：修改属临时修改，仅本次生效，重启电脑，又会恢复到原来的内容 启动后，进入单用户纯文本命令模式，注意：命令提示符是:/# 使用指令chroot /sysroot切换根目录。经测试，此句之前无须执行挂载指令mount ‐o remount,rw /sysroot 使用指令 passwd root ，来重置 root 用户的密码。由于本机安装了中文语言包，而当前文本命令模式不支持中文，所以修改密码时的提示，全部显示成了方块。如果未安装中文语言包的话，提示应该是英文的。不过操作很简单，就是输入两次密码，正确输入即可。注意1：不要输入过于简单的密码。注意2：更改LANG=en_US.UTF-8，依然是中文提示，且中文仍然会显示成方块。 使用touch /.autorelabel命令，会在 / 目录下创建一个 .autorelabel 文件，有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling。 使用命令 exit 退出 chroot 状态，使用命令 reboot 重启，使用 root 新密码登录。如果使用 reboot 不能重启，可以加入 -f 参数， reboot ‐f 强制重启。 重启后，进入以下状态 等待一会，系统会再次重启。正常进入系统。 第二种方法 ： 同样是开机时，按 e 进入编辑状态。将 ro 更改为 rw ，将 LANG=zh_CN.UTF-8 更改为 LANG=en_US.UTF-8，并在末尾追加空格，init=/bin/sh，注意：一定是在末尾添加。 按 Ctrl + x 启动。启动后如下 执行如下指令，修改密码。 123# passwd root# touch /.autorelabel #注意文件名称# exec /sbin/init #重启即可 注意：此种方式，修改 LANG=en_US.UTF-8，是可以显示英文的。注意：本方法命令行前缀是sh‐4.2# 启动后进入以下状态 第三种方法： 按 e 编辑，添加rd.break 启动后，如下状态：注意命令前缀switch_root，这是固定不变（不因不同的机器而变）的 依次输入以下指令，与第一种方法相同。注意指令前缀的变化123456# mount ‐o remount,rw /sysroot #如果不加这一句，是没有效果的。但第一种方法经测试，无须加此句。# chroot /sysroot# passwd root# touch /.autorelabel# exit# reboot #重启 两次重启后就会生效。注意：CentOS 6.x 版本和 7.x 版本，重置 root 密码的方法是不一样的。具体方法可查询网络。重置 root 用户密码是 Redhat RHCE 认证考试必须先完成的第一步操作，很明显，意味着这是最简单的必备技能。第二种方法相对简单一些。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linxu</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说点心情]]></title>
    <url>%2F2018%2F10%2F24%2F1024%E8%AF%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[还有人知道今天给我过节很开心有人记得我]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort快速排序算法]]></title>
    <url>%2F2018%2F10%2F09%2FQuicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序算法思想：二分法，分治法，递归 排序实例6 1 2 7 9 3 4 5 10 86为基准，也就是temp先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。 如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它 找到7 和 56 1 2 7 9 3 4 5 10 8 交换后得到6 1 2 5 9 3 4 7 10 8 依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下6 1 2 5 4 3 9 7 10 8 此时交换基准数与33 1 2 5 4 6 9 7 10 8 这样就保证了基准数6左边都比他小，右边都比他大这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序也就是进行递归排序算法，最终就得到排序结果1 2 3 4 5 6 7 8 9 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;void QuickSort(int* a, int left, int right) &#123; int i = left; int j = right; int temp = a[left]; int t = 0; if (left &gt;= right) return; while (i != j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= temp)//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp j--;//从右向左找第一个小于x的数 while (i &lt; j &amp;&amp; a[i] &lt;= temp)//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp i++;//从左向右找第一个大于x的数 //交换两个数在数组中的位置 if (i &lt; j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //将基准数归位 a[left] = a[i]; a[i] = temp; QuickSort(a, left, i - 1); QuickSort(a, i + 1, right); return;&#125;int main()&#123; int n; int a[101] = &#123;0&#125;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; QuickSort(a, 0, n-1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 测试用例： Input:113 4 5 1 34 61 22 41 111 2 87 Output:1 2 3 4 5 22 34 41 61 87 111]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络物理层]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的主要任务确定与传输媒体的接口有关的一些特性： 机械特性 电气特性 功能特性 过程特性 传输方式的转换 数据在计算机中多采用 并行传输 方式 数据在通信线路上的传输方式一般是 串行传输 数据通信的基础知识数据通信系统的模型 数据通信基本概念 模拟信号（连续信号） ：一般是正弦或余弦波形 数字信号（离散信号）：脉冲信号 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形 模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声 数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积信道及其极限容量 信道：数据传输的通道 单向通信：单工，单向传输 双向交替通信：半双工，一方发，一方收，不能同时 双向同时通信：全双工，同时发送和接收信息，需要两条信道 信道参数 数据传输速率 = 带宽 载波频率：信道对应的频率 采样频率：模拟信号转化为数字信号时采样的速率 量化：对采样信号的数字化 噪声、信噪比： 信噪比（dB）= 10log10(S/N)（dB） Nyquist定理——计算机通信的基本定理比特率 = log2V波特率在无噪信道中，当带宽为H Hz，信号电平为V级： 数据传输速率 = 2Hlog2V (b/s) V：信号电平的级数，在二进制中，仅为0、1两级采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰 香农（Shannon)定理：在噪声信道中，当带宽为H Hz，信噪比为 S/N ：最大数据传输速率（b/s）= Hlog2（1+S/N） 信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法让每一个码元携带更多比特的信息量 数据传输基带传输：​ - 基带信号：信号源产生的原始电信号，也叫基本频带信号​ - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制宽带传输​ - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输​ - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段​ - 宽带传输：多个频带的带通信号在同一个物理媒体上传输​ 数字数据在模拟信道上传输：数字信号——&gt;模拟信号 将数字数据调制成模拟信号进行传输，把0、1用波形表示 通常有三种基本的调制方式 调幅ASK：用载波的两种不同的振幅来表示两个二进制 调频FSK：用载波附近的两种不同的频率来表示两个二级制 调相PSK：用载波的相位移动来表示两个二进制 正交调相QPSK 正交调幅QAM 数字数据的数字信号传输 数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题 常用的数字信号编码方式： 不归零编码NRZ 曼切斯特编码——自同步编码方式 差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1 编码方式的比较： 不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟 曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟 差分曼切斯特编码与曼切斯特编码基本相同 模拟数据在数字信道上传输 模拟数据变成数字数据在数字信道上传递 采用脉冲编码调制（PCM–Pulse Code Modulation）技术 关键点：在接收端还原成模拟数据 PCM以Nyquist采样定理为基础 采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息 信道复用技术频分复用FDMFrequency Division Multiplexing前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和频分复用的所有用户再同样的时间占用不同的带宽资源 时分复用TDMTime Division Multiplexing每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输​ - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。​ - 每一个用户所占用的时隙是周期性地出现​ - TDM信号也称为等时信号​ - 时分复用地所有用户是在不同的时间占用同样的频带宽度 TDM的同步和异步：​ - 同步TDM:​ - 时间片与输入装置一一对应，同步​ - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲​ - 传输介质的传输速率不能低于各个输入信号的数据速率之和​ - 同步TDM可能会造成线路资源的浪费​ - 异步TDM​ - 时间片是按需动态分配的​ - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号​ - 在传输的数据单元中必须包含地址信息，以便寻址目的节点​ - 传输介质的传输速率只要不低于各个输入信号的平均速率即可​ - 异步TDM又称统计TDM(STDM) 波分复用WDMWavelength Division Multiplexing光的频分复用 码分复用CDMCode Division Multiplexing 码分多址（Code Division Multiple Access） 每个用户可以CDMA在同样的时间使用同样的频带进行通信 抗干扰强，频谱类似白噪声，不易被发现 采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等 码片序列（chip sequence） 每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。 通常m取值为64或128（在后面的原理性说明中，取为8） 每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 例如，S 站的 8 bit 码片序列是 00011011。 发送比特 1 时，就发送序列 00011011， 发送比特 0 时，就发送序列 11100100。 为了方便，将码片0写为–1 ，将1写为+1 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。 码片序列的正交关系 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0 交换技术物理媒体中间设备传递数据的技术 电路交换 在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接 一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址 服务质量好 线路的利用率较低 建立连接时间长，因连接建立时冲突概率高 报文交换 无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站 数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞 每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时） 分组交换 与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文 可以为分组在内存预留空间 每个分组中必须包含目的地址，并采用存储-转发机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计 每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置存储转发的速度较报文交换高 接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文 虚电路交换 将电路交换的概念引入到分组交换 信息传递依然采用分组（定义最大分组长度） 引入电路交换的连接建立过程 找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点 发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2018%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[因特网发展的三个阶段第一阶段：从单个网络ARPANET向互联网发展的过程ARPANET： 1969年美国国防部创建的第一个分组交换网 1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生 1990年关闭第二阶段：三级结构的因特网1985年美国国家科学基金会：NSFNET三级计算机网络： 主干网 地区网 校园网（或企业网）第三阶段：多层次ISP结构因特网 第一层：服务面积最大(一般是国家范围)，拥有高速主干网 NAP 第二层：第一层ISP的用户 第三层：又称本地ISP，拥有本地范围的网络 ISP: (Internet Service Provider) 互联网服务提供者（商）NAP:网络接入点NAP (Network Access Point)：分散主干网流量，又称对等点（peering point）IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组 英特网的组成因特网的边缘部分：由所有连接在因特网上的主机组成（通信和资源共享）因特网的核心部分：由大量网络和连接这些网络的路由器（router）组成，为边缘部分提供服务（连通性和交换） 另一种分法：资源子网，通信子网 边缘部分通信方式： 客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程 客户程序特点： 客户程序必须知道服务器程序的地址 不需要特殊的硬件和复杂的操作系统 服务程序特点： 可同时处理多个远地或本地客户的请求 系统启动后自动调用并一直不断的运行着 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器 核心部分三种交换方式： 路由器：实现分组交换的关键构建，转发收到的分组交换（switching）按照某种方式动态地分配传输线路的资源 电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源 通话前先拨号建立连接（经过一个或多个交换机） 通话过程中，通信双方一直占用所建立的连接 通话结束后，挂机释放连接 报文交换 分组交换 在发送端，先把较长的报文划分成较短的固定长度的数据端 每一个数据段前面添加上首部构成分组 依次把各分组发送到接收端 接收端剥去首部，抽出数据部分，还原成报文 每一个分组的首部都含有地址等控制信息结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机 路由器处理分组的过程： 把收到的分组先放入缓存； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去 优点： 高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。 缺点： 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 计算机网络分类1.按照网络的作用分类：​ - 广域网WAN（Wide Area Network）​ - 城域网MAN (Metropolitan Area Network)​ - 局域网LAN (Local Area Network)​ - 个人区域网PAN (Personal Area Network)2.按照网络的使用者分类：​ - 公用网（public network）​ - 专用网 (private network)3.原来把用户接入到互联网的网络：接入网 AN(Access Network) 计算机网络的性能 速率 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒） 带宽 某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ 计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s 吞吐量 表示在单位时间内通过某个网络（或信道、接口）的实际数据量 时延 发送时延主机或路由器发送数据帧所需要的时间​ 发送时延 = 数据帧长度 / 发送速率 传播时延电磁波在信道中传播一定的距离需要花费的时间​ 传播时延 = 信道长度 / 电磁波在信道上的传播速率 处理时延主机或路由器在收到分组时需要花费时间处理 排队时延分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 时延带宽积 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度） 往返时间RTT（Round-Trip Time） 发送时长 = 数据长度 / 发送速率 有效数据率 = 数据长度 / （发送时间 + RTT） 利用率 信道利用率和网络利用率，过高会产生非常大的时延 计算机网络的体系结构实体、协议、服务和服务访问点 实体： 表示任何可发送或接收信息的硬件或软件进程 对等实体peer entity 协议（protocol）： 控制两个对等实体进行通信的规则、标准或约定的集合 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务 网络协议的组成要素 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 同步：事件实现顺序的详细说明 协议与服务： 本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的 协议是”水平的“，协议是控制对等实体之间通信的规则 服务是”垂直的“，服务是由下层向上层通过层间接口提供的 并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语 服务访问点 SAP（Service Access Point）： 同一系统相邻两层实体进行交互的地方称为SAP 服务数据单元SDU(Service Data Unit) OSI/RM体系结构 层次 名称 作用 第七层 应用层(applicationg layer) 约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致 第六层 表示层(presentation layer) 表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义 第五层 会话层(session layer) 建立有关会话的机制，是双向的还是单向对话或重新建立会话 第四层 传输层(transport layer) 提供端到端的通路，应用到应用的通路 第三层 网络层(network layer) 提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括- 选择路由- 拥塞控制- 协议的转换- 分段和重组- 对用户的分组、字符等统计 第二层 数据连路层(data link layer) 提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收- 识别帧的标志- 帧的发送和接收，需校验、确认- 发送方在超时或收到否定性确认后，要重发- 重复帧要丢弃在共享网络中，需解决信道共享问题等——mac层 第一层 物理层(physical layer) 与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换 会话层及以下关心的是信息的传输表示层及以上关心的是信息的理解 TCP/IP的体系结构 层次 名称 作用 第五层 应用层 通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等 第四层 传输层 负责向两台主机中进程之间的通信提供通用的数据传输服务TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付 第三层 网络层 为分组交换网上的不同主机提供通信服务把传输层产生的报文段或用户数据报封装成分组或包进行传送选择合适路由网际协议IP和多路由选择协议 第二层 数据链路层 将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息 第一层 物理层 透明的传送比特流 传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层 数据传递过程 PDU(Protocol Data Unit)：对等层次间传送的数据单位 主机1 应用进程数据先传送到应用层,加上应用层首部，称为PDU 应用层PDU再传送到传输层，加上传输层首部，成为传输层报文 传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组 IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧 数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体 电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层 物理层接收到比特流，上交给数据链路层 数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层 网络层剥去首部，取出数据部分上交给传输层 传输层剥去首部，取出数据部分上交给应用层 应用层剥去首部，取出应用程序数据上交给应用进程主机2]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT 6 添加字数和阅读时间统计]]></title>
    <url>%2F2018%2F09%2F14%2FNexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[打开hexo目录，运行git bush，安装插件$ npm install hexo-symbols-count-time --save 修改博客配置文件，添加以下代码12345symbols_count_time:symbols: truetime: truetotal_symbols: truetotal_time: true 修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码123456symbols_count_time:separated_meta: trueitem_text_post: trueitem_text_total: falseawl: 4wpm: 275 重启服务]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给Hexo正确添加RSS订阅]]></title>
    <url>%2F2018%2F09%2F09%2Fhexo-rss%2F</url>
    <content type="text"><![CDATA[安装feed插件 本地hexo目录下运行git bash here 输入指令npm install hexo-generator-feed 等待安装完成 添加配置文件 打开hexo目录下配置文件_config.yml，末尾添加以下配置 # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 打开主题配置文件_config.yml,搜索rss，添加配置 rss: /atom.xml 发布hexo s]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>rss</tag>
      </tags>
  </entry>
</search>
