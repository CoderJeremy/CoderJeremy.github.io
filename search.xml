<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2020%2F03%2F01%2FJSP%2F</url>
    <content type="text"><![CDATA[JSP 概念：Java Server Pages：Java服务器端页面 原理：JSP本质上是一个Servlet 服务器解析请求消息，找是否有index.jsp页面 如果有，会将index.jsp转换为.java文件 编译.java文件，生成.class字节码文件 由字节码文件提供访问 JSP的脚本：JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本就可以定义什么内容 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么 JSP的内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 一共9个内置对象 request response out：字符输出流对象，可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 JSP指令 作用：用于配置JSP页面，导入资源文件 格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ...%&gt; 分类： page：配置JSP页面 contentType：等同于response.setContentType() 设置响应体的MIME类型以及字符集 设置当前JSP页面的编码。（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，回自动跳转到指定的错误页面 isErrorPage：标识当前页面是否是错误页面 true：是，可以使用内置对象exception false；否，默认值。不可以使用内置对象exception include：页面包含的。导入页面的资源文件 格式： &lt;%@inlude file=&quot;xxx.jsp&quot;%&gt; taglib：导入资源，导入标签库 格式：&lt;%@ taglib prefix=&quot; &quot; uri=&quot; &quot; %&gt; prefix：前缀，自定义的 JSP注释 html注释： &lt;!-- --&gt;：只能注释html代码片段 jsp注释：推荐使用 &lt;%-- --%&gt;：可以注释所有 JSP内置对象 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 MVC开发模式 jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中写大量的java代码，又写html标签，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC Model：模型。JavaBean 完成具体的业务操作。如：查询数据库，封装对象 View：View视图。JSP 展示数据 Controller：控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 EL表达式 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中java代码的编写 语法：${表达式} 注意：JSP默认支持EL表达式。如果要忽略EL表达式 设置jsp中page指令中：isELIgnored=&quot;true&quot;，忽略当前jsp页面中所有的el表达式 \${表达式} ：忽略当前这个el表达式 使用： 运算 算数运算符 ： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}：判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}：判断字符串、集合、数组对象是否不为null 并且长度大于0 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 pageScope–&gt;pageContext requestScope–&gt;request sessionScope–&gt;session applicationScope–&gt;application（ServletContext ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会区调用对象的getter方法 List集合 ${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[&quot;key名称&quot;]} 隐式对象： EL表达式中有11个隐式对象 pageContext：获取JSP其他八个内置对象 ${pageContext.request.contextPath}：在JSP页面动态获取虚拟目录 JSTL 概念：JavaServer Pages Tag Library JSP标准标签库 由Apache组织提供的开源的免费的jsp标签 作用：用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关的jar包：&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 引入标签库：taglib指令：&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt; 使用标签 常用的JSTL标签 if：相当于java的if test：必须属性，接受boolean表达式 如果表达式为true,则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合EL表达式一起使用 注意 c:if标签没有else情况，需要else情况，则可以再定义一个c:if标签 123&lt;c:if test="true"&gt;&lt;h3&gt;这是真的&lt;/h3&gt;&lt;/c:if&gt; choose：相当于java的switch语句 12345678910&lt;c:choose&gt;&lt;c:when test="$&#123;requestScope.day==1&#125;&#125;"&gt;星期一&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==2&#125;&#125;"&gt;星期二&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==3&#125;&#125;"&gt;星期三&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==4&#125;&#125;"&gt;星期四&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==5&#125;&#125;"&gt;星期五&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==6&#125;&#125;"&gt;星期六&lt;/c:when&gt;&lt;c:when test="$&#123;requestScope.day==7&#125;&#125;"&gt;星期日&lt;/c:when&gt;&lt;c:otherwise&gt;数字输入有误&lt;/c:otherwise&gt;&lt;/c:choose&gt; foreach：相当于java代码的for语句 完成重复操作 begin：开始值 end：结束值 var：临时变量 step：步长 varStatus：循环状态对象 index：容器中元素的索引，从0开始 count：循环次数，从1开始 12345&lt;c:forEach begin="0" end="5" var="i" step="1" varStatus="s"&gt; $&#123;i&#125; $&#123;s.index&#125; $&#123;s.count&#125;&lt;br&gt;&lt;/c:forEach&gt; 遍历容器 item：容器对象 var：容器中元素的临时变量 三层架构：软件设计架构 界面层(表示层/web)：用户可以通过界面上的组件和服务器进行交互。 接收用户参数，封装数据，调用业务逻辑层完成处理，转发jsp页面完成显示 SpringMVC 业务逻辑层(service)：处理业务逻辑的。 组合DAO层中的简单方法，形成复杂的业务逻辑操作 Spring 数据访问层(dao)：操作数据存储文件。 定义对于数据库基本的CRUD操作 Mybatis]]></content>
      <tags>
        <tag>jsp</tag>
        <tag>el</tag>
        <tag>jstl</tag>
        <tag>mvc</tag>
        <tag>三层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2020%2F02%2F27%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP概述 Hyper Text Transfer Protocol ：超文本传输协议 特点： 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型：一次请求对应一次响应 无状态：每次请求之间相互独立，不能交互数据 历史版本 1.0 ：每次请求都会建立新的连接 1.1 ：可以复用连接 请求消息数据格式 请求行 格式：请求方式 请求url 请求协议/版本 请求方式：共7种 GET 请求参数在请求行中，（在url后） 请求的url长度有限制 安全性低 POST 请求参数在请求体中。 请求的url长度没有限制 相对安全 请求头 客户端浏览器告诉服务器的一些信息 格式：请求头名称 : 请求头值1,请求头值2... 常见请求头： User-Agent：浏览器版本信息，可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 请求空行 空行：用于分割POST请求的请求头和请求体 请求体（正文） 封装POST请求消息的请求参数 响应消息数据格式 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码：服务器高速客户端浏览器本次请求和响应的一个状态 1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码 2xx：成功。200 3xx：重定向。 302：重定向 304：访问缓存 4xx：客户端错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXXX方法 5xx：服务器错误。500(服务器内部异常) 响应头 格式：头名称:值 常见的响应头： Content-Type：服务器高速客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么样的格式打开响应体数据 in-line：默认值，在当前页眉内打开 attachment;filename=xxx：以附件形式打开响应体。（文件下载） 响应空行：分隔响应头和响应体 响应体：传输的数据]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2020%2F02%2F27%2FServlet%2F</url>
    <content type="text"><![CDATA[TomcatWeb服务器软件 Web服务器软件：接收用户的请求，处理请求，做出响应。web容器，部署web项目。 常见的web服务器： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 Java SE：Java Standard Edition，Java 标准版。是Java技术的核心和基础，是Java ME和Java EE编程的基础。 Java EE：Java Platform Enterprise Edition企业级应用程序版本。Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Java ME：Java Platform Micro Edition，是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。 Tomcat 目录结构 bin：可执行文件 conf：配置文件 libs：依赖jar包 logs：日志文件 temp：临时文件 webapps：存放web项目 work：存放运行时的数据 可能遇到的问题 黑窗一闪而过 原因：没有正确配置JAVA_HOME环境变量 启动报错 端口被占用：找到占用的端口号，杀死该进程，或修改自身端口号(查看进程和端口号netstat -ano) 修改端口号：conf/server.xml 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端号。在访问时，就不用输入端口号 关闭 正常关闭 bin/shutdown.bat ctrl+c 强制关闭 关闭窗口 部署 简单部署：将项目打成一个war包，再将war包放置到webapps目录下。（war包会自动解压缩） 配置conf/server.xml文件 1234在&lt;Host&gt;标签体中配置&lt;Context docBase="D:\xxx" path="/xxx" /&gt;// docBase:项目存放的路径// path：虚拟目录 热部署：在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 12&lt;Context docBase="D:\xxx" /&gt;* 虚拟目录：xml文件的名称 Servlet Server Applet：运行再服务器端的小程序概念 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet就是一个接口，定义了Java类被浏览器访问到（tomcat识别）的规则 需要自定义一个类，实现Servlet接口，复写方法。 快速入门 创建JavaEE项目 定义一个类，实现Servlet接口 public class 类名 implements Servlet 实现接口中的抽象方法 init：创建 ServletConfig：获取Servlet配置对象 service：提供服务 getServletInfo：获取Servlet信息 destroy：销毁 配置Servlet 123456789101112&lt;!--配置Servlet--&gt;&lt;servlet&gt;&lt;servlet-name&gt;demo&lt;/servlet-name&gt;&lt;servlet-class&gt;com.nogizaka.servlet.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--配置映射路径--&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo&lt;/servlet-name&gt;&lt;url-pattern&gt;/demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则在找到对应的&lt;servlet-class&gt;全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet生命周期创建 init方法，只执行一次 默认情况：第一次被访问时，Servlet被创建 配置执行创建时机： 在&lt;servlet&gt;标签下配置&lt;load-on-startup&gt; 负数：第一次被访问时创建 0或正整数：服务器启动时创建 注意：Servlet的iniy方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 多个用户同时访问时，可能存在线程安全问题 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要修改值。 提供服务 提供服务：执行service方法，执行多次 每次访问Servlet时，service方法都会被调用一次 销毁 销毁：destroy方法，只执行一次 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 Servlet3.0 支持注解配置，无需web.xml 步骤 创建JavaEE项目。选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(urlPatterns = &quot;资源路径&quot;) @WebServlet 12345678910111213141516171819202122232425@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)b@Documentedpublic @interface WebServlet &#123; String name() default "";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default ""; String largeIcon() default ""; String description() default ""; String displayName() default "";&#125; IDEA与tomcat的相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE 工作空间项目和tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目”(out文件夹)，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 Servlet体系结构12345Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法 Servlet相关配置 urlPattern：Servlet访问路径 一个Servlet可以定义多个访问路径 ：@WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 路径定义规则： /xxx：路径匹配 /xxx/xxx:多层路径，目录结构 *.do：扩展名匹配 Request &amp; Response request对象和response对象的原理 request和response对象是由服务器创建的 request对象是来获取请求消息，response对象是来设置响应消息 Requestrequest对象继承体系结构12345ServletRequest -- 接口 | 继承HttpServletRequest -- 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) request功能 获取请求消息数据 获取请求行数据 获取当前请求方式：String getMethod() 获取当前虚拟目录：String getContextPath() 获取Servlet路径：String getServletPath() 获取get方式请求参数：String getQueryString() 获取请求URI： String getRequestURI()：URI：统一资源标识符 StringBuffer getRequestURL()：URL:统一资源定位符 获取协议及版本：String getProtocol() 获取客户机的IP地址：String getRemoteAddr() 获取请求头数据 String getHeader(String name)：通过请求头的名称获取请求头的值 Enumeration&lt;String&gt; getHeaderNames()：获取所有的请求头名称 获取请求体数据 请求体：只有POST请求方式才有，请求体中封装了POST请求的请求参数 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 其他功能 获取请求参数通用方法 String getParameter(String name)：根据参数名称获取参数值 String[] getParameterValues(String name)：根据参数名称获取参数值的数组 Enumeration&lt;String&gt; getParameterNames()：获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap()：获取所有参数的map集合 中文乱码问题： get方式：tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 解决：在获取参数前，设置request的编码 request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发 一种在服务器内部的资源跳转方式 步骤 通过request对象获取请求转发器对象， RequestDispatcher getRequestDispatcher(String path) 使用RequestDistpatcher对象来进行转发： forward(ServletRequest request,ServletRespons response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj)：存储数据 Object getAttribute(String name)：通过键 获取 值 void removeAttribute(String name)：通过键 移除 键值对 获取ServletContext ServletContext getServletContext() 用户登录步骤 创建项目，导入html页面，配置文件，jar包 创建数据库 创建包domain,创建类User domain 存放 javabean 创建包util,编写工具类JDBCUtils JDBC工具类： 获取连接池DataSource对象 获取数据库连接Connection对象 创建包dao,创建类UserDao,提高login方法 dao：datasource access object，数据库连接对象 dao：处理所有的数据库相关操作 单元测试，数据库是否正常连接 创建web.servlet包，实现LoginServlet类 注意 html中的form表单中的action属性：虚拟目录+Servlet的资源路径 BeanUtils工具类 导包:commons-beanutils-1.8.0.jar 用于封装JavaBean JavaBean: 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 JavaBean中的属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（一般和成员方法名相同） 常用方法： setProperty(Object bean, String name, Object value)：设置属性 getProperty(Object bean, String name)：获取属性 populate(Object bean, Map&lt;String,? extends Object&gt; properties)：将map集合的键值对信息，封装到对应的JavaBean对象中 Response 功能：设置响应消息 设置响应行 格式：HTTP/1.1 200 OK 设置状态码：setStatus(int sc) 设置响应头 setHeader(String name,String value) 设置响应体 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流：将数据输出到客户端浏览器 重定向 资源的跳转 1234// 设置状态码为302response.setStatus(302);// 设置响应头locationresponse.setHeader("location","/JavaEE_Response/responseDemo2"); 方法：sendRedirect(&quot;/虚拟目录/资源路径&quot;) 特点： ||地址栏|服务器|请求| |—|—|—|—| |转发Forward|地址栏路径不变|只能访问当前服务器下的资源|一次请求可以使用request对象共享数据| |重定向Redirect|地址栏发送变化|可以访问其他站点(服务器)资源|两次请求不可以使用request对象共享数据| 路径写法相对路径 通过相对路径不可以确定唯一资源 不以/开头，以.开头 规则：找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../:后退一级目录 绝对路径 通过绝对路径可以确定唯一资源 以/开头 规则：判断定义的路径是给谁用 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取：request.getContextPath() &lt;a&gt;,&lt;form&gt;,重定向 给服务器使用：不需要加虚拟目录() 转发路径 服务器输出字符数据到浏览器 步骤： 获取字符输出流 输出数据 12345// 获取字符输出流PrintWriter pw = response.getWriter();// 输出数据pw.write("&lt;h1&gt;hello response&lt;/h1&gt;&lt;br&gt;"); 中文乱码 浏览器：与操作系统有关，windows GBK PrintWriter pw = response.getWriter();：获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码(设置响应头content-type) 1234// 设置响应头response.setHeader("content-type","text/html;charset=utf-8");//或者使用简单的形式，设置编码，是在获取流之前设置response.setContentType("text/html;charset=utf-8"); ServletContext对象 概念：代表整个web应用，可以和程序的容器(服务器)进行通信 获取： 通过request对象获取：request.getServletContext(); 通过HttpServlet获取：this.getServletContext(); 功能： 获取MIME类型 MIME：在互联网通信过程中定义的一种文件数据类型 格式：大类型/小类型 text/html image/jpeg 获取方法：String getMimeType(String file) 域对象：共享数据 ServletContext对象范围：所有用户所有请求的数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) 3. 获取文件的真实(服务器)路径 - 方法：`String getRealPath(String path)` 文件下载 步骤： 获取下载文件名：request.getParameter() 将资源按字节输入流读入内存 找到资源在服务器内的路径：ServletContext对象getRealPath方法 读入字节输入流：创建FileInputStream对象，传递路径 设置response响应头 获取文件类型：ServletContext对象的getMimeType() 设置响应头类型：content-type 设置响应头打开方式：content-disposition 将输入流数据 写出到 response输出流 获取输出流对象：response.getOutputStream() 设置缓冲区：byte[] buff = new byte[1024*4]; 输出数据：write方法 关闭缓冲区：close方法 12345678910111213141516171819202122232425// 获取文件名称String filename = request.getParameter("filename");// 使用字节输入流加载进入内存 // 找到文件的服务器路径ServletContext context = this.getServletContext();String realPath = context.getRealPath("/img/" + filename); // 字节流关联FileInputStream fis = new FileInputStream(realPath);// 指定response的响应头// 设置响应头类型：content-typeString mimeType = context.getMimeType(filename);response.setHeader("content-type",mimeType);// 设置想要头打开方式：content-dispositionresponse.setHeader("content-disposition","attachmemt;filename="+filename);// 将输入流数据写出到response输出流ServletOutputStream sos = response.getOutputStream();byte[] buff=new byte[1024*8];// 缓冲区int len=0;while((len=fis.read(buff))!=-1)&#123; sos.write(buff,0,len);&#125;fis.close(); 中文乱码 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同]]></content>
      <tags>
        <tag>tomcat</tag>
        <tag>Servlet</tag>
        <tag>request</tag>
        <tag>response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些异常]]></title>
    <url>%2F2020%2F02%2F26%2F%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常NoClassDefFoundError Caused by: java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException 原因：找不到DataAccessException类，可能是jar包导入异常 解决方案：查看依赖jar包是否配置在WEB-INF下的lib文件夹中（不是libs）或者是否缺少相关jar包]]></content>
      <tags>
        <tag>Exception</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2020%2F02%2F21%2FXML%2F</url>
    <content type="text"><![CDATA[XML概念 Extensible Markup Language 可扩展标记语言 可扩展：标签都是自定义的 功能：存储数据 配置文件 在网络中传输 xml与html的区别 xml标签都是自定义的,html标签都是预定义的 xml的语法严格，html语法比较松 xml是存储数据的，html是展示数据的 语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭(围堵标签、自闭合标签) xml标签名称区分大小写 123456789101112131415&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分 文档声明 格式：&lt;?xml 属性列表?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值ISO-8859-1 standalone：是否独立（yes/no） 指令：结合css&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 标签：标签名称自定义 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性：id属性值唯一 文本：CDATA区：在该区域中的数据会被原样展示 格式：&lt;![CDATA[ 数据 ]]&gt; 约束 规定xml文档的书写规则 作为框架的使用者 能够在xml中引入约束文档 能够简单的读懂约束文档 分类 DTD:一种简单的约束技术 Schema:一种复杂的约束技术 DTD 引入dtd文档到xml文档中 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema XML Schema语言也称作XML Schema定义（XML Schema Definition，XSD） XML Namespace(xmlns)属性: 格式：xmlns:namespace-prefix=&quot;namespaceURI&quot; 引入 填写xml文档的根元素 引入xsi前缀。 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间。 xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀，作为标识。 xmlns=&quot;http://www.itcast.cn/xml&quot; 解析 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：soup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup 步骤 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 1234567891011/*获取Document对象*//*获取student.xml的path*/String path = JsoupDemo.class.getClassLoader().getResource("student.xml").getPath();// 解析xml文档，加载文档进内存，获取dom树Document document = Jsoup.parse(new File(path),"utf-8");// 获取元素对象 ElementElements elements = document.getElementsByTag("name");//System.out.println(element.size());for (Element element : elements) &#123; System.out.println(element.text());&#125; 对象的使用 Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 Element：元素对象 获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取所有子标签的纯文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象，是Document和Element的父类 快捷查询方式 selector：选择器 使用的方法：Elements select​(String cssQuery) XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询]]></content>
      <tags>
        <tag>XML</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap]]></title>
    <url>%2F2020%2F02%2F21%2FBootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap概念 一个前端开发的框架，Bootstrap，基于HTML、CSS、JavaScript。 框架：一个半成品软件，开发人员可以在框架基础上，再进行开发，简化编码。 优点： 定义了很多的CSS样式和JS插件。我们开发人员直接可以使用这些样式和插件得到了丰富的页面效果。 响应式布局：同一套页面可以兼容不同分辨率的设备 快速入门 下载Bootstrap 导入资源文件 创建html，引入相关资源文件 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;!--&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;--&gt; &lt;link href="../css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="../js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局 同一套页面可以兼容不同分辨率的设备 实现：依赖于栅格系统。将一行平均分为12个格子，可以指定元素占几格 步骤 定义容器 container：固定宽度 container-fluid：100% 宽度 定义行 row 定义元素。指定该元素在不同的设备上，所占的格子数目。 col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px)：col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 12345678910111213141516171819&lt;!--1. 定义容器--&gt;&lt;div class="container-fluid"&gt; &lt;!--2. 定义行--&gt; &lt;div class="row"&gt; &lt;!--3. 定义元素。指定该元素在不同的设备上，所占的格子数目。--&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-3"&gt;栅格&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS样式和JS插件 全局CSS样式 按钮：class=&quot;btn btn-default&quot; 图片：class=&quot;img-responsive&quot;，图片在任意尺寸都占100% 方形： &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt; 圆形： &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; 相框： &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; 表格 table class=&quot;table table-bordered&quot;：带边框的表格 class=&quot;table table-hover&quot;：鼠标悬停 class=&quot;table table-striped&quot;：条纹状表格 表单 class=&quot;form-control&quot; 组件 导航条 分页条 插件 轮播图:Carousel]]></content>
      <tags>
        <tag>Bootstrap</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端]]></title>
    <url>%2F2020%2F02%2F20%2FWeb%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Web前端B/S架构 静态资源 使用静态网页开发技术发布的资源 特点： 所有用户访问，得到的结果是一样的 如：文本、图片、音频、视频，HTML、CSS、Javascript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器，浏览器内置了静态资源的解析引擎，可以展示静态资源 动态资源 使用动态网页即时发布的资源 特点： 所有用户访问，得到的结果可能不一样 如：jsp/servlet、php、asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 HTML概念 Hyper Text Markup Language 超文本标记语言 超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织再一起的网状文本。 标记语言：由标签构成的语言，标记语言不是编程语言 基础语法 html文档后缀：.html或.htm 标签分类 围堵标签：有开始标签和结束标签，如&lt;html&gt;&lt;/html&gt; 自闭合标签：开始标签和结束标签在一起，如&lt;br/&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号引起来（单引双引都可） html的表情不区分大小写，建议使用小写。 常用标签 文件标签 &lt;html&gt;&lt;/html&gt;：html文档的根标签 &lt;head&gt;&lt;/head&gt;：头标签，用于指定html文档的一些属性。引入外部资源 &lt;title&gt;&lt;/title&gt;：标题标签 &lt;body&gt;&lt;/body&gt;：体标签 &lt;!DOCTYPE html&gt;：定义文档类型，html5中定义该文档是html文档 &lt;meta charset=&quot;UTF-8&quot;&gt;：指定字符集 文本标签 注释：&lt;!-- 注释内容 --&gt; &lt;h1&gt;to&lt;h6&gt;：标题标签（h1~h6字体大小逐渐递减） &lt;p&gt;&lt;/p&gt;：段落标签 &lt;br/&gt;：换行标签 &lt;hr&gt;：展示一条水平线 属性： color：颜色 width：宽度 size：高度 align：对齐方式（center/left/right） &lt;b&gt;&lt;/b&gt;：字体加粗 &lt;i&gt;&lt;/i&gt;：字体斜体 &lt;font&gt;&lt;/font&gt;：字体标签 &lt;center&gt;：文本居中,相对于父元素 属性： color：颜色 size：大小 face：字体 属性定义 color： 英文单词 rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) #值1值2值3：值的范围：00~FF之间。如： #FF00FF width： 数值，单位默认px像素 数值%：占比相对于父元素的比例 &gt; 特殊字符表：空格：`&amp;nbsp;` 图片标签 &lt;img/&gt;：展示图片 属性： src：指定图片的位置 alt：规定在图像无法显示时的替代文本 &lt;img src=&quot;图片地址&quot; alt=&quot;图片名称&quot;&gt; 相对路径：以.开头的路径 ./：代表当前目录 ../：代表上一级目录 列表标签 有序列表 &lt;ol&gt;:定义有序列表。 &lt;li&gt;:定义列表的项目。 无序列表 &lt;ul&gt;:定义无序列表。 &lt;li&gt;:定义列表的项目。 链接标签 &lt;a&gt;:定义一个超链接 属性： href:指定访问资源的url(统一资源定位符) target:指定打开资源的方式 _self:默认值，在当前页面打开 _blank:在空白页打开 样式/节 &lt;div&gt;&lt;/div&gt;:可以把文档分割为独立的、不同的部分。每一个div占满一整行。块级标签 &lt;span&gt;&lt;/span&gt;:用来组合文档中的行内元素。文本信息在一行展示，行内标签 内联标签 &lt;header&gt;&lt;/header&gt;:定义文档的页眉（介绍信息）。 &lt;footer&gt;&lt;/footer&gt;:定义文档或节的页脚。 表格标签 &lt;table&gt;&lt;/table&gt; width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 &lt;tr&gt;&lt;/tr&gt;：定义行 bgcolor：背景色 align：对齐方式 &lt;td&gt;&lt;/td&gt;：定义单元格 colspan：合并列 rowspan：合并行 &lt;th&gt;&lt;/th&gt;：定义表头单元格 &lt;caption&gt;&lt;/caption&gt;：表格标题 &lt;thead&gt;&lt;/thead&gt;：表示表格的头部分 &lt;tbody&gt;&lt;/tbody&gt;：表示表格的体部分 &lt;tfoot&gt;&lt;/tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据。用于和服务器进行交互。 &lt;form&gt;：用于定义表单，可以定义一个范围，范围内代表采集用户数据的范围 属性： action；指定提交数据的URL method：指定提交方式（一共7种，常用2种） get 请求参数会在地址栏显示。数据被封装到请求行中 请求参数大小有限制 不太安全 post 请求参数不会显示在地址栏。数据被封装到请求体中 请求参数大小没有限制 比较安全 表单项中的数据想要被提交，必须指定其name属性 表单项标签 input：可以勇敢type属性值，改变元素展示的样式 type属性： text：文本输入框，默认值 password：密码输入框 radio：单选框 要想多个单选框实现单选的效果，则多个单选框的name属性必须一样 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性：可以指定默认值cheecked=&quot;checked&quot;，可以简写checked checkbox：复选框 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性：可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息 按钮： submit：提交按钮，可以提交表单 button：普通按钮 image：图片提交按钮（src属性指定图片的路径） date：定义 date 控件（包括年、月、日，不包括时间）。 email：定义用于 e-mail 地址的字段。 color：定义拾色器 number：定义用于输入数字的字段。 placeholder：指定输入框的提示信息，当输入框的内容发生改变，会自动清空提示信息 select：下拉列表 子元素：option，指定列表项 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行。 - `label`：指定输入项的文字描述信息 - label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。`&lt;label for=&quot;username&quot;&gt;&lt;/label&gt;` CSS 概念：Cascading Style Sheets 层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 优点： 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 使用 内联样式 在标签内使用style属性指定css代码 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 如1234567&lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt;&lt;div&gt;hello css&lt;/div&gt; 外部样式 定义css资源文件 在head标签内，定义link标签，引入外部的资源文件 1234567&lt;!-- a.css:div&#123; color:green;&#125; --&gt;&lt;link rel="stylesheet" href="css/a.css"&gt;&lt;div&gt;hello css&lt;/div&gt;&lt;div&gt;hello css&lt;/div&gt; 注意： 三种方式，css作用域越来越大 3种格式可以写为： 123&lt;style&gt; @import "css/a.css";&lt;/style&gt; 语法 格式： 12345选择器&#123; 属性名1:属性值1; 属性名2:属性值2; ...&#125; 注意：每一对属性需要使用分号;隔开，最后一对属性可以不加 选择器 选择器：筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素，建议在一个html页面中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法：标签名称{} 注意：id选择器优先级高于元素选择器 类选择器：选择具有相同class属性值的元素 语法：.class属性值{} 注意：类选择器优先级高于元素选择器 扩展选择器 选择所有元素 语法：*{} 并集选择器 语法：选择器1,选择器2{} 子选择器：筛选选择器1元素下的选择器2元素 语法：选择器1 选择器2{} 父选择器：筛选选择器2的父选择器1 语法：选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名=属性值的元素 语法：元素名称[属性名=&quot;属性值&quot;]{} 伪类选择器：选择一些元素具有的状态 语法：元素:状态{} 如： &lt;a&gt;标签 link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 属性 字体 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background:background: url(&quot;图片地址&quot;) no-repeat right top; 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right Javascript 概念：客户端脚本语言 运行再客户端浏览器中，每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行 功能：可以增强用户和html页面的交互过程，可以来控制html元素，让页面增加动态效果，增强用户体验 JavaScript的发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。 1995年，NetScape公司，开发了一门客户端脚本语言：LiveScript。后来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软模仿JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式 JavaScript = ECMAScript + JavaScript特有东西(DOM+BOM) ECMAScript：客户端脚本语言标准基本语法 与html结合方式 内部JS：定义&lt;script&gt;，标签体内容就是js代码 外部JS：定义&lt;script&gt;，通过src属性引入外部的js文件 注意： &lt;script&gt;可以定义在html页面的任何地方。但定义的位置会影响执行顺序 &lt;script&gt;可以定义多个 注释 单行注释：//注释内容 多行注释：/*注释内容*/ 数据类型 基本数据类型 number：数字。整数/小数/NaN（not a number一个不是数字的数字类型） string：字符串。 boolean：true/false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 引用数据类型 对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据 语法: var 变量名 = 初始化值; typeof运算符：获取变量的类型。(null运算后得到Object类型) 运算符 一元运算符：只有一个运算数的运算符 ++，-- ， +(正号) 在JS中，如果运算数不是运算符所要求的类型，那么JS引擎会自动地将运算数进行类型转换。 String转number:按照字面值转换，如果字面值不是数字，则转为NaN 算数运算符 + - * / % ... 赋值运算符 = += -+.... 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) 比较方式 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止 类型不同：先进行类型转换，再比较(“123”==123) ===全等于 在比较之前，先判断类型，如果类型不一致，则直接会返回false 逻辑运算符 &amp;&amp; || ! 其他类型转boolean number：0或NaN为false，其他为true string：除了空字符串，其他都是true null/undefined：false 对象：所有对象都为true 三元运算符 表达式? 值1:值2; 判断表达式的值，如果是true则取值1，如果是false则取值2 流程控制语句 if…else… switch 在Java中，switch语句可以接受地数据类型：byte int shor char,枚举(jdk1.5) ,String(jdk1.7) 在JS中,switch语句可以接受任意的原始数据类型 while do…while for JS特殊语法 语句以分号;结尾，如果一行只有一条语句，分号可以省略 变量地定义使用var关键字，也可以不使用 使用：定义的变量是局部变量 不使用：定义的变量是全局变量（不建议） 基本对象 Function函数(方法)对象 创建： 12345678// 常用function 方法名称(形参列表)&#123; 方法体&#125;// 常用2var 方法名 = function(形参列表)&#123; 方法体&#125; 属性： length:返回形参的个数 特点： 方法定义是，形参的类型不用写，返回值类型也不用写 方法是一个对象，如果定义名称相同的方法，会覆盖 JS中，方法的调用只与方法的名称有关，和参数列表无关(无法重载，可以通过arguments.length进行模拟重载) 在方法声明中有一个隐藏的内置对象（数组），arguments封装所有的实际参数 调用：方法名称(实际参数列表); Array数组对象 创建 123456// 1var arr = new Array(元素列表);// 2var arr = new Array(默认长度);// 3var arr = [元素列表]; 方法 join(分隔符)：将数组中的元素按照指定的分隔符拼接为字符串 push()：项数组的末尾添加一个或更多元素，并返回新的长度 属性 length：数组的长度 特点 在JS中，数组元素的类型是可变的 在JS中，数组的长度是可变的 Boolean Date日期对象 创建： 1var date = new Date(); 方法： toLocaleString()；返回当前date对象对应的时间本地字符串格式 getTime()：获取毫秒值。返回当前日期对象描述的时间到1970年1月1日0点的毫秒值差 Math对象 创建：Math对象不用创建，直接使用。Math.方法名(); 方法 random()：返回 0 ~ 1 之间的随机数。 含0不含1 ceil()：对数进行上舍入。 floor()：对数进行下舍入。 round()：把数四舍五入为最接近的整数。 属性 PI Number String RegExp正则表达式对象 正则表达式：定义字符串的组成规则 单个字符：[] 如：[a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符: \d:单个数字字符 [0-9] \w:单个单词字符[a-zA-Z0-9_] 量词符号 ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n m如果缺省： {,n}:最多n次 n如果缺省：{m,} 最少m次 开始结束符号 ^:开始$:结束 正则对象 创建 12345var reg = new RegExp("正则表达式")//引号里面的字符串需要转义符\var reg = /正则表达式/;//egvar reg1 = new RegExp("^\\w&#123;6,12&#125;$");var reg2 = /^\w&#123;6,12&#125;$/; 方法 test(参数)：验证指定的字符串是否符合正则定义的规范 Global全局对象 特点：Global中封装的方法不需要对象就可以直接调用。方法名(); 方法： encodeURI()：url编码 decodeURI()：url解码 12345var str1 = "乃木坂";var encode = encodeURI(str1);//编码document.write(encode+'&lt;br&gt;');//%E4%B9%83%E6%9C%A8%E5%9D%82var str2 = decodeURI(encode)//解码document.write(str2+'&lt;br&gt;'); - `encodeURIComponent()`：url编码,编码的字符更多 - `decodeURIComponent()`：url解码 - `parseInt()`：将字符串转为数字 &gt; 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number - `isNaN()`：判断一个值是否是NaN &gt; NaN六亲不认，连自己都不认。NaN参与的==比较全部问false - `eval()`：将JavaScript 字符串，并把它作为脚本代码来执行。 BOM 概念：Browser Object Model 浏览器对象模型。将浏览器的各个组成部分封装成对象 组成： Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Window窗口对象 创建 方法 与弹出框有关的方法 alert()：显示带有一段消息和一个确认按钮的警告框。 confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。 确定：返回true 取消：返回false prompt()：显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法 close()：关闭浏览器窗口。谁调用，谁被关闭 open()：打开一个新的浏览器窗口。返回新的Window对象 与定时器有关的方法 setTimeout(方法对象,毫秒值)：在指定的毫秒数后调用函数或计算表达式 参数：js代码或者方法对象，毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout(id)：取消由setTimeout()方法设置的timeout setInterval(方法对象,毫秒值)：按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval(id)：取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象 history location Navigator Screen 获取DOM对象 documet:window.document可简写document 特点 Window对象不需要创建可以直接使用。window.方法名() window引用可以省略。方法名() Location地址栏对象 创建 window.location location 方法 reload()：重新加载当前文档。刷新 属性 href：设置或返回完整的 URL。 History历史记录对象 创建 window.history history 方法 back()：加载 history 列表中的前一个 URL。 forward()：加载 history 列表中的下一个 URL。 go(参数)：加载 history 列表中的某个具体页面。 正数：前进几个历史记录 负数：后退几个历史记录 属性 length：返回当前窗口历史列表中的 URL 数量。 DOM 概念：Document Object Model文档对象模型。将标记语言文档的各个组成部分，封装成对象，可以使用这些对象，对标记语言文档进行CRUD动态操作（文档-&gt;dom树） 功能：控制html文档的内容 W3C DOM标准被分为3个不同的部分 核心DOM：正对任何结构化文档的标准模型 Document：文档对象 ElementL：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，上述5个对象的父对象 XML DOM：针对XML文档的标准模型 HTML DOM：针对HTML文档的标准模型 核心DOM Document：文档对象 创建(获取)：在html DOM模型中可以使用window对象来获取 window.document document 方法 获取Element对象 getElementById()：根据id属性值获取元素对象。id属性值一般唯一。 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName()：根据class属性值获取元素对象们。返回值是一个数组。 getElementsByName()：根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象 createAttribute(name) createComment() createElement() createTextNode() 属性 Element：元素对象 获取：通过document对象来获取 window.document.getElementById() document.getElementById() 方法 removeAttribute()：删除属性 setAttribute()：设置属性 123456789101112131415161718&lt;a&gt;点我进入百度&lt;/a&gt;&lt;input type="button" id="btn1" value="快点我一下"&gt;&lt;input type="button" id="btn2" value="点我删除"&gt;&lt;script&gt; /*设置Element对象属性*/ var btn1 = document.getElementById("btn1"); btn1.onclick = function()&#123; var ele_a = document.getElementsByTagName("a")[0]; ele_a.setAttribute("href","https://www.baidu.com"); &#125; /*删除Element对象属性*/ var btn2 = document.getElementById("btn2"); btn2.onclick = function()&#123; var ele_a = document.getElementsByTagName("a")[0]; ele_a.removeAttribute("href"); &#125;&lt;/script&gt; Node：节点对象，其他5个对象的父对象 特点：所有DOM对象都可以被认为是一个节点 方法： CRUD DOM树 appendChild()：向节点的子节点列表的结尾添加新的子节点 removeChild()：删除（并返回）当前节点的指定子节点 replaceChild()：用新节点替换一个子节点 属性 parantNode：返回节点的父亲节点 12345678910111213141516&lt;script&gt; /*删除子节点*/var ele_a = document.getElementById("del");ele_a.onclick = function()&#123; var div1 = document.getElementById("div1"); div1.removeChild(div2);&#125;;/*添加子节点*/var div3 = document.createElement("div");div3.setAttribute("id","div3");var ele_b = document.getElementById("add");ele_b.onclick = function()&#123; var div1 = document.getElementById("div1"); div1.append(div3);&#125;&lt;/script&gt; HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 12345//修改样式方式1div1.style.border = "1px solid red";div1.style.width = "200px";//font-size--&gt; fontSizediv1.style.fontSize = "20px"; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值 事件监听机制 概念：某些组件被执行了某些操作后，会触发某些代码的执行 事件：某些操作。如：单击、双击 事件源：组件。如：按钮、文本输入框 监听器：代码 注册监听：将事件、事件源、监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。 常见事件： 点击事件 onclick：单击事件 ondbclick：双击事件 焦点事件 onblur：失去焦点 onfocus：元素获得焦点 加载事件 onload：一张页面或一幅图像完成加载 鼠标事件 onmousedown：鼠标按键被按下 onmouseup：鼠标按键被松开 onmousemove：鼠标被移动 onmouseover：鼠标移到某元素之上 onmouseout：鼠标从某元素移开 键盘事件 onkeydown：某个键盘按键被按下 onkeyup：某个键盘按键被松开 onkeypress：某个键盘按键被按下并松开 选择和改变 onchange：域的内容被改变 onselect：文本被选中 表单事件 onsubmit：提交按钮被点击(可以阻止表单的提交。方法返回false则表单被阻止提交) onreset：重置按钮被点击 绑定事件： 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 onclick：单击事件 通过js获取元素对象，指定事件属性，设置一个函数]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签对应全称]]></title>
    <url>%2F2020%2F02%2F15%2FHTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%AF%B9%E5%BA%94%E5%85%A8%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[常用HTML标签的英文全称及简单描述 HTML标签 英文全称 中文释义 a Anchor 锚(定义超链接，用于从一张页面链接到另一张页面) abbr Abbreviation 缩写词 acronym Acronym 取首字母的缩写词 address Address 地址 alt alter 替用(一般是图片显示不出的提示) b Bold 粗体（文本） bdo Direction of Text Display 文本显示方向 big Big 变大（文本） blockquote Block Quotation 区块引用语 br Break 换行 cell cell 巢 cellpadding cellpadding 巢补白 cellspacing cellspacing 巢空间 center Centered 居中（文本） cite Citation 引用 code Code 源代码（文本） dd Definition Description 定义描述 del Deleted 删除（的文本） dfn Defines a Definition Term 定义定义条目 div Division 分隔 dl Definition List 定义列表 dt Definition Term 定义术语 em Emphasized 加重（文本） font Font 字体 h1~h6 Header 1 to Header 6 标题1到标题6 hr Horizontal Rule 水平尺 href hypertext reference 超文本引用 i Italic 斜体（文本） iframe Inline frame 定义内联框架 ins Inserted 插入（的文本） kbd Keyboard 键盘（文本） li List Item 列表项目 nl navigation lists 导航列表 ol Ordered List 排序列表 optgroup Option group 定义选项组 p Paragraph 段落 pre Preformatted 预定义格式（文本 ） q Quotation 引用语 rel Reload 加载 radio radiobox 单选框 s/ strike Strikethrough 删除线 samp Sample 示例（文本） small Small 变小（文本） span Span 范围 src Source 源文件链接 strong Strong 加重（文本） sub Subscripted 下标（文本） sup Superscripted 上标（文本） td table data cell 表格中的一个单元格 th table header cell 表格中的表头 tr table row 表格中的一行 tt Teletype 打印机（文本） u Underlined 下划线（文本） ul Unordered List 不排序列表 var Variable 变量（文本）]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2020%2F02%2F15%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概念 Java DataBase Connectivity(Java数据库连接)：Java语言操作数据库 本质：其实是官方（SUN公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动和jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码时驱动jar包中的实现类。 步骤 导入驱动jar包 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 注册驱动 DriverManager 获取数据库连接对象 Connection 定义SQL 获取执行SQL语句的对象 Statement 执行SQL，接收返回结果 处理结果 释放资源 对象 DriverManager：驱动管理对象 Connection：数据库连接对象 Statement：执行SQL的对象 ResultSet：结果集对象 PreparedStatement：执行SQL的对象 DriverManager驱动管理对象 注册驱动：告诉程序该使用哪一个数据库驱动jar 方法：static void registerDriver(Driver driver):注册与给定的驱动程序DriverManager 写代码时使用：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 12345678// 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125;&#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤 获取数据库连接（DriverManager） 方法：static Connection getConnection(String url,String user,String password) 参数： url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 Connection数据库连接对象 功能： 获取执行SQL的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：void setAutoCommit(boolean autoCommit):调用改方法设置参数为false。即开启事务 提交事务：void commit() 回滚事务：void rollback() Statement执行静态SQL的对象 执行SQL boolean execute(String sql):可以执行任意的sql int executeUpdate(String sql):执行DML(insert、update、delete)语句，DDL(create、alter、drop)语句 返回值：影响的行数。可以通过这个影响的行数判断DML语句是否执行成功，返回值&gt;0则执行成功。 ResultSet executeQuery(String sql):执行DQL(select)语句 样例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JdbcDemo01 &#123; public static void main(String[] args) &#123; // 导入驱动 Connection conn = null; Statement smt = null; try &#123; // 静态SQL语句 String s1 = "insert into emp values ()"; String s2 = "delete from emp where salary&gt;8000"; String s3 = "update emp set gender='女' where name='jdbc'"; // 注册驱动 Class.forName("com.mysql.jdbc.Driver"); // 获取数据库连接对象Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/demo", "root", "root"); // 获取Statement对象 smt = conn.createStatement(); // 执行sql语句 int r1 = smt.executeUpdate(s1); int r2 = smt.executeUpdate(s2); int r3 = smt.executeUpdate(s3); System.out.println(r1); System.out.println(r2); System.out.println(r3); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源 // 避免空指针异常 if (smt != null) &#123; try &#123; smt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; ResultSet结果集对象 封装查询结果 boolean next()：游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据）。如果是，则返回false，如果不是返回true； XXX getXXX(参数)：获取一列数据 XXX：代表数据类型， 如：int getInt() 参数： int：代表列的编号，如： getString(1) String：代表列名称，如： getString(“name”) 使用步骤： 游标向下移动一行 判断是否有数据 获取数据1234ResultSet resultSet = smt.executeQuery(s1);while(resultSet.next())&#123; System.out.println(resultSet.getString("name"));&#125; PreparedStatement执行SQL语句的对象 SQL注入问题：在拼接SQL时，有一些SQL的特殊关键字参与字符串的拼接，会造成安全性问题 输入用户随便，输入密码：a’ or ‘a’ = ‘a’ sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 解决方案：使用PreparedStatement对象 预编译的SQL：参数使用？作为占位符 使用步骤： 导入驱动jar包 注册驱动 获取数据库连接对象Connection 定义SQL sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行SQL语句的对象PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法：setXXX(参数1，参数2) 参数1：?的位置编号，从1开始 参数2：?的值 执行SQL：接受返回值结果，不需要传递SQL语句 处理结果 释放资源 注意：使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 语句中使用了占位符，规定了sql语句的结构。用户可以设置”?”的值，但是不能改变sql语句的结构，因此解决了SQL注入 JDBC工具类：JDBCUtils 目的：简化书写 分析： 注册驱动抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件jdbc.properties（文件的读取，只需要读取一次即可拿到这些值。使用静态代码块） 1234url=user=password=driver= 抽取一个方法释放资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.nogizaka.jdbc;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /* 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 * */ static &#123; // 读取资源文件 try &#123; // 1 创建Properties类 Properties prop = new Properties(); // 获取src路径下的文件的方式：ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource("jdbc.properties"); // 获取字符串路径 String path = res.getPath(); // 2 加载文件 prop.load(new FileReader(path)); // 3 获取数据 赋值 url = prop.getProperty("url"); user = prop.getProperty("user"); password = prop.getProperty("password"); driver = prop.getProperty("driver"); // 4 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // 获取数据库连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * * @param stmt * @param conn */ public static void close(Statement stmt, Connection conn) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(ResultSet res, Statement stmt, Connection conn) &#123; if (res != null) &#123; try &#123; res.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注意： properties文件放在src目录下 获取src路径下的文件的方式：ClassLoader 类加载器1234ClassLoader classLoader = JDBCUtils.class.getClassLoader();URL res = classLoader.getResource("jdbc.properties");// 获取字符串路径String path = res.getPath(); JDBC事务控制 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 数据库连接池 概念：其实就是一个容器（集合），存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象当用户来访问数据库时，从容器中获取连接对象，用户访问完以后，会将连接对象归还给容器。 好处：节约资源，提供访问效率 实现： 标准接口：javax.sql.DataSource 方法： 获取连接：getConnection() 归还连接：Connection.close() 如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接，而是归还连接 一般由数据库厂商实现 C3P0:数据库连接池技术 Druid:数据库连接池实现技术（阿里） C3P0 数据库连接池技术 步骤： 导入jar包 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 定义配置文件： 名称：c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建核心对象 数据率连接池对象 new ComboPooledDataSource() 获取连接：getConnection() 123456// 创建数据库连接池对象DataSource ds = new ComboPooledDataSource();// 获取连接对象,getConnection()可以传递配置名，不同配置效果不同，不传使用默认配置Connection conn = ds.getConnection();// 归还连接conn.close(); 配置文件：c3p0-config.xml1234567&lt;!-- 连接池参数 --&gt;&lt;!--初始化申请的连接数--&gt;&lt;property name="initialPoolSize"&gt;5&lt;/property&gt;&lt;!--最大连接数量--&gt;&lt;property name="maxPoolSize"&gt;10&lt;/property&gt;&lt;!--超时时间--&gt;&lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; Druid 数据库连接池实现技术 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件 Properties 可以放在任意目录下 加载配置文件 获取数据库连接池对象：通过工厂来获取 DruidDataSourceFactory.createDataSource() 获取连接：getConnection() 123456789101112// 定义配置文件// 加载配置文件Properties prop = new Properties();// 将properties文件转换为字节输入流InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");// 读取属性列表(键和元素对)从输入字节流。prop.load(is);// 获取连接池对象,通过工厂来获取，参数为配置文件DataSource ds = DruidDataSourceFactory.createDataSource(prop);// 获取连接Connection conn = ds.getConnection();System.out.println(conn); 定义工具类 定义一个类 JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC:JDBC Template Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 commons-logging-1.2.jar spring-beans-5.0.0.RELEASE.jar spring-core-5.0.0.RELEASE.jar spring-jdbc-5.0.0.RELEASE.jar spring-tx-5.0.0.RELEASE.jar 创建JdbcTemplate对象，依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update()：执行DML语句。增、删、改语句 queryForMap()：查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList()：查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query()：查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject()：查询结果，将结果封装为对象 一般用于聚合函数的查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* 需求：1. 修改1号数据的 salary 为 100002. 添加一条记录3. 删除刚才添加的记录4. 查询id为1的记录，将其封装为Map集合5. 查询所有记录，将其封装为List6. 查询所有记录，将其封装为Emp对象的List集合7. 查询总记录数*/public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = "update emp set salary = 10000 where id = 1001"; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; /** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = "insert into emp(id,ename,dept_id) values(?,?,?)"; int count = template.update(sql, 1015, "郭靖", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = "delete from emp where id = ?"; int count = template.update(sql, 1015); System.out.println(count); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = "select * from emp where id = ? or id = ?"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = "select * from emp"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = "select count(id) from emp"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2020%2F02%2F13%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL启动与关闭 MySQL服务启动： 手动 cmd–&gt; services.msc打开服务窗口 使用管理员打开cmd net start mysql：启动mysql服务 net stop mysql：关闭mysql服务 登录与退出 MySQL登录 mysql -u[user] -p[password] mysql -h[ip] -u[user] -p[password] mysql --host=[ip] --user=[user] --password=[password] MySQL退出 exit quit MySQL目录结构 安装目录 配置文件 my.ini 数据目录 数据库 表 数据 SQL 结构化查询语言。定义了操作所有关系型数据库的规则 SQL通用语法 SQL语句可以单行或者多行书写，以分号结尾 可以使用空格和缩进来增强语句的可读性 MySQL数据库的SQL语句不区分大小写，关键字建议使用大写 注释： 单行注释：-- 注释内容 或# 注释内容（MySQL特有） 多行注释： /* 注释 */ SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL数据定义语言操作数据库 CRUD：增删改查 CREATE创建 创建数据库：CREATE DATABASE 数据库名称; 创建数据库，判断不存在，再创建：CREATE DATABASE IF NOT EXISTS 数据库名称; 创建数据库，并指定字符集：CREATE DATABASE 数据库名称 CHARACTER SET 字符集名; RETRIEVE查询 查询所有数据库名称：SHOW DATABASES; 查询某个数据库的字符集：SHOW CREATE DATABASE 数据库名称;（查询某个数据库的创建语句） UPDATE修改 修改数据库的字符集：ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称; DELETE删除 删除数据库：DROP DATABASE 数据库名称; 判断数据库存在，存在再删除：DROP DATABASE IF EXISTS 数据库名称; 使用数据库 查询当前正在使用的数据库名称：SELECT DATABASE(); 使用数据库：USE 数据库名称; 操作表CREATE创建 格式 123456CREATE TABLE 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n); 注意：最后一列，不需要加逗号 数据库类型 int()：整数类型 double(,)：浮点数 date：日期，只包含年月日 yyyy-MM-dd datetime：日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp：时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar()：字符串 复制表：CREATE TABLE 表名 LIKE 被复制的表名 RETRIEVE查询 查询某个数据库中所有的表名称：SHOW TABLES; 查询表结构：DESC 表名; UPDATE修改 修改表名：ALTER TABLE 表名 RENAME TO 新表名 修改表的字符集：ALTER TABLE 表名 CHARACTER SET 字符集名称 添加一列：ALTER TABLE 表名 ADD 列名 数据类型 修改列名称、类型： ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型 ALTER TABLE 表名 MODIFY 列名 新数据类型 删除列：ALTER TABLE 表名 DROP 列名 DELETE删除 删除表： DROP TABLE 表名; DROP TABLE IF EXISTS 表名; DML数据操纵语言添加数据 语法：INSERT INTO 表名(列名1,列名2,...,列名n) VALUES(值1,值2,...值n); 注意： 列名和值要一一对应 如果表名后，不定义列名，则默认给所有列添加值 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据 语法：DELETE FROM 表名 [WHERE 条件]; 注意： 如果不加条件，则删除表中所有的记录 如果要删除所有记录 DELETE FROM 表名; 不推荐使用，有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; 推荐使用，效率更高，先删除表，然后再创建一张一样的表 修改数据 语法：UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,...[WHERE 条件]; 注意：如果不加任何条件，则会将表中所有记录全部修改 DQL数据查询语言 SELECT * FROM 表名; 语法： SELECT：字段列表 FROM：表名列表 WHERE：条件列表 GROUP BY：分组字段 HAVING：分组之后的条件 ORDER BY：排序 LIMIT：分页限定 基础查询 多个字段的查询 SELECT 字段名1,字段名2,...FROM 表名; 如果查询所有字段，可以使用*代替字段列表 去除重复 DISTINCT 计算列 一般可以使用四则运算计算一些列的值 IFNUL(表达式1，表达式2)：NULL参与的运算，计算结果都为NULL 表达式1：哪个字段需要判断是否为NULL 表达式2：如果表达式1的字段为NULL后进行替换的值 起别名 AS：可以省略 条件查询 WHERE子句后跟条件 运算符 &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN...AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL AND 或 &amp;&amp; OR 或 || NOT 或 ! 123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 查询年龄大于20岁SELECT * FROM student WHERE age &gt; 20;SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄等于20岁SELECT * FROM student WHERE age = 20;-- 查询年龄不等于20岁SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄大于等于20 小于等于30SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25SELECT * FROM student WHERE age IN (22,18,25);-- 查询英语成绩为nullSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为nullSELECT * FROM student WHERE english IS NOT NULL;-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%'; 排序查询 语法：ORDER BY 子句 ORDER BY 排序字段1 排序方式1,排序字段2 排序方式2... 排序方式： ASC：升序。（默认） DESC：降序 注意：如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件 eg：SELECT * FROM emp ORDER BY job_id ASC,id DESC; 聚合函数 将一列数据作为一个整体，进行纵向的计算。 COUNT:计算个数，一般选择非空的列（主键）COUNT(*) SELECT COUNT(IFNULL(mgr,0)) FROM emp; MAX:计算最大值 MIN:计算最小值 SUM:求和 AVG:求平均值 注意：聚合函数的计算，排除null值。 解决方案； 选择不包含非空的列进行计算 IFNULL函数 分组查询 语法：GROUP BY 分组字段; 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别 where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where后不可以跟聚合函数，having可以进行聚合函数的判断 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 分页查询 语法：LIMIT开始的索引，每页查询的条数； 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 limit 是一个MySQL”方言” 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性 分类： 主键约束：PRIMARY KEY 非空约束：NOT NULL 唯一约束：UNIQUE 外键约束：FOREIGN KEY 主键约束 PRIMARY KEY 含义；非空且唯一 一张表只能有一个字段为主键 主键就是表总记录的唯一表示 在创建表时，添加主键约束 1234CREATE TABLE stu( id INT PRIMARY KEY, -- 给id添加主键约束 name VARCHAR(20)) 创建表之后，添加主键约束 123ALTER TABLE stuMODIFY id INT PRIMARY KEY; 删除主键 1234-- 错误写法:ALTER TABLE stu MODIFY id INT;ALTER TABLE stuDROP PRIMARY KEY; 自动增长 概念：如果某一列时数值类型的，使用AUTO_INCREMENT可以来完成值的自动增长 在创建表时，添加主键约束，并且完成主键自增 1234CREATE TABLE stu( id INT PRIMARY KEY AUTO_INCREMENT. name VARCHAR(20)); 添加自动增长 123ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 删除自动增长 123ALTER TABLE stu MODIFY id INT; 非空约束 NOT NULL，值不能为NULL类型 创建表时添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空); 创建表之后，添加非空约束 123ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 删除非空约束 123ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束（索引） UNIQUE:值不能重复 创建表时，添加唯一约束 1234CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束); 在创建表之后，添加唯一约束 123ALTER TABLE stuMODIFY phone_number VARCHAR(20) UNIQUE; 删除唯一约束（索引） 123ALTER TABLE stu DROP INDEX phone_number; 外键约束 FOREIGN KEY：让表与表产生关系，从而保证数据的正确性 在创建表时，添加外键约束 123456CREATE TABLE stu( id INT, lesson VARCHAR(20), CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称) ); 在创建表后，添加外键约束 12345ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 删除外键约束 123ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 级联操作 添加级联操作 123456ALTER TABLE 表名ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE; 分类： 级联更新:ON UPDATE CASCADE 级联删除:ON DELETE CASCADE 数据库设计多表之间的关系 分类： 一对一：一对一关系实现，可以在任意一方添加唯一（UNIQUE）外键指向另一方的主键。 一对多：在多的一方建立外键，指向一的一方的主键。 多对多：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 范式 概念；设计数据库时，需要遵循一些规范，要遵循后边的范式要求，必须先遵循前边所有范式要求。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈，越高的范式数据库冗余越小 明确关系数据库有六种范式：第一范式、第二范式、第三范式、BC范式、第四范式、第五范式(完美范式) 第一范式(1NF)：每一列都是不可分割的原子数据项 第二范式(2NF)：在1NF基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 函数依赖：A-&gt;B，如果通过A属性(属性组)的值能唯一确定B属性的值，则称B依赖于A 完全函数依赖：A-&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值，如：(学号,课程名称)-&gt;分数 部分函数依赖：A-&gt;B,如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。如：(学号,课程名称)-&gt;姓名 传递函数依赖：A-&gt;B,B-C.如果通过A属性(属性组)的值，可以唯一确定B属性(属性组)的值，再通过B属性的值可以确定唯一C属性的值，则称C传递函数依赖于A 码：如果再一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该码的表 主属性：码属性组中的所有属性 非主属性：非 码属性组中的属性 第三范式(3NF)：在2NF的基础上，任何非主属性不依赖于其他非主属性(消除传递函数依赖) BC范式：在3NF的基础上消除主属性对于码的部分与传递函数依赖。 数据库的备份和还原 备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原：登录数据库，创建数据库，使用数据库，执行source 文件 多表查询 查询语法： 123456SELECT 列名列表FROM 表名列表WHERE ... 笛卡尔积：AXB的所有组合 内连接查询 步骤： 从哪些表中查询数据 条件是什么 查询哪些字段 隐式内连接：使用WHERE条件消除无用数据 123456789SELECT t1.name, -- 员工表的姓名t1.gender,-- 员工表的性别t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接：SELECT 字段列表 FROM 表名1 [INNER] JOIN 表名2 ON 条件 1234SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 外连接查询 左外连接 语法：SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 OM 条件; 查询的是左表所有数据以及其交集部分 右外连接 语法：SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 OM 条件; 查询的是右表所有数据以及其交集部分 子查询 概念：查询中嵌套查询，称嵌套查询为子查询。 子查询不同情况 结果是单行单列：子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = 结果是多行单列：子查询可以作为条件，使用运算符IN(条件)来判断 结果是多行多列：子查询可以作为一张虚拟表参与查询 事务基本介绍 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败 操作： 开启事务：START TRANSACTION; 回滚：ROLLBACK; 提交：COMMIT; MySQL数据库中事务默认自动提交 事务提交的两种范式： 自动提交:一条DML（增删改）语句会自动提交一次事务 手动提交：需要先开启事务，在提交 修改事务的默认提交范式： 查看事务的默认提交方式：SELECT @@autocommit;1代表自动提交，0代表手动提交 修改默认提交方式：SET @@autocommit=0; 四大特征 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）：事务前后数据的完整性必须保持一致。 隔离性（Isolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 事务隔离的问题 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改 事务隔离的级别 read uncommitted读取尚未提交的数据 ：脏读、不可重复读、幻读 read committed读取已经提交的数据 ：可以解决脏读–oracle默认的 repeatable read重读读取：可以解决脏读和不可重复读–mysql默认的 serializable串行化：可以解决脏读不可重复读和幻读–相当于锁表 注意 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别：select @@tx_isolation; 数据库设置隔离级别：set global transaction isolation level 级别字符串; DCL管理用户、授权管理用户 添加用户：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;; SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;); mysql中忘记了root用户的密码？ cmd – &gt; net stop mysql 停止mysql服务(需要管理员运行该cmd) 使用无验证方式启动mysql服务： mysqld –skip-grant-tables 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 use mysql; update user set password = password(‘你的新密码’) where user = ‘root’; 关闭两个窗口 打开任务管理器，手动结束mysqld.exe 的进程 启动mysql服务 使用新密码登录。 查询用户： 切换到mysql数据库：USE mysql; 查询user表：SELECT * FROM USER; 权限管理 查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;; 授予所有权限：GRANT ALL ON *.* TO &#39;用户名&#39;@&#39;主机名&#39;; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java测试、反射、注解]]></title>
    <url>%2F2020%2F02%2F09%2FJava%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Junit概述 测试分类； 黑盒测试；不需要写代码，给输入值，看程序是否能够输出期望值 白盒测试；需要写代码。关注程序具体的执行流程。 Junit使用；白盒测试 步骤； 定义一个测试类（测试用例） 建议； 测试类名；被测试的类名Test 报名；xxx.xx.xx.test 定义测试方法；可以独立运行 建议； 方法名；test测试的方法名 返回值；void 参数列表；空参 给方法加@Test 导入junit依赖环境 判断结果； 红色；失败 绿色；成功 一般使用断言操作来处理结果；Assert.assertEquals(期望,结果) 补充； @Before；修饰的方法会在测试方法之前被自动执行（一般用于资源申请） @After；修饰的方法会在测试方法执行之后自动被执行（一般用于资源释放） 反射概述 框架；半成品软件。可以再框架的基础上进行软件开发，简化编码 反射；将类的各个组成部分封装为其他对象，这就是反射机制 优点； 可以在程序运行过程中，操作这些对象 可以解耦，提高程序的可扩展性 获取Class对象的方式； Class.forName(&quot;全类名&quot;)；将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class；通过类名的属性class获取 多用于参数的传递 对象.getClass()；getClass()方法在Object类中定义 多用于对象的获取字节码的方式 结论；同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个 Class对象功能 获取功能 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取全类名 String getName() Field：成员变量 操作： 设置值；void set(Object obj, Object value) 获取值；get(Object obj) 忽略访问权限修饰符的安全检查；setAccessible(true):暴力反射 Constructor:构造方法 创建对象：T newInstance(Object... initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象newInstance方法 Method：方法对象 执行方法： Object invoke(Object obj, Object… args) 获取方法名称： String getName:获取方法名 注解 概念；说明程序的，给计算机看的 注释； 用文字描述程序的，给程序员看的 定义；注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述： JDK1.5之后的新特性 说明程序的 使用注解：@注解名称 作用分类； ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告 一般传递参数all @SuppressWarnings(&quot;all&quot;) 自定义注解 格式； 1234元注解public @interface 注解名称&#123; 属性列表;&#125; 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 public interface MyAnno extends java.lang.annotation.Annotation {} 反编译；cmd -&gt; javap xxx.class 属性；接口中的抽象方法 要求； 属性的返回值类型有下列取值 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性，在使用时需要给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解；用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 在程序使用(解析)注解：获取注解中定义的属性值 获取注解定义的位置的对象 （Class，Method,Field） 获取指定的注解 getAnnotation(Class) 其实就是在内存中生成了一个该注解接口的子类实现对象 调用注解中的抽象方法获取配置的属性值 注意； 以后大多数时候，使用注解，而不是自定义注解 注解给谁用？ 编译器 给解析程序用 注解不是程序的一部分，可以理解为一个标签]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性]]></title>
    <url>%2F2020%2F02%2F09%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java8新特性函数式接口概念 有且只有一个抽象方法的接口，称之为函数式接口 接口中可以包含其他的方法（默认，静态，私有），但是只能有一个抽象方法。 @FunctionalInterface注解 检测接口是否是一个函数式接口 是；编译成功 否；编译失败（接口中没有抽象方法或抽象方法的个数大于1） 格式；1234@FunctionalInterfacepublic interface 接口名&#123; 抽象方法&#125; 使用；一般可以作为方法的参数和返回值类型 函数式编程Lambda的延迟执行 Lambda特点；延迟执行 作用；提升性能 常用函数式接口Supplier接口 java.util.function.Supplier&lt;T&gt;；接口仅包含一个无参的方法；T get()。用来获取一个泛型参数指定类型的对象数据。 生产型接口；指定接口的泛型是什么类型，那么接口中的get方法就会产生什么类型的数据 Consumer接口 java.util.function.Consumer&lt;T&gt;；接口包含抽象方法void accept(T t)，意为消费一个指定泛型数据 消费型接口，泛型执行什么类型，就可以使用accept方法消费什么类型的数据，至于具体怎么消费，需要定义计算 默认方法；addThen 需要两个Consumer接口，可以把两个Consumer接口组合到一起，在对数据进行消费 源码；1234default Consumer&lt;T andThen(Consumer&lt;? super T&gt; after)&#123; Objects.requirNonNull(after); return (T t)-&gt;&#123;accept(t);after.accept(t);&#125;;&#125; Predicate接口 java.util.function.Predicate&lt;T&gt;接口；对某种数据类型的数据进行判断，结果返回一个Boolean值 抽象方法；boolean test(T t)；用来对指定数据类型数据进行判断的方法 默认方法； add；与 1234default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;Objects.requireNonNull(other);return (t) ‐&gt; test(t) &amp;&amp; other.test(t);&#125; or；或 1234default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;Objects.requireNonNull(other);return (t) ‐&gt; test(t) || other.test(t);&#125; negate；非 123default Predicate&lt;T&gt; negate() &#123;return (t) ‐&gt; !test(t);&#125; Function接口 java.util.function.Function&lt;T,R&gt;；接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件 抽象方法；R apply(T t)；根据类型T的参数获取类型R的的结果（一般用于类型转换） 默认方法； andThen Stream流式思想 JDK1.8之后 关注做什么，不关注怎么做 “Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值） Stream（流）是一个来自数据源的元素队列 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源流的来源。 可以是集合，数组等。 Stream操作还有两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 使用步骤 获取数据源 数据转换 执行操作获取想要的结果 注意； Stream流属于管道流，只能被消费一次，第一个Stream流调用完毕，就会关闭。获取流 两种方法 所有的Collection集合都可以通过stream默认方法获取流 Stream接口的静态方法of可以获取数组对应的流 java.util.stream.Stream&lt;T&gt;是Java8新加入的最常用的流接口 根据COllection获取流 default Stream&lt;E&gt; stream() 根据Stream接口获取流 static &lt;T&gt; Stream&lt;T&gt; of(T...values)；参数是一个可变参数，可以传递一个数组 常用方法 延迟方法；返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。 终结方法；返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用逐一处理；foreach void forEach(Consumer&lt;? super T&gt; action)；该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理 forEach方法，用来遍历流中的数据，是一个终结方法，遍历之后就不能继续调用Stream流中的其他方法过滤；filter Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)；可以通过filter方法将一个流转换为另一个子集流映射；map &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);；将流中的元素映射到另一个流中，可以使用map方法统计个数；count long count()；用于统计Stream流中元素的个数 count方法是一个终结方法，返回值是一个long类型的整数，所有不能再继续调用Stream流中的其他方法取用前几个；limit Stream&lt;T&gt; limit(long maxSize);；用于截取流中的元素 limit是一个延迟方法，只是对流中的元素进行截取，返回是一个新的流，所以可以继续调用Stream流中的其他方法跳过前几个；skip Stream&lt;T&gt; skip(long n);；用于跳过元素 如果流的当前长度大于n，则跳过前n个，否则会得到一个长度为0的空流组合；concat static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)；将两个流合并为一个流 这是一个静态方法，与String中的concat方法不同 方法引用 方法引用符：双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者 语义； Lambda表达式写法： s -&gt; System.out.println(s)；拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。 方法引用写法：System.out::println；直接让System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 注:Lambda中传递的参数一定是方法引用中的那个方法可以接收的类型,否则会抛出异常 通过对象名引用成员方法 通过对象名引用成员方法，使用前提是对象名已经存在，成员方法也是已经存在的 通过类名称引用静态方法 通过super引用成员方法 通过this引用成员方法、 类的构造器引用 数组的构造器引用]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程]]></title>
    <url>%2F2020%2F02%2F05%2FJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java网络编程网络基础 软件结构： C/S；Client/Server B/S；Browser/Server 网络协议 TCP/IP协议；传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol) 应用层 传输层 网络层 数据链路层 物理层 TCP；传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次：客户端—&gt;服务器（发请求） 第二次：客户端&lt;—服务器（返回响应） 第三次：客户端—&gt;服务器（曲儿响应） UDP；用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。 IP分类： IPv4；是一个32位的二进制数，通常被分为4个字节，表示成 a.b.c.d的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d的形式，例如 192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个 IPv6；采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成 ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 本机IP地址：127.0.0.1、localhost端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 常用端口号； 80；网络端口 3306；MySQL 1521；Oracle 8080：Tomcat TCP通信 客户端和服务器端进行一个数据交互，需要4个IO流对象 服务器端必须明确； 多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互。在服务器端有个方法叫accept客户端获取到请求的客户端对象 多个客户端同时和服务器端进行交互，就需要使用多个IO流对象 服务器是没有IO流的，服务器可以获取到请求的客户端对象Socket。使用每个客户端Socket中提供的IO流和客户端进行交互（服务器使用客户端的流和客户端交互） TCP通信的客户端；向服务器发送连接请求，给服务i去发送数据，读取服务器回写的数据Socket类 表示客户端的类；java.net.Socket；此类实现客户端套接字，套接字是两台机器之间通信的端点。套接字包含了IP地址和端口号的网络单位 构造方法： Socket(String host,int port)；创建一个流套接字并将其连接到指定主机上的指定端口号。 String host；服务器主机的名称/服务器的IP地址 int port；服务器的端口号 成员方法； OutputStream getOutputStream()；返回此套接字的输出流 InputStream getInputStream()；返回此套接字的输入流 void close()；关闭此套接字 实现步骤； 创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据 释放资源（Socket） 注意； 客户端和服务器端进行交互，必须使用Socket中提供网络流，不能使用自己创建的流对象 当我们创建客户端对象Socket时，就会去请求服务器和服务器经过3次握手建立连接通路。如果服务器没有启动，则抛出异常，如果服务器启动，则进行交互 ServerSocket类 表示服务器的类；java.net.ServerSocket；此类实现服务器套接字 构造方法； ServerSocket(int port)；创建绑定到特定端口的服务器套接字 服务器端必须明确是哪个客户端请求的服务器，所以可以使用accpet方法获取到请求的客户端对象Socket 成员方法； Socket accept()；侦听并接收到此套接字的连接 实现步骤； 创建服务器ServerSocket对象和系统要指定的端口号 使用ServerSocket对象中的方法accpept获取到请求的客户端对象Socket 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据 释放资源(Socket、ServerSocket) 注意 上传完文件，给服务器写一个结束标记 void shutdownOutput()；禁用次套接字的输出流。对于TCP套接字，任何以前写入的数据都将发送，并且后跟TCP的正常连接终止序列]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语法]]></title>
    <url>%2F2020%2F02%2F01%2FJava%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java初步字节 位（bit): 一个数字0或1 字节（Byte）: 8位=1字节，这是数据存储的最小单位 1KB = 1024 Byte,1MB = 1024 KB 命令提示符 MS-DOS(Microsoft Disk Operating System) 启动 ：win + R 切换盘符 ： [盘符]: 进入文件： cd [文件名] 退回上一层：cd .. 退回根目录：cd \ 显示文件列表: dir 清空屏幕：cls 推出cmd : exit JVM、JRE、JDK JVM : Java Virtual Machine,Java虚拟机，是Java程序的运行环境,系统不同，虚拟机版本不同 JRE : Java Runtime Environment, Java运行时环境，包含JVM 和 核心类库 JDK : Java Development Kit, Java开发工具包，包含JRE 和 开发者工具 JDK &gt;&gt; JRE &gt;&gt; JVM Java环境配置 新建变量：JAVA_HOME，值：jdk安装路径，直到bin的上一级 添加Path：%JAVA_HOME%\bin ,%自动匹配% Java入门Java程序运行步骤 java源程序–&gt;编译器–&gt;java字节码文件–&gt;JVM运行 javac.exe : 编译器 java.exe : 解释器 HelloWorld 编写：编写HelloWorld.java 编译：打开CMD，找到程序所在目录，输入javac HelloWorld.java，生成：HelloWorld.class 文件 运行：输入 java HelloWorld ,无需后缀，指定类名 注释 单行注释 ： // 多行注释 ： / / 关键字、标识符 关键字 : 完全小写的字母（public） 标识符 : ·在程序中，自己定义的内容，比如类的名字和变量的名 命名规则: 由 英文字母、0-9、$(美元符)、_（下划线）组成 不能以数字开头 不能是关键字 命名规范: 类名规范：首字母大写，后面每个单词首字母大写（大驼峰） 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰） 方法名规范：同变量名 常量 在程序运行期间，固定不变的量 分类： 字符串常量：双引号引用的部分,例如：”abc”,”123” 整数常量：直接写上数字，没有小数点,例如：100,200 浮点数常量：直接写上数字，有小数点，例如：2.5,-3.14 字符常量：单引号引起来的单个字符，例如：’A’,’中’（没有’’,’AB’，有’ ‘） 布尔常量：只有两种取值，true、false 空常量：null,代表没有任何数据 变量 程序运行期间，内容可以发生改变的量 创建一个变量并且使用的格式： 数据类型 变量名称 //创建了一个变量 变量名称 = 数据值 //赋值交给左边的变量 一步到位 数据类型 变量名称 = 数据值；//创建一个变量的同时，立刻放入指定的数据值 注意事项 ： 如果创建多个变量，变量之间的名称不可以重复 对于float和long类型来说，字母f和L不要漏掉 如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围 没有进行赋值的变量，不能直接使用 变量使用不能超过作用域的范围【作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止】 Java数据类型基本数据类型 整数型 byte short int long 浮点型 float double 字符型 char 布尔型 boolean引用数据类型 字符串 数组 类 接口 Lambda注意事项 字符串不是基本类型，而是引用类型 浮点型可能只是一个近似值，并非精确的值 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节 浮点数当中默认类型是double,如果要用float，需要加上一个后缀F 整数 当中默认类型是int,如果要使用long，需要加上一个后缀L，推荐使用大写字母后缀 数据类型转换 自动类型转换（隐式） 特点：代码不需要进行特殊处理，自动完成。 规则：数据范围从小到大，向上兼容 强制类型转换（显式） 特点: 代码需要进行特殊格式处理，不能自动完成 格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据 注意事项： 强制类型转换一般不推荐使用，因为有可能发生精度损失(小数)、数据溢出(大数) byte/short/char 这三种类型都可以发生数学运算，例如加法”+”。 byte/short/char 这三种类型在运算时，都会被首先提升为int类型，然后再计算。 boolean类型不能发生数据类型转换 对于byte/short/char 三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧范围，编译器自动补上强转。 如果超过左侧范围，编译器会直接报错。 在给变量进行赋值时候，如果右侧地表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 编译器的常量优化 ： short result = 5 + 8; 等号右边全是常量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中相当于直接就是 short result = 13;右侧的常量结果数值，没有超过左侧范围，所以正确。这种成为“编译器的常量优化”。常量计算在编译时已经计算并赋值。一旦表达式右侧有变量参与，则无法进行这种优化。 ASCII码 ASCII : American Standard Code for Information Interchange 美国信息交换标准代码 Unicode : 万国码，也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是128开始包含有更多字符 ‘0’ - ‘48’ , ‘A’ - 65 , ‘a’ - 97 运算符 进行特定操作的符号，例如：+ 表达式：用运算符连起来的式子，例如：a + b 分类： 算数运算符：+ 、 - 、 * 、 / 、 % 、 ++ 、 – 赋值运算符：= 、 += 、-= 、*= 、/= 、%= 比较运算符：== 、&lt; 、 &gt; 、 &lt;= 、 &gt;= 、 != 逻辑运算符：&amp;&amp; 、 || 、 !(取反) 三目运算符：数据类型 变量名称 = 布尔类型表达式 ? 结果1 : 结果2 （true为结果1，false为结果2） 方法入门 定义：若干语句功能的集合，将一个功能抽取出来，形成一个单独的功能，提高代码复用，减少冗余 格式： 123456789/*修饰符 返回值类型 方法名(参数列表)&#123; 方法体 return ;&#125;*/public static void method()&#123; System.out.println("这是一个方法");&#125; 调用: 方法不会自动运行，必须被调用 注意: 方法定义的先后顺序无所谓 方法定义必须是挨着的，不能再一个方法的内部定义另外一个方法 方法必须被调用才会执行 Java9 新特性 JShell : 适合片段代码的测试 启动 ： cmd + JShell 退出 : /exit 流程控制顺序 顺序结构：根据编写顺序，从上到下执行。 判断 if if…else if…else if…else 选择 switch 注意：多个case后面的数值不可以重复 switch小括号当中只能是下列数据类型 基本数据类型 ： byte/short/char/int 引用数据类型 : String字符串、enum枚举 123456789101112switch()&#123; case 常量值1: 语句1; break; case 常量值2: 语句2; break; ... default: 语句体:n+1; break;&#125; case的穿透性：如果case的后面不写break,将出现穿透现象，直接向后运行，直到遇到break; 循环 for while do-while：无条件执行一次循环体，具有一定风险性 12345初始化表达式 do&#123; 循环体 步进表达式 &#125;while(布尔表达式) 区别： 如果条件判断从来没有满足过，for和while将执行0次，do-while至少循环一次 for循环的变量在小括号当中定义，只有循环内可以使用 IDEA快捷键 (自定义)自动补全快捷键:file-settings-keymap-dupulicate(创建副本)-main menu-code-completion-basic(ctrl+alt+?) Alt+Enter : 导入包，自动修正代码 Ctrl+Y : 删除光标所在行 Ctrl+D : 复制光标所在行，插入光标位置下面 Ctrl+ALt+L : 格式化代码 Ctrl+/ : 单行注释 Ctrl+Shift+/ : 多行注释 Alt+Ins : 自动生成代码，toString,get,set方法 Alt+Shift+上下箭头 : 移动当前代码行项目结构 Project Module Package Class Java基础方法定义 若干语句功能的集合 参数:进入方法的数据 返回值: 从方法中出来的数据 格式1234修饰符 返回值类型 方法名称(参数类型 参数名称,...)&#123; 方法体 return 返回值;&#125; 修饰符: public static… 返回值类型: void int 方法名称 : 方法名字，小驼峰 参数名称 : 进入方法的数据对应的变量名称 方法体 : 方法需要做的事 return : 停止当前方法，将返回值还给调用处 返回值 : 执行方法后得到的数据结果 注意 : return后面的”返回值“，必须和方法名称前面的返回值类型，保持对应 方法的调用 单独调用: 方法名称(参数),返回值为void,只能单独调用 打印调用: System.out.println(方法名称(参数)); 赋值调用: 数据类型 变量名称 = 方法名称(参数); 方法的重载（Overload） 在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 参数列表: 个数不同，数据类型不同，顺序不同 重载方法调用 : JVM通过方法的参数列表，调用不同的方法。 注意 : 与参数的名称无关 与方法的返回值类型无关 注意 方法应该定义在类中，但是不能在方法中再定义方法，不能嵌套 方法定义的先后顺序无所谓 方法必须被调用才能执行 返回值类型必须和方法的返回值类型对应 数组概念 存储数据长度固定的容器，保证多个数据的数据类型要一致 特点 数组是一种引用数据类型 数组当中的多个数据类型一致 数组的长度在程序运行期间不可改变 初始化 在内存中创建一个数组，并且向其中赋予一些默认值 动态初始化:指定长度 静态初始化:指定内容 动态初始化 数据类型[] 数组名称 = new 数据类型[数组长度] 左侧数据类型:数组中保存的数据类型 左侧的中括号:表示这是一个数组 左侧数组名称:数组的名字 右侧的new : 代表创建数组的动作 右侧数据类型:必须和左边的数据类型保持一致 右侧中括号的长度:数组当中，到底可以保存多少个数据,是一个int数字 1int[] arrayA = new int[200]; 注意: 使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值 整数型:默认值0; 浮点型:默认值0.0; 字符型:’\u0000’; 布尔型:false; 引用型:null. 静态初始化 数据类型[] 数组名称 = new 数据类型[]{元素1, 元素2, 元素3...} 自动分配空间和容量 1int[] arrayB = new int[]&#123;5,10,15&#125; 注意: 静态初始化也有默认值，只不过系统自动马上将默认值替换成大括号中具体值 数组的访问 直接打印数组名称，得到的是数组对应的,内存地址哈希值 访问数组元素的格式: 数组名称 [索引值] 数组的内存 栈(Stack):存放的都是方法中的局部变量。方法的运行一定要在栈中运行。 局部变量:方法的参数，或者是方法{}内部的变量 作用域:一旦超出作用域，立刻从栈内存当中消失 堆(Heap): new出来的东西，都在堆中。 堆内存里面的东西都有一个地址值:16进制 堆内存里面的数据，都有默认值 方法区(Method Area):存储.class相关信息，包含方法的信息 本地方法栈(Native Method Stack):与操作系统相关 寄存器(pc Register): 与CPU相关 数组的常见问题 索引越界异常:如果访问数组元素的时候，索引编号不存在，将会发生数组索引越界异常:ArrayIndexOutOfBoundsException 空指针:数组必须进行new初始化才能使用其中的元素。如果只是赋值了一个null,没有进行new创建，那么将会发生空指针异常:NullPointerException 数组的常用操作 获取数组长度: 数组名称.length，数组一旦创建，程序运行期间，长度不可改变 数组的遍历: 数组名称.fori–&gt;自动补全遍历代码 数组作为方法参数: 传递地址值 数组作为方法返回值: 返回地址值，public static int[] 方法名，return 数组名 注意 方法的参数为基本类型时，传递的是数据值 方法的参数为引用类型时，传递的时地址值 Java中级面向对象思想 面向过程: 当需要实现一个功能时，每一个步骤都需要具体描述出来，强调步骤 面向对象:当需要实现一个功能时，不关心具体步骤，强调过程 封装 继承 多态类和对象类和对象的关系 类:一组相关属性和行为的集合，可以看作是一类事物的模板，使用事物的属性特性和行为特征来描述该类事物。 属性:该事物的状态信息 行为:该事物能够做什么 对象:一类事物的具体体现。对象是类的一个实例,必然具备该类事物的属性和行为。 类与对象的关系: 类是对象的模板，对象是类的实例 类是一类事物的描述，抽象 对象是一类事物的实例，具体 类的定义 格式: 1234public class ClassName&#123; //成员变量 //成员方法&#125; 成员变量(属性):对应事物的属性(事物的状态信息) 成员方法(行为):对应事物的行为(事物能够做什么)对象的使用 通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用 导包：指出所需要使用的类，在什么位置：import 包名称.类名称 创建：类名称 对象名 = new 类名称(); 使用： 使用成员变量：对象名.成员变量名 使用成员方法：对象名.成员方法名(参数) 注意： 当使用一个对象类型作为方法的参数时，传递的就是对象的地址值。 当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值。 成员变量与局部变量的区别 定义的位置不一样 局部变量：方法内部 成员变量：方法外部，直接写在类当中 作用的范围不一样 局部变量：只有方法当中才可以使用 成员变量：整个类可以使用 默认值不一样 局部变量：没有默认值，必须手动赋值 成员变量：如果没有进行赋值，会有默认值，规则和数组一样 内存位置不一样 局部变量；位于栈内存中 成员变量：位于堆内存中 生存周期不一样 局部变量：随着方法进栈儿诞生，随着方法出栈而消失 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失封装 封装性在Java当中的体现 方法就是一种封装 关键字private也是一种封装 封装就是将一些细节信息隐藏起来，对于外界不可见 Private private是一个权限修饰符，代表最小权限 可以修饰成员变量和成员方法 被private修饰后的成员变量和成员方法，只有在本类中访问，超过本类范围就不能被访问 通过设置setXXX(),getXXX()方法来实现外部访问 This this代表所在类的当前对象的引用(地址值),即对象自己的引用 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量 如果需要访问本类当中的成员变量，需要使用格式:this.成员变量名 通过谁调用的方法，谁就是this 构造方法 构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。 格式 123public 类名称(参数类型 参数名称)&#123; 方法体&#125; 注意事项： 构造方法的名称必须和所在类名称完全一致 构造方法不要写返回值类型，连void也不用写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，编译器会默认添加一个无参，无方法体的构造方法 一旦编写了至少一个构造方法，那么编译器将不再默认添加 构造方法也可以进行重载（方法名相同，参数列表不同） 标准类(JavaBean) 格式 所有成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法(快捷键:Alt+insert/CODE-&gt;Generate生成器) 编写一个无参数的构造方法(快捷键：Alt+insert-&gt;Constuctor构造器) 编写一个全参数的构造方法 这样的标准类也叫JavaBean JavaBean：Java语言编写类的一种标准规范。 Java高级常用API API: Application Programming Interface.应用程序编程接口。Java API时一本程序员的字典，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们通过查询API的方式，来学习Java提供的类 API使用步骤： 打开帮助文档 点击显示，找到快速索引，看到输入框 输入需要查找的内容 看包，java.lang下的类不需要导包，其他需要 看类的解释和说明 学习构造方法 使用成员方法 Scanner类 功能：可以实现键盘输入数据，到程序中 引用类型一般使用步骤： 导包: import 包路径.类名称，如果需要使用的目标类和当前类位于同一个包下，则可以省略导包语句不写，只有java.lang包下的内容不需要导包，其他包都需要import语句 创建: 类名称 对象名 = new 类名称() 使用: 对象名·成员方法名() 导包：import java.util.Scanner 创建：Scanner sc = new Scanner(System.in)，System.in表示从键盘进行输入 使用： 获取键盘输入的一个int数字：int num = sc.nextInt(); 获取键盘输入的一个字符串：String str = sc.next(); 匿名对象 创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量 格式：new 类名称(参数列表);，左边没有变量值和赋值号。 应用场景： 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不创建一个新对象，造成浪费 匿名对象可以作为方法的参数和返回值 12345678910111213141516171819202122232425262728293031import java.util.Scanner;/* * 匿名对象 Anonymous * 做参数 * 做返回值 * */public class Anonymous &#123; public static void main(String[] args) &#123;// 做参数 System.out.println("输入的数字是：" + new Scanner(System.in).nextInt());// 使用匿名对象作为参数 methodParam(new Scanner(System.in));// 匿名对象作为返回值 Scanner sc = methodReturn(); System.out.println("第三次输入的是："+sc.nextInt()); &#125; // 匿名对象做参数 public static void methodParam(Scanner sc) &#123; int anInt = sc.nextInt(); System.out.println("输入的第二个数字是:" + anInt); &#125; // 匿名对象做返回值 public static Scanner methodReturn()&#123; return new Scanner(System.in); &#125;&#125; Random类 作用：产生随机数 使用步骤： 查看类：导包，import java.util.Random 查看构造方法：创建，Random r = new Random() 查看成员方法：使用， 获取一个随机的int数字：int num = r.nextInt() 获取一个随机的int数字：(参数代表范围，左闭右开区间)，int num = r.nextInt(3),实代表的范围是 [0,3) ArrayList类 ArrayList集合的长度是可以随便变化的 导包：import java.util.ArrayList 创建：ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); 使用：成员方法 public boolean add()：向集合当中添加元素，参数的类型和泛型一致 public E get(int index)；从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素 public E remove(int index)：从集合中删除元素，参数是索引编号，返回值就是被删除掉的元素 public int size()：获取集合的长度，返回值是集合中元素的个数 注意： 尖括号内的泛型只能是引用类型，不能是基本类型 如果向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的包装类 基本类型 -&gt; 包装类 int -&gt; Integer byte -&gt; Byte short -&gt; Short long -&gt; Long float -&gt; Float double -&gt; Double char -&gt; Character boolean -&gt; Boolean 从JDK1.5开始，支持自动装箱（基本类型-&gt;包装类型），自动拆箱（包装类型-&gt;基本类型） String 特点： 字符串的内容永不可变 字符串可以共享使用 字符串效果上相当于是char[ ]字符数组，但其底层原理是byte[ ]字节数组。 创建字符串： 三种构造方法 public String()：创建一个空白字符串，不含任何内容 public String(char[] array)：根据字符数组的内容，来创建对应的字符串 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串 一种直接创建 String str = &quot;Hello&quot;; //右边直接用双引号 直接写上双引号，就是字符串对象 字符串常量池 对于常量类型来说，==判断的是值 对于引用类型来说，==判断的是地址值 双引号直接写的字符串在常量池当中，new的不在池当中 常用方法字符串比较 public boolean equals(Object obj);//参数可以是任何对象，任何对象都能用object进行接受 注意： 任何对象都能用object进行接收 equals方法具有对称性，也就是a.equals(b)和b.equals(a); 如果比较双方一个常量一个变量，推荐常量写在前面，推荐：&quot;abc&quot;.equals(str),不推荐str.equals(&quot;abc&quot;)；防止str为null，产生空指针异常 public boolean equalsIgnoreCase(String str)：忽略大小写进行内容比较 字符串获取 public int length()：获取字符串当中含有的字符个数，拿到字符串的长度 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串（concatenate级联） public char charAt(int index)：获取指定索引位置的单个字符（索引从0开始） public int indexOf(String str)：查找参数字符串在原本字符串当中首次出现的索引位置，如果不存在，返回-1 字符串截取 public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串，[begin, end)，包含左边，不含右边 字符串转换、替换 public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值 public byte[] getBytes()：获取当前字符串底层的字节数组 public String replace(CharSequence oldString, CharSequence newString)：将所有出现的老字符串替换成为新的字符串,CharSequence意思就是说可以接受字符串类型。 字符串分割方法 public String[] split(String regex)：按照参数规则，将字符串切分为若干部分 注意：split方法的参数其实是一个正则表达式如果要切分&quot;.&quot;，必须写成&quot;\\.&quot; static关键字 static用来修饰成员变量和成员方法，被修饰的成员是属于类，而不是仅仅属于某个对象自己，凡是本类的对象，都共享同一内容。 一旦使用static修饰静态成员方法，那么这种方法就成为了静态方法，静态方法可以直接通过对象名进行调用，也可以直接通过类名称来调用；非静态方法必须通过创建类才能使用 有static，推荐使用类名称进行调用 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 对于本类当中的静态方法，可以省略类名称，编译器会自动补全 注意： 静态不能直接访问非静态，因为在内存当中先有静态内容，后有非静态内容 静态方法不能用this，因为this代表当前对象，通过谁调用方法，谁就是当前对象 静态代码块 格式 12345public class 类名称&#123; static&#123; //静态代码块内容 &#125;&#125; 当第一次用到本类时，静态代码块执行唯一的一次 静态内容总是优先于非静态，所以静态代码块构造方法先执行 用途：用来一次性地对静态成员变量进行赋值 数组根据类：Arrays 作用：与数组相关的工具类，实现数组的常见操作，所有方法都是静态方法，使用非常方便 导包：java.util.Arrays 使用： public static String toString()；将参数数组变成字符串(按照默认格式；[元素1，元素2，元素3…]) public static void sort(数组)：按照默认升序对数组的元素进行排序。 如果是数值，sort默认升序 如果是字符串，sort默认按字母升序 如果是自定义类，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 数学工具类：Math 与数学相关的工具类，里面提供了大量的静态方法，完成于数学运算相关的操作 导包；java.util.Math 使用： public static double abs(double num)：获取绝对值 public static double ceil(double num)：向上取整 public static double floor(double num)：向下取整 public static long round(double num)：四舍五入 Math.PI：圆周率常量 继承定义 继承是多态的前提，如果没有继承，就没有多态 主要解决的问题：共性抽取 子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类的非私有的属性和行为 父类：基类、超类 子类；派生类格式 子类与父类的关系：is-a 父类：(一个普通的类定义) 123public class 父类名称&#123; //...&#125; 子类： 123public class 子类名称 extends 父类名称&#123; //...&#125; 特点成员变量 父类无法使用子类成员变量 子类仅可以直接访问父类的非私有成员变量 成员变成重名： 直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找 间接通过成员方法访问成员变量：方法属于谁就优先用谁，没有则向上找 三种变量重名： 局部变量：直接写成员变量名 本类的成员变量：this.成员变量名 父类的成员变量：super.成员变量名 成员方法 成员方法不重名：正常使用 成员方法重名：创建的对象是谁，优先用谁的方法 注意：无论是成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类 方法重写 重写(Override)【覆盖】：在继承关系当中，方法的名称一样，参数列表也一样 对比： 重载：Overload：方法名称相同，参数列表不同 重写：Override：方法名称相同，参数列表也相同–覆盖 特点：创建的是子类对象，则优先使用子类方法 注意： 必须保证父子类之间的方法名称相同，参数列表也相同 @Override // 写在方法前面，用来检测是不是有效的正确的覆盖重写（注解） // 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写 2. 子类方法的返回值必须**小于等于**父类方法的返回值范围 &gt; `java.lang.Object`类是所有类的公共最高父类，java.lang.String就是Object的子类 3. 子类方法的权限必须**大于等于**父类方法的权限修饰符 &gt; public &gt; protected &gt; (default)(不写) &gt; private 构造方法 继承关系中，父子类构造方法的访问特点； 子类构造方法当中有一个默认隐含的super()调用，所以一定是先调用父类构造，后执行子类的构造 子类构造可以通过super关键字来调用父类重载构造 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造 super关键字 在子类的成员方法中，访问父类的成员变量：super.变量名 在子类的成员方法中，访问父类的成员方法：super.方法名 在子类的构造方法中，访问父类的构造方法：super(); 继承的特征 Java语言是单继承的，一个类的直接父类只能有一个 Java语言可以多级继承（继承体系），顶层都是Object类 一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类 抽象类定义 没有方法主体的方法称为抽象方法，包含抽象方法的类，必须是抽象类 抽象类：包含抽象方法的类 抽象方法：没有方法体的方法，加上abstract关键字，去掉方法体，分号结束 格式 抽象方法： 12// 修饰符 abstract 返回值类型 方法名(参数列表);public abstract void method(); 使用 不能直接创建new抽象类对象 必须用子类继承抽象父类 子类必须覆盖重写抽象父类所有的抽象方法 继承抽象类的子类必须重写父类所有的抽象方法，否则该子类也必须声明为抽象类，最终必须要有子类实现该父类的抽象方法，否则抽象父类到子类的创建全部失效，失去意义 注意 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的 抽象类中，不一定包含抽象方法，但是有抽象方法的类一定是抽象类 抽象类的子类，必须重写抽象父类所有的抽象方法，否则，编译无法通过报错，除非该子类也是抽象类 接口定义 接口就是一种公共的规范标准 接口是一种引用数据类型（数组、类、接口） 格式 123public interface 接口名称&#123; // 接口内容&#125; 备注：换成关键字interface之后，编译生成的字节码文件仍然是：.java-&gt;.class java版本 java7： 常量 抽象方法 java8: 默认方法 静态方法 java9 私有方法 使用 接口不能直接使用，必须有一个“实现类”来“实现”接口 格式：123public class 实现类名称 implements 接口名称&#123; // ...&#125; 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法（否则它必须是一个抽象类） 实现：去掉abstract关键字，加上方法体和大括号 创建实现类的对象，进行使用 接口的抽象方法 注意： 接口当中的抽象方法，修饰符必须是两个固定关键字：public abstract 这两个关键字修饰符，可以选择性省略 方法的三要素，可以随意定义 接口的默认方法 从Java8开始，可以使用默认方法，默认方法可以被实现类继承 作用：解决接口升级的问题（实现类可以重写默认方法） 格式：123public default 返回值类型 方法名称(参数列表)&#123; // 方法体&#125; 接口的静态方法 从Java8开始，接口当中允许定义静态方法 静态与.class文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 格式： 123public static 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 注意：不能通过接口实现类的对象来调用当中的静态方法 正确用法：通过接口名称，直接调用其中的静态方法。 格式：接口名称.静态方法名称(参数) 接口的私有方法 我们需要抽取一个共有方法，用来解决多个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。 从Java9开始，接口当中允许定义私有方法 普通私有方法：解决多个默认方法之间重复代码问题 格式： 123private 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 静态私有方法：解决多个静态方法之间重复代码问题 123private static 返回值类型 方法名称(参数列表)&#123; 方法体&#125; 接口的成员变量（常量） 接口中可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】 格式： public static final 数据类型 常量名称 = 数据值; 一旦使用final关键字进行修饰，说明不可改变 注意： 接口当中的常量，可以省略public static final 接口当中的常量，必须进行赋值，不能不赋值 接口中，常量的名称，使用完全大写的字母，用下划线进行分隔(shift+F6) 总结 在java9+版本中，接口的内容可以有 成员变量其实是常量，格式：[public] [static] [final] 数据类型 常量名称 = 数据值; 注意： 常量必须进行赋值，而且一旦赋值不能改变 常量名称完全大写，用下划线进行分隔 接口中最重要的就是抽象方法，格式： [public] [abstract] 返回值类型 方法名称(参数列表) 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类 从Java8开始，接口里允许定义默认方法，格式：[public] default 返回值类型 方法名称(参数列表){方法体} 注意：默认方法也可以被覆盖重写 从Java8开始，接口里允许定义静态方法，格式：[public] static 返回值类型 方法名称(参数列表){方法体} 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法 从Java9开始，接口里允许定义私有方法，格式： private 返回值类型 方法名称(参数列表){方法体} private static 返回值类型 方法名称(参数列表){方法体} 注意：private方法只有接口自己才能调用，不能被实现类或别人使用 注意 接口不能有静态代码块 接口不能有构造方法 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口 格式： 123public class 实现类 implements 接口A,接口B&#123; // 覆盖重写所有抽象方法&#125; 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类 如果实现类所实现的多个接口，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法（父类&gt;&gt;接口） 接口的多继承 类与类之间是单继承的，直接父类只能有一个 类与接口之间是多实现的，一个类可以实现多个接口 接口与接口之间是多继承的 使用：关键字extends 注意 多个父接口当中的抽象方法如果有重复，没关系 多个父接口当中的默认方法如果有重复，那么子接口必须进行默认方法的覆盖重写，【而且要带着default关键字】 实现类重写接口默认方法，不需要保留default关键字 多态概述 多态性：一个对象拥有多种形态 代码当中体现多态性：【父类引用指向子类对象】 格式： 父类名称 对象名 = new 子类名称(); 或者 接口名称 对象名 = new 实现类名(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误，如果有，执行的是子类重写后方法 多态中的成员变量 直接通过对象名访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 多态中的成员方法 new的是谁，就优先用谁，没有则向上找 注意： 成员方法：编译看左，运行看右 成员变量：编译看左，运行看左 多态的优点 方法调用相同（编译时），用谁找谁（运行时），动态过程 引用类型转换向上转型 向上转型：多态本身是子类类型向父类类型向上转型的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型 格式：父类名称 对象名 = new 子类名称(); 注意：向上转型一定是安全的。从小范围–&gt;大范围 缺陷：无法调用子类特有的内容 向下转型 向下转型：父类类型向子类类型向下转型的过程(还原)，这个过程是强制的 格式：子类名称 对象名 = (子类名称)父类对象; 含义：将父类对象，还原成原本的子类对象 注意： 要还原的对象必须是原来创建的对象，才能向下转型 要还原的对象如果不是原来创建的对象，而是其他对象，就会报错（运行异常，ClassCastException） instance of关键字 作用：返回一个boolean值，判断前面的对象能不能当作后面类型的实例 格式：变量名 instance of 数据类型 final关键字 含义：代表最终、不可改变的 使用： 修饰一个类，不能被继承 修饰一个方法，不能被重写 修饰一个局部变量，不能被重新赋值 修饰一个成员变量，不能被重新赋值 修饰类 格式： 123public final class 类名称()&#123; // ...&#125; 作用：当前这个类不能有任何的子类（final类不能作为父类） 注意：final类的所有成员方法都无法进行覆盖重写 修饰方法 格式： 123public final 返回值 方法名(参数列表)&#123; // 方法体&#125; 作用：当前方法就是最终方法，不能再被覆盖重写 注意：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾 修饰局部变量 格式： 1final 数据类型 数据名 = 数据值; 作用：当前局部变量，不能进行更改，一次赋值，终生不变 注意：对于基本类型，不可变说的是变量当中的数据不可变；对于引用类型来说，不可变说的是变量当中的地址值不可变 修饰成员变量 格式： 1final 数据类型 数据名 = 数据值; 作用：当前成员变量，不能进行更改，但成员变量有默认值，用了final后必须进行手动赋值 注意： 对于final的成员变量，要么使用直接赋值，要么使用构造方法赋值（二选一） 必须保证类当中所有重载构造方法，都最终会对final的成员变量进行赋值 权限修饰符 public protected (default) private 同一个类 YES YES YES YES 同一个包 YES YES YES NO 不同包子类 YES YES NO NO 不同包非子类 YES NO NO NO 内部类 定义：将一个类A定义在另一个类B里面，A被称为内部类，B被称为外部类 成员内部类：定义在类中方法外的类 分类： 成员内部类 局部内部类(包含匿名内部类) 注意：内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。比如，Person$Heart.class 成员内部类 定义在一个类内成员方法外的类 格式： 123456修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; //... &#125; //...&#125; 使用： 直接：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称() 间接：在外部类的方法中，使用内部类：然后main只是调用外部类的方法 注意； 内用外，随意访问，外用内，需要内部类对象 同名变量访问：（重名）外部类名称.this.外部类成员变量名 局部内部类 定义在一个方法内部的类，“局部”：只有当前所属方法才能使用，出了方法无法使用 格式： 1234567修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称(参数列表)&#123; class 局部内部类名称&#123; //... &#125; &#125;&#125; 使用：方法内创建局部类对象，main直接调用外部类方法 注意：权限修饰符 外部类：public/(default) 成员内部类：public / protected / (default) / private 局部内部类：无法使用修饰符 局部内部类的final问题 局部内部类，如果希望访问所在方法的局部变量，那么这份局部变量必须是有效final的(从Java8开始，只要局部变量事实不变，那么final关键字可以省略) 原因： new出来的对象在堆内存当中 局部变量是跟着方法走到，在栈内存中 方法运行结束之后，立刻出栈，局部变量就会立刻消失 new出来的对象会在堆中持续存在，直到垃圾回收消失 匿名内部类 如果接口的实现类(或者是父类的子类)，只需要使用唯一的一次，那么这种情况就可以省略掉该类的定义，改用匿名内部类 格式： 123接口名称 对象名 = new 接口名称()&#123; // 覆盖重写所有抽象方法&#125;; 对”new 接口名称(){…};”解析: new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 注意： 匿名内部类，在创建对象的时候，只能使用唯一一次，如果希望多次创建对象，而且内容一样，那么就必须使用单独的实现类 匿名对象，在调用方法的时候，只能调用一次，如果希望同一个对象，调用多次方法，必须要给对象取名 匿名内部类省略了实现类/子类，匿名对象省略了对象名称 匿名内部类和匿名对象不是一回事 常用API-2Object类 类Object是类层次结构的根(父)类。每个类都使用Object作为超(父)类，所有对象（包括数组）都实现这个类的方法 导包：java.lang.Object 使用 public String toString()：返回该对象的字符串表示 public boolean equals(Object obj)：指示其他某个对象是否与此对象”相等” toString方法 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值 直接打印对象的名字，其实就是调用对象的toString 覆盖重写 在IDEA中，可以使用alt+insert，点击toString() 看一个类是否重写了toString,直接打印这个类的对象即可，如果没有重写toString方法，那么打印的是对象的地址值equals方法 如果没有重写equals方法，默认比较对象的地址值，如果需要比较内容，需要覆盖重写 参数： Object obj：可以传递任意的对象 this ；调用的对象 obj ；参数 基本数据类型：比较地址值 引用数据类型；比较对象的地址值 覆盖重写： 问题：隐含一个多态，无法使用子类特有的内容（属性和方法） 解决：向下转型（强转） alt+insert ,equals() and hashCode() Objects类 JDK7中添加的工具类，其中的方法是null-save(空指针安全)或null-tolerant(容忍空指针)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象 Objects.equals方法：防止出现空指针异常123public static boolean equals(Object a, Object b)&#123; return (a==b)||(a!=null&amp;&amp;a.equals(b));&#125; Date类 表示特定的瞬间，精确到毫秒（千分之一秒 1000毫秒=1秒） 毫秒值的作用：可以对时间和日期进行计算（0毫秒：1970年1月1日 00:00:00） 中国属于东八区，会把时间+8小时 导包：java.util.Date构造方法 public Date()：获取当前系统的日期和时间 public Date(Long date):传递毫秒值，把毫秒值转换为Date日期成员方法 public long getTime():把日期转换为毫秒值(相当于System.currentTimeMillis()方法)，返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数DateFormat类 定义：日期/时间格式化子类的抽象类，可以实现日期和文不之间的转换（Date-&gt;String） 作用：格式化（日期-&gt;文本）、解析（文本-&gt;日期） 导包：java.text.DateFormat 成员方法： String format(Date date)：按照指定的模式，把Date日期，格式化为符合模式的字符串 Date parse(String source)：把符合模式的字符串，解析(parse)为Date日期 DateFormat是抽象类，无法之间创建对象使用，可以使用DateFormat的子类（SimpleDateFormat） parse方法声明了一个异常叫ParseException，如果字符串和构造方法的模式不一样，那么程序就会抛出此异常，调用一个抛出了异常的方法，就必须处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理 SimpleDateFormat: java.text.SimpleDateFormat extends DateFormat 构造方法：SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造 注意：模式中的字母不能更改，连接模式的符号可以改 Calendar类 本身是抽象类，已知子类GregorianCalendar，提供了很多操作日历字段的方法(YEAR\MONTH\DAT_OF_MONTH\HOUR) Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance()，此方法返回了Calendar类的子类对象 static Calendar getInstance() 使用默认时区和语言环境获得一个日历常用方法 public int get(int field)：返回给定日历字段的值 public void set(int field, int value)；将给定的日历字段设置为给定值 public abstract void add(int field, int amount)；根据日历的规则，为给定的日历字段添加或减去指定的时间量 public Date getTime()；返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象 注意；int field；日历类的字段，可以使用Calendar类的静态成员变量获取 System类 导包：java.lang.System 获取与系统相关的信息或系统级操作常用方法 public static long currentTimeMillis()；返回以毫秒为单位的当前时间 public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length)；将数组中指定的数据拷贝到另一个数组中 StringBuilder类 字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），底层也是一个数组，但是没有final修饰，可以改成长度 在内存中始终是一个数组，占用空间少（byte[] value = new byte[16]），效率高，如果超出，自动扩容 java.lang.Builder构造方法 StringBuilder()；构造一个不带任何字符的字符串生成器，其初始容量为16个字符 StringBuilder(String str)；构造一个字符串生成器，并初始化为指定的字符串内容成员方法 public StringBuilder append(...)；添加任意类型数据的字符串形式，并返回当前对象自身 public String toString()；将当前StringBuilder对象转换为String对象注意 String-&gt;StringBuilder；可以使用StringBuilder的构造方法 StringBuilder-&gt;String；可以使用StringBuilder的toString方法 基本类型包装类 使用一个类，将基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类，我们可以使用类中的方法来操作这些基本类型的数据装箱与拆箱 装箱；把基本类型的数据，包装到包装类中 构造方法： Integer(int value)；构造一个新分配的Integer对象，它表示指定的int值 Integer(String s)；构造一个新分配的Integer对象，它表示String参数所指示的int值（注意：传递的字符串，必须是基本类型的字符串，否则会抛出异常‘100’正确，‘0’异常） 静态方法 static Integer valueOf(int i)；返回一个表示指定的int值的Integer对象 static Integer valueOf(String s)；返回保存指定的String的值的Integer对象 拆箱；在包装类中取出基本类型的数据 成员方法；int intvalue()；以int类型返回该Integer值 自动装箱与自动拆箱 基本类型的数据和包装类之间可以自动地相互转换（JDK1.5之后） 基本类型与字符串类型的转换 基本类型-&gt;字符串； 基本类型的值+”” 包装类的静态方法toString(参数)，不是Object类的toString()方法，发生了重载 String类的静态方法valueOf(参数) 字符串-&gt;基本类型； 包装类的静态方法；parseXXX(“数值类型的字符串”) 集合概述 数组长度固定；集合长度可变 数组存储同一类型元素；集合只能存储对象，类型可以不一致 框架 Collection接口；所有单列集合中共性的方法\所有的单列集合都可以使用共性的方法\没有索引的方法 List接口；有序的集合（存储和取出元素顺序相同）\允许存储重复元素\有索引，可以使用普通的for循环遍历 Vector集合 ArrayList集合 LinkedList集合 Set接口；不允许存储重复元素\没有索引（不能使用普通的for循环遍历） TreeSet集合 HashSet集合 LinkedHashSet集合(存取一致) Collection集合常用方法 public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() ；清空集合中所有的元素。 public boolean remove(E e)；把给定的对象在当前集合中删除。 public boolean contains(E e)；判断当前集合中是否包含给定的对象。 public boolean isEmpty()；判断当前集合是否为空。 public int size()；返回集合中元素的个数。 public Object[] toArray()；把集合中的元素，存储到数组中。 Iterator迭代器 为了遍历集合中所有元素 java.util.Iterator Iterator接口 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 常用方法； boolean hasNext()；如果仍有元素可以迭代，返回true E next() ；返回迭代的下一个元素 注意：Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象。Colletion接口中有一个方法，叫iterator()，返回的就是迭代器的实现类对象 使用步骤； 使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态），注意迭代器也有泛型，跟着集合走 使用Iterator接口中的方法hasNext判断还有没有下一个元素 使用Iterator接口中的方法next取出集合中的下一个元素 增强for循环 底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，jdk1.5之后 Collection&lt;E&gt;extends Iterable&lt;E&gt;；所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;；实现这个接口允许对象成为”foreach”语句的目标 格式 123for(集合/数组的数据类型 变量名:集合名/数组名)&#123; sout(变量名);&#125; 注意；新for循环必须有被遍历的目标，目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现 泛型(Generic)概述 一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型 泛型可以看作是一个变量，用来接收数据类型 E e；Element元素 T t；Type类型 创建集合对象的时候，就会确定泛型的数据类型优点 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型 把运行期间异常ClassCastException，提升到了编译时期的编译失败 但是泛型是什么类型，只能存储什么类型的数据定义与使用 含有泛型的类 格式：123修饰符 class 类名&lt;泛型&gt;&#123; //...&#125; 含有泛型的方法 格式；123456789// 普通方法修饰符 &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123; 方法体;&#125;// 静态方法修饰符 static &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123; 方法体;&#125; 含有泛型的接口 格式； 123修饰符 interface 接口名&lt;泛型&gt;&#123; 抽象方法(泛型 参数名,...);&#125; 使用： 定义类时确定泛型的类型 始终不确定泛型的类型，直到创建对象时，确定泛型的类型泛型通配符 ？；代表任意的数据类型 使用： 不能创建对象使用 只能作为方法的参数使用 注意：泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 泛型的上限限定 ? extends E；代表使用的泛型只能是E的子类/本身 泛型的下限限定 ? super E；代表使用的泛型只能是E类型的父类/本身 List集合 java.util.List extends Collection List接口继承Collection接口特点 有序的集合，存储元素和取出元素的顺序是一致的 有索引，包含了一些带索引的方法 允许存储重复的元素常用方法 public void add(int index, E element)；将指定的元素，添加到该集合中的指定位置上 public E get(int index)；返回集合中指定位置的元素 public E remove(int index)；移除列表中指定位置的元素，返回的是被移除的元素 public E set(int index, E element)；用指定元素替换集合中指定位置的元素，返回以前在指定位置的元素 注意：操作索引的时候，一定要防止索引越界异常子类 ArrayList；List接口的数组实现，元素增删慢，查找快。此实现是不同步的（多线程）。 LinkedList；List接口的链表列表实现。元素添加快，查找慢。 双向链表 含有大量操作首尾元素的方法，因此不要使用多态 常用方法： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst() :返回此列表的第一个元素。 public E getLast() :返回此列表的最后一个元素。 public E removeFirst() :移除并返回此列表的第一个元素。 public E removeLast() :移除并返回此列表的最后一个元素。 public E pop() :从此列表所表示的堆栈处弹出一个元素。 public void push(E e) :将元素推入此列表所表示的堆栈。 public boolean isEmpty() ：如果列表不包含元素，则返回true。 Vector；单线程，与ArrayList原理一样，已被ArrayList替代 Set集合 java.util.Set extends Collection Set接口继承Collection接口特点 不允于存储重复的元素 原理；add方法会调用元素的hashCode方法和equals方法，判断元素值是否重复(前提；存储的元素必须重写hashCode和equals方法)，哈希值不同，直接存入集合，哈希值相同，比较equals，true为相同值，不存入集合 没有索引，没有带索引的方法，也不能使用普通的for循环遍历 子类HashSet 特点； 由哈希表支持，不保证迭代顺序 是一个无序的集合，存储元素和取出元素的顺序有可能不一致 底层是一个哈希表结构(查询速度快) 哈希值； 是一个十进制的整数，由系统随机给出(对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址) 在Object类中由一个方法，可以获取对象的哈希值；int hashCode() hashCode()；public native int hashCode()，native代表该方法调用的是本地操作系统的方法 String类的哈希值；String类重写了Object类的hashCode()方法（”重地和通话”哈希值相同） 数据结构； 哈希表； jdk1.8版本之前；哈希表= 数组+链表 jdk1.8版本之后；哈希表=数组+链表+红黑树（提高了查询速度） 存储数据到集合中(先计算元素的哈希值) 把元素进行分组，相同哈希值链接到一起 哈希冲突：元素不同，哈希值相同 如果链表的长度超过8位，那么就会把链表转换为红黑树 存储自定义类型元素 重写hashCode和equals方法 LinkedHashSet java.util.LinkedHashSet extends HashSet,继承父类HashSet 可预知迭代顺序的Set接口的哈希表和链接列表实现 底层是一个哈希表（数组+链表/红黑树）+链表；多了一条链表记录元素的存储顺序，保证元素有序 可变参数 JDK1.5之后出现的新特性 使用前提；当前方法的参数列表数据类型已经确定，但是参数的个数不确定，使用可变参数 格式；修饰符 返回值类型 方法名(数据类型...变量名){} 原理；可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个,1,2…多个 注意； 一个方法的参数列表，只能有一个可变参数 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾 终极写法；(Object...obj) Collections工具类 java.util.Collections；集合工具类常用方法 public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T...elements)；往集合中添加一些元素 public static void shuffle(List&lt;?&gt; list)；打乱集合顺序 public static &lt;T&gt; void sort(List&lt;T&gt; list)；将集合中元素按照默认规则（升序）排序 public static &lt;T&gt; void sort(List&lt;T&gt; list ,Comparetor&lt;? super T&gt;)；将集合中元素按照指定规则排序 注意； sort(List&lt;T&gt; list)被排序的集合里面存储的元素，必须实现Comparable接口，重写接口中的compareTo()定义排序规则 Comparable接口的排序规则；自己(this)-参数；升序 Comparator和Comparable的区别 Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法 Comparator；找一个第三方的裁判 Comparator排序规则；o1-o2升序，o2-o1降序 Map集合 java.util.Map&lt;k,v&gt; 特点； Map集合是一个双列集合，一个元素包含两个值(一个key,一个value) Map集合中的元素，key和value的数据类型可以相同，也可以不同 Map集合中的元素，key是不允许重复的，value是可以重复的 Map集合中的元素，key和value是一一对应的 和Collection的区别： Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 Map常用子类 HashMap&lt;K,V&gt;； HashMap底层是哈希表，查询速度快，元素的存储顺序不能保证一致 为了保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法 JDK1.8之前；数组+单向链表 JDK1.8之后；数组+单向链表/红黑树（链表的长度超过8时） LinkedHashMap&lt;K,V&gt;； 是HashMap的子类，底层是哈希表+链表 是一个有序的集合，存储元素和取出元素的顺序是一致的，需要重写hashCode()、equals()方法 注意；Map接口中的集合都有两个泛型变量&lt;K,V&gt;，在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 Map常用方法 public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值V: 存储键值对的时候，key不重复，返回值V是null 存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值V: key存在，返回被删除的值 key不存在，返回null public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值V: key存在，返回对应value值 key不存在，返回null boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map遍历key找value方式 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keySet() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) Entry键值对对象 Map.Entry&lt;K,V&gt;；在Map接口中有一个内部接口Entry 作用；当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键与值得映射关系） Entry对象的常用方法； public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 HashMap存储自定义类型键值 Map集合保证Key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一 LinkedHashMap&lt;K,V&gt; LinkedHashMap&lt;K,V&gt;继承HashMap&lt;K,V&gt; 底层原理；哈希表+链表（记录顺序） HashTable&lt;K,V&gt; 底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢 HashTable不能存null值,null键 HashTable和Vector在jdk1.2之后被取代（HashMap,ArrayList） HashTable的子类Properties依然在使用 JDK9对集合添加的优化 JDK9的新特性； List接口、Set接口、Map接口；增加了一个静态方法of，可以给集合一次性添加多个元素 前提；集合中存储的元素的个数已经确定，不再改变 注意； of方法值适用于List、Set、Map接口，不适用于接口的实现类 of方法的返回值是一个不能改变的集合，集合不能再使用add、put方法添加元素，会抛出异常 Set接口和Map接口再调用of方法的时候，不能有重复的元素，否则会抛出异常 Debug调试 Debug调试程序； 可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug 使用方式； 在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里） 右键，选择Debug执行程序 执行程序； f8；逐行执行程序 f7；进入到方法中 shift+f8；跳出方法 f9；跳到下一个断点，如果没有下一个断点，那么就结束程序 ctrl+f2；退出Debug模式，停止程序 Console；切换到控制台 异常与多线程异常 异常；程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止 异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象，Javac处理异常的方式是中断处理异常体系 Throwable；Java.lang.Throwable Error；工程师无法处理，只能尽力避免 Exception；编译期异常，由于使用不当导致，可以避免 RuntimeException；运行期异常,Java程序运行过程中出现的问题 异常处理 常用关键字；try,catch,finally,throw,throws throw 在指定的方法中抛出指定的异常 格式；throw new xxxException(&quot;异常产生的原因&quot;) 注意； throw关键字必须写在方法内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，(运行期异常)可以不处理，默认交给JVM处理（打印异常对象，中断程序） throw关键字后边创建的是编译异常，我们就必须处理这个异常，要么throw,要么try...catch 声明异常throws 异常处理的第一种方式，交给别人处理 当方法内部抛出异常对象的时候，必须处理这个异常对象 可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理 格式； 12345修饰符 返回值 方法名(参数列表) throws AAAException, BBBException...&#123; throw new AAAException("产生原因"); throw new BBBException("产生原因"); ...&#125; 注意； throws关键字必须写在方法声明处 throws关键字后边声明的异常必须是Exception或者是Exception的子类 方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常。（如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可） 调用了一个声明抛出异常的方法，我们就必须处理声明的异常。（要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM，要么try...catch自己处理异常） 捕获异常try…catch 格式； 123456789try&#123; 可能产生异常的代码&#125;catch(异常类型 变量名)&#123; //用来接收try中抛出的异常对象 处理异常的代码（一般把异常信息记录到一个日志中）&#125;...catch(异常类型 变量名)&#123;&#125; 注意； try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try…catch之后的代码 如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑 Throwable常用方法 public void printStackTrace()；打印异常的详细信息 public String getMessage()；获取发生异常的原因 public String toString()；获取异常的类型和异常描述信息（不用） finally代码块 格式 1234567try&#123; 可能发生异常的代码&#125;catch(异常类型 变量名)&#123;&#125;finally&#123; 无论是否出现异常都会执行&#125; 注意； finally 不能单独使用，必须和try一起使用 finally 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源（IO） 异常的注意事项 多个异常使用捕获该如何处理 多个异常分别处理 多个异常一次捕获，多次处理 注意；一个try,多个catch,如果catch定义的异常变量，具有父子类的关系，子类的异常变量必须写在上面，否则会报错 多个异常一次捕获（catch异常对象的父类），一次处理 如果finally有return语句,永远返回finally中的结果,避免该情况 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类重写父类方法时 抛出和父类相同的异常 抛出父类异常的子类异常 不抛 父类没有抛出异常，子类也不能抛出异常，如果出现异常，只能捕获处理，不可抛出 自定义异常类 格式 12345public class XXXException extends Exception|RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法&#125; 注意； 自定义异常类一般都是Exception结尾，说明该类是一个异常类 自定义异常类，必须的继承Exception或者RuntimeException 继承Exception；自定义的异常类是一个编译器异常，如果方法内抛出了编译器异常，必须处理这个异常，要么抛出要么捕获 继承RuntimeException；自定义的异常类是一个运行期异常，无需处理，交给JVM（中断处理） 多线程并发与并行 并发；指两个或多个事件在同一个时间段内发生(交替执行) 并行；指两个或多个事件在同一时刻发(同时发生)线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度； 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的是抢占式调度 单线程程序：Java程序中只有一个线程 主线程：执行主（main）方法的线程创建线程类方式一：创建Thread类的子类 java.lang.Thread；描述线程的类，要实现多线程程序，必须继承Thread类 实现步骤： 创建一个Thread子类 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程做什么） 创建Thread类的子类对象 调用Thread类中的方法start()方法，开启新的线程（开辟新的栈空间），执行run方法方式二：实现Runnable接口 java.lang.Runnable 实现步骤： 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法实现Runnable接口创建多线程的好处 避免了单继承的局限性 一个类只能继承一个类，类继承了Thread类就不能继承其他的类，实现Runnable接口，还可以继承其他的类，实现其他的接口 增强了程序的扩展性，降低了程序的耦合性（解耦） 实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离(解耦)。实现类中，重写了run方法：用来设置线程任务；创建Thread类对象，调用start()方法：用来开启新线程 Thread类 构造方法 常用方法 public String getName()；获取当前线程名称 public void start()；导致此线程开始执行，Java虚拟机调用此线程的run方法 public void run()；此线程要执行的任务在此处定义代码 public static Thread currentThread()；返回当前正在执行的线程对象的引用 public static void sleep(long millis)；使当前正在执行的线程以指定的毫秒数暂停 设置线程名称 使用Thread类中的方法void setName(String name) 创建一个带参数的构造方法，参数传递线程的名称，调用父类的带参构造方法（super(name)）,把线程名称传递给父类，让父类（Thread）给子线程改名字（Thread(String name)） 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。匿名内部类方式实现线程的创建 格式： 1234new 父类/接口（）&#123; @Override 重写父类/接口中的方法&#125; eg: 123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 线程任务 &#125; &#125;).start(); 线程安全线程同步 当使用多线程访问同一资源的时候，多个线程对资源有写操作，就容易出现线程安全问题 Java提供了同步机制（Synchronized）解决线程同步机制同步代码块 格式： 123synchronized(锁对象)&#123; 需要同步操作的代码&#125; 注意； 同步代码块中的锁对象，可以使用任意的对象 必须保证多个线程使用的锁对象是同一个 锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行，其他线程被阻塞（BLOCKED） 频繁的上锁、解锁会降低程序效率，但是提供程序安全性 同步方法 使用synchronized修饰的方法，就叫同步方法 格式： 123public synchronized 返回值类型 方法名()&#123; 可能会产生线程安全问题的代码&#125; 同步方法也会把方法内部打代码锁住 同步锁是谁?对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 Lock锁 java.util.concurrent.locks.Lock Lock 实现了比 synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象 创建对象 Lock 锁名 = new ReentrantLock(); 常用方法； public void lock() :加同步锁。 public void unlock() :释放同步锁 线程状态 java.lang.Thread.State六种状态| 线程状态 | 导致状态发生的条件 ||—|—||NEW(新建)|线程刚被创建，但是并未启动。还没调用start方法||Runnable(可运行)|线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于CPU||Blocked(锁阻塞)|当一个线程试图获取一个对象锁，而对象锁被其他的线程持有，则该线程进入Blocked状态；当线程持有锁时，该线程变成Runnable状态||Waiting(无限等待)|一个线程在等待另一个线程执行（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒||TimedWaiting(计时等待)|同waiting状态，有几个方法有超时参数，调用他们将进入TimeWaiting状态，这一状态将一致保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有：Thread.sleep(),Object.wait()||Teminated(被终止)|因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡|Timed Waiting 计时等待 Thread.sleep(long m)；强制当前正在执行的线程休眠，线程进入Runnable/Blocked状态 锁对象.wait(long m)；在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程进入Runnable/Blocked状态 注意；sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。Blocked 锁阻塞 线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态Waiting 无限等待 等待唤醒 只有锁对象才能调用void wait()和void notify()方法 void notifyAll()；全部唤醒 等待唤醒机制线程间通信 多个线程在处理同一个资源，但是处理的动作（线程的任务）却不同 多个线程并发执行，CPU默认随机切换线程，为了让他们有规律执行，需要进行协调通信 等待唤醒机制；使各个线程能有效利用资源等待唤醒机制 多个线程间的一种协作机制 wait/notify就是线程间的一种协作机制 等待唤醒中的方法： wait：线程不再活动，不再参与调度，进入wait set中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：选取所通知对象的 wait set中的一个线程释放 notifyAll；释放所通知对象的 wait set上的全部线程。 注意： wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法 线程池 线程池；可以容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源 优点； 降低资源消耗 提高响应速度 提高线程的可管理性 线程池的使用 jdk1.5之后提供 java.util.concurrent.Executors；线程池的工厂类，用来生成线程池 Executors类中的静态方法； static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用固定线程数的线程池 参数；int nThreads；创建线程池中包含的线程数量 返回值；ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口接收) java.util.concurrent.ExecutorService；线程池接口 用来从线程池中获取线程，调用start()方法，执行线程任务 submit(Runnable task)提交一个Runnable任务用于执行 关闭/销毁线程池的方法 void shutdown() 线程池的使用步骤 使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类，实现Runnable接口，重写run方法，设置线程任务 调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法 调用ExecutorService中的方法shutdown销毁线程池（不建议执行） Lambda表达式函数式编程思想 面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程Lambda Java8 实现多线程：12345678910// 匿名内部类实现多线程new Thread(new Runnable()&#123; @Override public void run()&#123; 线程任务 &#125; &#125;).start();// Lambda表达式实现多线程new Thread(()-&gt;&#123;线程任务&#125;).start();//启动线程 Lambda表达式标准格式 组成； 一些参数 一个箭头 一段代码 格式； (参数列表)-&gt;{一些重写方法的代码} 解释； ()；接口中抽象方法的参数列表，没有参数就空着，有参数就写处参数，多个参数用逗号分隔 -&gt;；床底的意思，把参数传递给方法体{} {}；重写接口的抽象方法的方法体 Lambda省略格式 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为函数式接口 File类与IO流File类概述 java.io.File是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作 File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法静态方法 static String pathSeparator ；与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 static char pathSeparatorChar ；与系统有关的路径分隔符。 static String separator ；与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 路径不要写死，win和分隔符不同eg:&quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a.txt&quot; static char separatorChar ；与系统有关的默认名称分隔符。 路径 绝对路径；是一个完整的路径，以盘符开始的路径 相对路径；是一个简化的路径，相对指的是相对于当前项目的根目录 注意： 路径不区分大小写 路径中的文件名称分隔符windows用的是反斜杠，但反斜杠是转义字符，所以两个反斜杠菜表示一个普通的反斜杠构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 String pathname：字符串的路径名称 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的File实例。 String parent 父路径，String child 子路径 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的File实例。 File parent 父路径是File类，可以使用一些方法，String child 注意； 路径可以是文件结尾，也可以是文件夹结尾 路径可以是相对路径，也可以是绝对路径 路径可以是不存在的 创建File对象，只是把字符串路径封装成File对象，不考虑路径的真实情况获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。不存在，返回0。判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 文件不存在，创建文件，返回true,文件存在，创建失败，返回false 创建文件的路径必须存在，否则会抛出异常（IOException） public boolean mkdir() ：创建由此File表示的目录。(单级) 只会创建目录，与名称是否存在后缀无关 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录（多级） public boolean delete() ：删除由此File表示的文件或目录。 删除成功，返回true,文件夹中有内容，不会删除，返回flase，构造方法中路径不存在，返回false delete方法是直接在硬盘删除文件/文件夹，不走回收站，需要谨慎 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 list方法和listFiles方法遍历的是构造方法中给出的目录 如果构造方法中给出的目录的路径不存在，会抛出空指针异常 如果构造方法中给出的路径不是一个目录，也会抛出空指针异常 文件过滤器FileFilter java.io.FileFilter接口；用于抽象路径名（File对象）的过滤器 作用；用来过滤文件（File对象） 抽象方法；用来过滤文件的方法 boolean accept(File pathname)；测试指定抽象路径名是否应该包含在某个路径名列表中FilenameFilter java.io.FilenameFilter接口；实现此接口的类实例可用于过滤文件名 作用；用于过滤文件名 抽象方法；用来过滤文件的方法 boolean accept(File dir, String name)；测试指定文件是否应该包含在某一文件列表中 参数； File dir；构造方法中传递的被遍历的目录 String name；使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称 注意；两个过滤器接口没有实现类，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤规则 IO流IO分类 数据流向： 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存中写出到其他设备上的流。 数据类型； 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1字符=2字节 1字节=8位 顶级父类： ||输入流|输出流| |—|—|—| |字节流|字节输入流InputStream|字节输出流OutputStream| |字符流|字符输入流Reader|字符输出流Writer| 字节流字节输出流 java.io.OutputStream；抽象类表示字节输出流的所有类的超类 常用方法； public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 注意；当完成流的操作时，必须调用此方法，释放系统资源 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流（以二进制存入）。 如果写的第一个字节是正数（0-127）,那么显示的时候会查询ASCII表 如果写的第一个字节是负数，那第一个字节回合第二个字节，两个字节组成一个中文显示，查询系统默认码表（GBK） public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 FileOutputStream类： 构造方法： public FileOutputStream(File file) ：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name) ： 创建文件输出流以指定的名称写入文件。 注意；当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 写入数据的原理 内存–&gt;硬盘 Java抽象–&gt;JVM–&gt;OS–&gt;OS调用写数据的方法–&gt;把数据写入到文件中数据追加续写 public FileOutputStream(File file, boolean append) ： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append) ： 创建文件输出流以指定的名称写入文件 boolean append:追加写开关 true：创建对象不会覆盖原文件，继续在文件的末尾追加写数据 false；创建一个新文件，覆盖源文件 换行写 Windows系统里，换行符号是\r\n 字节输入流 java.io.InputStream；抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中 常用方法； public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read() ： 从输入流读取数据的下一个字节。 public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 byte[]；起到缓冲作用，存储每次读取到的多个字节，一般定义为1024(1kb)或1024的整数倍 返回值int ；每次读取的有效字节个数 FileInputStream类 java.io.FileInputStream；从文件中读取字节 构造方法； FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。读取数据的原理 硬盘-&gt;内存 java程序-&gt;JVM-&gt;OS-&gt;OS读取数据的方法-&gt;读取文件关于中文 1个中文： GBK；占用2个字节 UTF-8；占用3个字节 字符流字符输出流 java.io.Writer； 常用方法： void write(int c) 写入单个字符。void write(char[] cbuf) 写入字符数组。- abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str) 写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush() 刷新该流的缓冲。void close() 关闭此流，但要先刷新它。 FileWriter extends OutputStreamWriter extends Writer； 构造方法； FileWriter(File file) ： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName) ： 创建一个新的 FileWriter，给定要读取的文件的名称 使用步骤； 创建FileWriter对象，构造方法中绑定要写入数据的目的地 使用FileWriter中的方法write，把数据写入到内存缓冲区中（字符转字节的过程） 使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 释放资源(会先把内存缓冲区的数据刷新到文件中) 字符输入流 java.io.Reader；抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。 常用方法： public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read() ： 从输入流读取一个字符。 public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 FileReader类 extends InputStreamReader extends Reader； 构造方法： FileReader(File file) ： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName) ： 创建一个新的 FileReader ，给定要读取的文件的名称 使用方法； 创建FileReader对象，构造方法中绑定要读取的数据源 使用FileReader对象中的方法read读取文件 释放资源 flush和close flush ：刷新缓冲区，流对象可以继续使用。 close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 注意 字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流IO异常处理 jdk1.7之前使用try…catch finally处理流中的异常 格式；12345678try&#123; 可能产生出异常的代码&#125;catch(异常类型 变量名)&#123; 异常的处理逻辑&#125;finally&#123; 一定会执行的代码 (资源释放)&#125; JDK7新特性：在try的后边可以增加一个(),在括号中可以定义流对象，那么这个流对象的作用域就在try中有效。try中的代码执行完毕，会自动把流对象释放，不用写finally 格式：12345try(定义流对象;定义流对象;...)&#123; 可能产生出异常的代码&#125;catch(异常类型 变量名)&#123; 异常的处理逻辑&#125; JDK9新特性；try的前面可以定义流对象，try后边的()中可以直接引入流对象的每次（变量名），在try代码执行完毕只会，流对象可以自动释放，不用写finally 格式：1234567A a = new A();B b = new B();try(a,b)&#123; 可能产生出异常的代码&#125;catch(异常类型 变量名)&#123; 异常的处理逻辑&#125; 属性集概述 java.util.Properties extends Hashtable&lt;K,V&gt; implements Map&lt;K,V&gt; Properties表示一个持久的属性集。Properties可保存在流中或从流中加载。 Properties集合是一个唯一和IO流相结合的集合 可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用 属性列表中每个键及其对应值都是一个字符串：Properties集合是一个双列集合，key和value默认都是字符串Properties类 构造方法： public Properties()；创建一个空的属性列表 常用方法： public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合 与流相关的方法 void store(OutputStream out, String comments)；以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。 void store(Writer writer, String comments)；以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符。 参数； OutputStream out；字节输入流，不能写入中文 Writer writer；字符输出流，可以写中文 String comments；注释，用来解释说明保存的文件是做什么的，不能使用中文，默认unicode编码，一般使用””空字符串 void load(InputStream inStream) ；从输入流中读取属性void列表（键和元素对）。 void load(Reader reader) ；按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。 注意； 存储键值对的文件中，键与值默认的链接符号可以使用=，空格（其他符合） 存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取 存储键值对的文件中，键与默认值都是字符串，不用加引号 缓冲流 字节缓冲流： BufferedInputStream ， BufferedOutputStream 字符缓冲流： BufferedReader ，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 字节缓冲流 BufferedOutputStream；字节缓冲输出流 java.io.BufferedOutputStream.extends.OutputStream 构造方法； public BufferedOutputStream(OutputStream out)； 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 public BufferedOutputStream(OutputStream out, int size)；创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流 使用方法； 创建FileOutputStream对象，构造方法中绑定要输出的目的地 创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据，刷新到文件中 释放资源（会先调用flush方法刷新的数据，第4步可以省略） BufferedInputStream；字节缓冲输入流 java.io.BufferedInputStream.extends.InputStream 构造方法； public BufferedInputStream(InputStream in)； 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 public BufferedInputStream(InputStream in, int size)；创建具有指定缓冲区大小的BufferedInputStream并保存其参数，即输入流 使用方法； 创建FileInputStream对象，构造方法中绑定要读取的数据源 创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象效率 使用BufferedInputStream对象中的方法read，读取文件 释放资源（会先调用flush方法刷新的数据，第4步可以省略） 字符缓冲流 BufferedWriter；字符缓冲输出流 java.io.BufferedWriter.extends.Writer 构造方法； public BufferedWriter(Writer out)； 创建一个使用默认大小输出缓冲区的缓冲字符输出流 public BufferedWriter(Writer out, int size)；创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流 特有的成员方法； void newLine()；写入一个行分隔符。会根据不同的操作系统，获取不同的行分隔符 使用方法； 创建FileWriter对象，构造方法中绑定要输出的目的地 调用字符缓冲输出流的方法write，吧数据写入到内存缓冲区中 调用字符缓冲输出流中的方法flush，把内存缓冲区中的数据，刷新到文件中 释放资源 BufferedReader；字符缓冲输入流 java.io.BufferedReader.extends.Reader 构造方法； public BufferedReader(Reader in)； 创建一个使用默认大小输入缓冲区的缓冲字符输入流 public BufferedReader(Reader in, int size)；创建一个使用指定大小输入缓冲区字符输入流 特有的成员方法； String readLine()；读取一个文本行，读取一行数据 行的终止符号；通过下列字符之一即可认为某行已终止（换行：\n,回车；\r,或回车后直接跟着换行\r\n） 返回值；包含该行内容的字符串，不包含任何终止符，如果已到达流末尾，则返回null 使用方法； 创建字符缓冲输入流对象，构造方法中传递字符输入流 使用字符缓冲输入流对象中的方法read/readLine读取文本 释放资源 转换流字符编码 字符编码 Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。字符集 字符集 Charset ：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。InputStreamReader类 字节–（解码）–&gt;字符 java.io.InputStreamReader extends Reader；从字节流到字符流的桥梁，它读取字节，并使用指定的字符集将其解码为字符 构造方法； InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。- InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。OutputStreamWriter类 字符–（编码）–&gt;字节 java.io.OutputStreamWriter extends Writer；从字符流到字节流的桥梁，使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法； OutputStreamWriter(OutputStream out) : 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream out, String charsetName) : 创建一个指定字符集的字符流。 序列化流 序列化；把对象以流的方式，写入到文件中保存，也叫写对象 反序列化；把文件中保存的对象，以流的方式读取出来，也叫读对象ObjectOutputStream类 序列化。Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法； public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 成员方法； void writerObject(Object obj)；将指定的对象写入ObjectOutputStream序列化操作 一个对象要想序列化，必须满足两个条件 该类必须实现 java.io.Serializable 接口， Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰（静态也不能被序列化）。 ObjectInputStream类 反序列化。将之前使用ObjectOutputStream序列化的原始数据恢复为对象 构造方法； public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。 成员方法； Object readObject()；从ObjectInputStream读取对象 反序列化操作 类必须实现Serializable 必须存在类对应的.class文件，如果找不到该类的class文件，则抛出一个ClassNotFoundException异常。 InvalidClassException； 当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 InvalidClassException 异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。 static final long serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配 打印流]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础-02(语法)]]></title>
    <url>%2F2019%2F12%2F31%2FC-%E5%9F%BA%E7%A1%80-02-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分类 值类型：存放到栈中，每次存取都会在内存中操作 引用类型：首先在栈中创建一个引用变量，绕后在堆中创建对象本身，再把这个对象所在内存的首地址赋给引用变量。 值类型- 整型 - 浮点型 - 字符型 - 布尔型 - 枚举型 整型- sbyte ：有符号，1字节， - byte ：无符号，1字节 - short ：有符号，2字节 - ushort ：无符号，2字节 - int ：有符号，4字节（C#整型 默认值） - uint : 无符号，4字节 - long : 有符号，8字节 - ulong : 无符号，8字节 浮点型- float ：单精度浮点，4字节，最多保留7位小数，123.45f/123.345F - double ： 双精度浮点，8字节，最多保留16位小数，默认double类型 字符型- char : 2字节，存放一字符、汉字,单引号表示，&apos;a&apos; 布尔型- bool : true/false 枚举型引用类型- 类 - 接口 - 数组 - 委托 - 字符串 类接口数组委托字符串- string ： 存放多个字符，双引号表示，“abc”]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令]]></title>
    <url>%2F2019%2F12%2F29%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git工作区域 远程仓库（Remote） 备份代码，实现代码的远程管理 仓库区/本地仓库（Respository） 确定的文件保存到仓库，成为一个新的版本，并且对他人可见 暂存区(Index/unStage) 暂存已经修改的文件，最后统一提交到git仓库 工作区（Workspace） 添加、编辑、修改文件 Git命令新建代码库 在当前目录新建一个Git代码库git init 新建一个目录，将其初始化为Git代码库git init [project-name] 下载一个项目git clone [url] 配置 显示当前配置git config --list 显示文件状态git status 增加/删除文件 添加当前目录所有文件(work)到暂存区(index)git add 添加指定文件到暂存区git add [filename] 代码提交 提交暂存区(index)到仓库（repo）git commit -m [Message提交描述] 分支 列出所有本地分支git branch 列出所有远程分支git branch -r 远程同步 更新远程仓库git remote update 取回远程仓库的变化，并与本地分支合并git pull [remote][branch] 上传本地指定分支到远程仓库git push [remote][branch]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础-01]]></title>
    <url>%2F2019%2F12%2F29%2FC-%E5%9F%BA%E7%A1%80-01%2F</url>
    <content type="text"><![CDATA[C# 基础C# 是什么？- MicroSoft开发。创始人Anders - 面向对象编程 C# 的特点？- 简单、安全 - 面向对象 - 封装：将代码看作一个整体，只提供对象名和参数，提高安全性 - 继承：C#仅支持单继承 - 多态：通过继承和实现接口的方式，让类或接口中的成员表现出不同作用 - 跨平台 - 开发多种类型的程序 C# 和 Java、C++的区别C# 和 .NET- .NET是一个开发平台，而C#是一种在.NET开发平台上使用的编程语言 - .NET框架是一个多语言组件和执行环境，它提供一个跨语言的统一编程环境 - .NET框架的目的是便于开发人员容易建立Web应用程序和Web服务，使得Internet上的各应用程序之间可以使用Web服务进行沟通 .NET Framework定义一个可以快速开发、部署网站服务及应用程序的开发平台，是Windows中的一个组件 - 公共语言运行时（CLR）虚拟系统 - .NET Framework类库 优点- 提供标准的面向对象开发环境 - 提供优化的代码执行环境、兼容性高 - 使用JIT(just in time)技术，提高代码运行速度 体系结构1. 编程语言：C#、VB、C++、JScript 2.Common Language Specification(CLS):公共语言运行规范，定义一组规则：可以通过不同的编程语言来创建Windows应用程序、ASP.NET网站程序以及在.NET Framework中所有支持的程序。 3.Framework Class Library(FCL)：在FCL中包括Windows Forms（窗体程序）、ASP.NET(网站程序)、WPF(windows界面程序的框架)、WCF(Windows平台上的工作流程序)等所用到的类库文件。 4.Common Language Runtime(CLR)：.NET Framework的基础，用户可以将CLR看作一个在执行时管理代码的代码，它提供内存管理、线程管理和远程处理等核心服务，并且还强制实施严格类型安全以及可靠性的管理。(类似Java虚拟机)，以CLR为目标的代码称为托管代码，不以CLR为目标的代码称为非托管代码。 5.Windows API、COM+ Service：application programming interface应用程序接口 6.OS]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#学习笔记(一)]]></title>
    <url>%2F2019%2F12%2F19%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[C#简介 Microsoft开发 面向对象 结构化 C# 功能 布尔条件（Boolean Conditions) 自动垃圾回收(Automatic Garbase Collection) 标准库(Standard Library) 组件版本(Assembly Versioning) 属性(Properties）和事件（Events） 委托（Delegates) 和事件管理（Events Management) 泛型（Generics） 索引器(Indexers) 条件编译（Conditional Compilation) 简单的多线程(Multithreading) LINQ和Lambda表达式 集成Winodws C# 环境.Net框架（.Net Framework)用于开发 Windows应用程序 Web 应用程序 Web 服务]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO常用指令]]></title>
    <url>%2F2019%2F07%2F09%2FHEXO%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令 打开hexo目录：右键 git bash here 新建文章：hexo new 文章名称 新建草稿：hexo publish 文章名称 生成：hexo g 本地服务器：hexo s 部署：hexo d]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取猫眼电影排行榜]]></title>
    <url>%2F2019%2F01%2F18%2FPython%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C%E6%A6%9C%2F</url>
    <content type="text"><![CDATA[Python爬取猫眼电影排行榜 requests 获取 html lxml 解析 html xpath 定位元素 json 存文件 自己写的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import requestsfrom lxml import htmlimport json# 存储排名的列表rank_list = []def spider(offset): '''爬取猫眼电影排行榜''' url = "https://maoyan.com/board/4?offset=&#123;offset&#125;".format(offset=offset) html_data = requests.get(url).text # print(html_data) selector = html.fromstring(html_data) # print(selector) topper = selector.xpath('//dd') # print(topper) temp = [] for movie in topper: # 排名 rank = movie.xpath('i/text()')[0] print("排名:&#123;&#125;".format(rank)) # 电影名 name = movie.xpath('div/div/div/p/a/@title')[0] print("《&#123;&#125;》".format(name)) # 主演 star = movie.xpath('div/div/div/p[@class="star"]/text()')[0].strip() print(star) # 上映时间 time = movie.xpath('div/div/div/p[@class="releasetime"]/text()')[0] print(time) # 评分 score1 = movie.xpath('div/div/div/p[@class="score"]/i[1]/text()')[0] print("评分:&#123;&#125;".format(score1), end='') score2 = movie.xpath('div/div/div/p[@class="score"]/i[2]/text()')[0] print("&#123;&#125;".format(score2)) # 封面,网站两个&lt;img&gt;标签，两个src资源无法区分，通过pycharm获取html源代码,src标签是不一样的 image = movie.xpath('a[@class="image-link"]/img/@data-src')[0] print(image) print("-"*20) rank_list.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1+score2, 'image': image &#125;) temp.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1 + score2, 'image': image &#125;) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) return temp# 爬一次写一次，爬一页写一次，爬完写一次def write_to_file(content): '''写入文件''' with open('Maoyan_Rank.txt', 'a', encoding='utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False)+'\n')if __name__ == '__main__': #spider() for i in range(0, 100, 10): for item in spider(i): write_to_file(item) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) # f = open('Maoyan_Rank.txt', 'w') # f.write(item for item in rank_list) 书上用的正则表达式，这里跳过12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import requestsfrom lxml import htmlimport jsondef get_one_page(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' &#125; res = requests.get(url, headers=headers) # print(res) # get 请求 成功返回 状态码 = 200 if res.status_code == 200: # print(res.text) return res.text return Nonedef spider(offset): '''爬取猫眼电影排行榜''' url = "https://maoyan.com/board/4?offset=&#123;&#125;".format(offset) html_data = get_one_page(url) # print(html_data) selector = html.fromstring(html_data) # print(selector) topper = selector.xpath('//dd') # print(topper) rank_list = [] for movie in topper: # 排名 rank = movie.xpath('i/text()')[0] print("排名:&#123;&#125;".format(rank)) # 电影名 name = movie.xpath('div/div/div/p/a/@title')[0] print("《&#123;&#125;》".format(name)) # 主演 star = movie.xpath('div/div/div/p[@class="star"]/text()')[0].strip() print(star) # 上映时间 time = movie.xpath('div/div/div/p[@class="releasetime"]/text()')[0] print(time) # 评分 score1 = movie.xpath('div/div/div/p[@class="score"]/i[1]/text()')[0] print("评分:&#123;&#125;".format(score1), end='') score2 = movie.xpath('div/div/div/p[@class="score"]/i[2]/text()')[0] print("&#123;&#125;".format(score2)) # 封面,网站两个&lt;img&gt;标签，两个src资源无法区分，通过pycharm获取html源代码,src标签是不一样的 image = movie.xpath('a[@class="image-link"]/img/@data-src')[0] print(image) print("-"*20) rank_list.append(&#123; 'rank': rank, 'name': name, 'star': star, 'time': time, 'score': score1+score2, 'image': image &#125;) # print("一共爬取到&#123;&#125;部电影".format(len(rank_list))) # for movie in rank_list: # print(movie) return rank_listdef write_to_file(content): '''写入文件''' with open('result.txt', 'a', encoding='utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False)+'\n\n')if __name__ == '__main__': #spider() for i in range(0, 100, 10): for item in spider(i): write_to_file(item) 爬取结果输出结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703C:\ProgramData\Anaconda3\python.exe F:/Python+/Spider/Maoyan.py排名:1《霸王别姬》主演：张国荣,张丰毅,巩俐上映时间：1993-01-01评分:9.6https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c--------------------排名:2《肖申克的救赎》主演：蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿上映时间：1994-10-14(美国)评分:9.5https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@160w_220h_1e_1c--------------------排名:3《罗马假日》主演：格利高里·派克,奥黛丽·赫本,埃迪·艾伯特上映时间：1953-09-02(美国)评分:9.1https://p0.meituan.net/movie/54617769d96807e4d81804284ffe2a27239007.jpg@160w_220h_1e_1c--------------------排名:4《这个杀手不太冷》主演：让·雷诺,加里·奥德曼,娜塔莉·波特曼上映时间：1994-09-14(法国)评分:9.5https://p0.meituan.net/movie/e55ec5d18ccc83ba7db68caae54f165f95924.jpg@160w_220h_1e_1c--------------------排名:5《教父》主演：马龙·白兰度,阿尔·帕西诺,詹姆斯·肯恩上映时间：1972-03-24(美国)评分:9.3https://p1.meituan.net/movie/f5a924f362f050881f2b8f82e852747c118515.jpg@160w_220h_1e_1c--------------------排名:6《泰坦尼克号》主演：莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩上映时间：1998-04-03评分:9.5https://p1.meituan.net/movie/0699ac97c82cf01638aa5023562d6134351277.jpg@160w_220h_1e_1c--------------------排名:7《唐伯虎点秋香》主演：周星驰,巩俐,郑佩佩上映时间：1993-07-01(中国香港)评分:9.2https://p0.meituan.net/movie/da64660f82b98cdc1b8a3804e69609e041108.jpg@160w_220h_1e_1c--------------------排名:8《千与千寻》主演：柊瑠美,入野自由,夏木真理上映时间：2001-07-20(日本)评分:9.3https://p0.meituan.net/movie/b076ce63e9860ecf1ee9839badee5228329384.jpg@160w_220h_1e_1c--------------------排名:9《魂断蓝桥》主演：费雯·丽,罗伯特·泰勒,露塞尔·沃特森上映时间：1940-05-17(美国)评分:9.2https://p0.meituan.net/movie/46c29a8b8d8424bdda7715e6fd779c66235684.jpg@160w_220h_1e_1c--------------------排名:10《乱世佳人》主演：费雯·丽,克拉克·盖博,奥利维娅·德哈维兰上映时间：1939-12-15(美国)评分:9.1https://p0.meituan.net/movie/230e71d398e0c54730d58dc4bb6e4cca51662.jpg@160w_220h_1e_1c--------------------排名:11《天空之城》主演：寺田农,鹫尾真知子,龟山助清上映时间：1992评分:9.1https://p1.meituan.net/movie/ba1ed511668402605ed369350ab779d6319397.jpg@160w_220h_1e_1c--------------------排名:12《喜剧之王》主演：周星驰,莫文蔚,张柏芝上映时间：1999-02-13(中国香港)评分:9.2https://p1.meituan.net/movie/18e3191039d5e71562477659301f04aa61905.jpg@160w_220h_1e_1c--------------------排名:13《辛德勒的名单》主演：连姆·尼森,拉尔夫·费因斯,本·金斯利上映时间：1993-12-15(美国)评分:9.2https://p1.meituan.net/movie/39ed7a0941a3604bba78d299b11a18ce119679.jpg@160w_220h_1e_1c--------------------排名:14《大闹天宫》主演：邱岳峰,毕克,富润生上映时间：1965-12-31评分:9.0https://p1.meituan.net/movie/14a7b337e8063e3ce05a5993ed80176b74208.jpg@160w_220h_1e_1c--------------------排名:15《音乐之声》主演：朱莉·安德鲁斯,克里斯托弗·普卢默,埃琳诺·帕克上映时间：1965-03-02(美国)评分:9.0https://p1.meituan.net/movie/6bc004d57358ee6875faa5e9a1239140128550.jpg@160w_220h_1e_1c--------------------排名:16《剪刀手爱德华》主演：约翰尼·德普,薇诺娜·瑞德,黛安·韦斯特上映时间：1990-12-06(美国)评分:8.8https://p1.meituan.net/movie/0e91ffcfa7e53449216cc29ee8af513a75791.jpg@160w_220h_1e_1c--------------------排名:17《春光乍泄》主演：张国荣,梁朝伟,张震上映时间：1997-05-30(中国香港)评分:9.2https://p0.meituan.net/movie/ae7245920d95c03765fe1615f3a1fe3865785.jpg@160w_220h_1e_1c--------------------排名:18《美丽人生》主演：罗伯托·贝尼尼,尼可莱塔·布拉斯基,乔治·坎塔里尼上映时间：1997-12-20(意大利)评分:9.3https://p0.meituan.net/movie/43d259ecbcd53e8bbe902632772281d6327525.jpg@160w_220h_1e_1c--------------------排名:19《海上钢琴师》主演：蒂姆·罗斯,普路特·泰勒·文斯,比尔·努恩上映时间：1998-10-28(意大利)评分:9.2https://p1.meituan.net/movie/c15b7623cce2f51c75562a3baefe507b68290.jpg@160w_220h_1e_1c--------------------排名:20《黑客帝国》主演：基努·里维斯,凯瑞-安·莫斯,劳伦斯·菲什伯恩上映时间：2000-01-14评分:9.0https://p1.meituan.net/movie/d981a12f59d3cc92ff666094404ad8f0211220.jpg@160w_220h_1e_1c--------------------排名:21《加勒比海盗》主演：约翰尼·德普,凯拉·奈特莉,奥兰多·布鲁姆上映时间：2003-11-21评分:8.9https://p1.meituan.net/movie/b449893ebc63d5c54eb4a5b60341f334383831.jpg@160w_220h_1e_1c--------------------排名:22《指环王3：王者无敌》主演：伊莱贾·伍德,伊恩·麦克莱恩,丽芙·泰勒上映时间：2004-03-15评分:9.2https://p0.meituan.net/movie/932bdfbef5be3543e6b136246aeb99b8123736.jpg@160w_220h_1e_1c--------------------排名:23《哈利·波特与魔法石》主演：丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃特森上映时间：2002-01-26评分:9.1https://p1.meituan.net/movie/aacb9ed2a6601bfe515ef0970add1715623792.jpg@160w_220h_1e_1c--------------------排名:24《无间道》主演：刘德华,梁朝伟,黄秋生上映时间：2003-09-05评分:9.1https://p1.meituan.net/movie/0d93b5b585ce29c6688e43f3989fb41f86421.jpg@160w_220h_1e_1c--------------------排名:25《射雕英雄传之东成西就》主演：张国荣,梁朝伟,张学友上映时间：1993-02-05(中国香港)评分:8.9https://p1.meituan.net/movie/53b6f0b66882a53b08896c92076515a8236400.jpg@160w_220h_1e_1c--------------------排名:26《楚门的世界》主演：金·凯瑞,劳拉·琳妮,诺亚·艾默里奇上映时间：1998-06-01(美国)评分:8.9https://p0.meituan.net/movie/8959888ee0c399b0fe53a714bc8a5a17460048.jpg@160w_220h_1e_1c--------------------排名:27《蝙蝠侠：黑暗骑士》主演：克里斯蒂安·贝尔,希斯·莱杰,阿伦·伊克哈特上映时间：2008-07-18(美国)评分:9.3https://p0.meituan.net/movie/d12a1c198ad9ffac72b5db57feacb449294699.jpg@160w_220h_1e_1c--------------------排名:28《教父2》主演：阿尔·帕西诺,罗伯特·德尼罗,黛安·基顿上映时间：1974-12-12(美国)评分:9.0https://p1.meituan.net/movie/7bac8bfa6739c18620065132ce9c64fa85110.jpg@160w_220h_1e_1c--------------------排名:29《指环王2：双塔奇兵》主演：伊莱贾·伍德,伊恩·麦克莱恩,丽芙·泰勒上映时间：2003-04-25评分:9.1https://p0.meituan.net/movie/5cfa597a98b35ee4ee598695942641ba287922.jpg@160w_220h_1e_1c--------------------排名:30《机器人总动员》主演：本·贝尔特,艾丽莎·奈特,杰夫·格尔林上映时间：2008-06-27(美国)评分:9.3https://p1.meituan.net/movie/4592eef6b6dffcd1d950f55f41ab098f239816.jpg@160w_220h_1e_1c--------------------排名:31《天堂电影院》主演：菲利浦·诺瓦雷,赛尔乔·卡斯特利托,蒂兹亚娜·罗达托上映时间：1988-11-17(意大利)评分:9.2https://p1.meituan.net/movie/618e57ddb3173de6bbf2e278946b11f279679.jpg@160w_220h_1e_1c--------------------排名:32《活着》主演：葛优,巩俐,牛犇上映时间：1994-05-18(法国)评分:9.0https://p0.meituan.net/movie/4c41068ef7608c1d4fbfbe6016e589f7204391.jpg@160w_220h_1e_1c--------------------排名:33《拯救大兵瑞恩》主演：汤姆·汉克斯,马特·达蒙,汤姆·塞兹摩尔上映时间：1998-07-24(美国)评分:8.9https://p1.meituan.net/movie/779bcc212a50a2526343362778f6b63c334618.jpg@160w_220h_1e_1c--------------------排名:34《哈尔的移动城堡》主演：倍赏千惠子,木村拓哉,美轮明宏上映时间：2004-11-20(日本)评分:9.0https://p0.meituan.net/movie/0127b451d5b8f0679c6f81c8ed414bb2432442.jpg@160w_220h_1e_1c--------------------排名:35《阿凡达》主演：萨姆·沃辛顿,佐伊·索尔达娜,米歇尔·罗德里格兹上映时间：2010-01-04评分:9.1https://p1.meituan.net/movie/91f575ec93f019f428d1f33e3ceca7c5115495.jpg@160w_220h_1e_1c--------------------排名:36《盗梦空间》主演：莱昂纳多·迪卡普里奥,渡边谦,约瑟夫·高登-莱维特上映时间：2010-09-01评分:9.2https://p1.meituan.net/movie/2f344a9f9575edbcae9f0abe0578bc90339773.jpg@160w_220h_1e_1c--------------------排名:37《忠犬八公的故事》主演：Forest,理查·基尔,琼·艾伦上映时间：2010-03-12(英国)评分:9.3https://p0.meituan.net/movie/7787c10ad5e95b03cf83ef9473500d8e282796.jpg@160w_220h_1e_1c--------------------排名:38《幽灵公主》主演：松田洋治,石田百合子,田中裕子上映时间：1997-07-12(日本)评分:8.9https://p0.meituan.net/movie/6ab1882a217e848acceb240365043d53329196.jpg@160w_220h_1e_1c--------------------排名:39《搏击俱乐部》主演：爱德华·哈里森·诺顿,布拉德·皮特,海伦娜·伯翰·卡特上映时间：1999-10-15(美国)评分:8.8https://p1.meituan.net/movie/c5e76795bf7a78b12a2ffabb4a0c5c11112921.jpg@160w_220h_1e_1c--------------------排名:40《东邪西毒》主演：张国荣,梁朝伟,刘嘉玲上映时间：1994-09-17评分:8.8https://p1.meituan.net/movie/7e471a9171a410ebc9413b2f1de67afc130067.jpg@160w_220h_1e_1c--------------------排名:41《风之谷》主演：岛本须美,永井一郎,坂本千夏上映时间：1992评分:8.9https://p0.meituan.net/movie/4f9638ba234c3fb673f23a09968db875371576.jpg@160w_220h_1e_1c--------------------排名:42《疯狂原始人》主演：尼古拉斯·凯奇,艾玛·斯通,瑞安·雷诺兹上映时间：2013-04-20评分:9.5https://p1.meituan.net/movie/d5e5e53ef9bbd98223e83df261b51b84103223.jpg@160w_220h_1e_1c--------------------排名:43《当幸福来敲门》主演：威尔·史密斯,贾登·史密斯,坦迪·牛顿上映时间：2008-01-17评分:8.9https://p1.meituan.net/movie/5896de3c1474277730e321c9b1db04a9205644.jpg@160w_220h_1e_1c--------------------排名:44《V字仇杀队》主演：娜塔莉·波特曼,雨果·维文,斯蒂芬·瑞上映时间：2006-03-17(美国)评分:8.8https://p1.meituan.net/movie/4a4c84aa103ab47202f1aa907c5542a4128882.jpg@160w_220h_1e_1c--------------------排名:45《十二怒汉》主演：亨利·方达,李·科布,马丁·鲍尔萨姆上映时间：1957-04-13(美国)评分:9.1https://p0.meituan.net/movie/df15efd261060d3094a73ef679888d4f238149.jpg@160w_220h_1e_1c--------------------排名:46《放牛班的春天》主演：热拉尔·朱尼奥,让-巴蒂斯特·莫尼耶,玛丽·布奈尔上映时间：2004-10-16评分:8.8https://p0.meituan.net/movie/7cd18fcf0b4f9180500124711e81492994030.jpg@160w_220h_1e_1c--------------------排名:47《三傻大闹宝莱坞》主演：阿米尔·汗,黄渤,卡琳娜·卡普上映时间：2011-12-08评分:9.1https://p0.meituan.net/movie/4bb144bc0a674ba6908349018fd092e6330929.jpg@160w_220h_1e_1c--------------------排名:48《勇敢的心》主演：梅尔·吉布森,苏菲·玛索,帕特里克·麦高汉上映时间：1995-05-24(美国)评分:8.8https://p1.meituan.net/movie/f8e9d5a90224746d15dfdbd53d4fae3d209420.jpg@160w_220h_1e_1c--------------------排名:49《黑客帝国3：矩阵革命》主演：基努·里维斯,雨果·维文,凯瑞-安·莫斯上映时间：2003-11-05评分:8.8https://p1.meituan.net/movie/5ca6ffcbb994a51cd6215e7c4fff2d9b71039.jpg@160w_220h_1e_1c--------------------排名:50《速度与激情5》主演：范·迪塞尔,保罗·沃克,道恩·强森上映时间：2011-05-12评分:9.2https://p1.meituan.net/movie/1d0fa86bcf7a44484b9c16ac6af5be68191952.jpg@160w_220h_1e_1c--------------------排名:51《驯龙高手》主演：杰伊·巴鲁切尔,杰拉德·巴特勒,亚美莉卡·费雷拉上映时间：2010-05-14评分:9.0https://p1.meituan.net/movie/8194ae885ed9419aadf35c196af86ba4239039.jpg@160w_220h_1e_1c--------------------排名:52《少年派的奇幻漂流》主演：苏拉·沙玛,伊尔凡·可汗,塔布上映时间：2012-11-22评分:9.1https://p0.meituan.net/movie/34998e31c6d07475f1add6b8b16fd21d192579.jpg@160w_220h_1e_1c--------------------排名:53《神偷奶爸》主演：史蒂夫·卡瑞尔,杰森·席格尔,拉塞尔·布兰德上映时间：2010-07-09(美国)评分:9.0https://p0.meituan.net/movie/85c2bfba6025bfbfb53291ae5924c215308805.jpg@160w_220h_1e_1c--------------------排名:54《闻香识女人》主演：阿尔·帕西诺,克里斯·奥唐纳,加布里埃尔·安瓦尔上映时间：1992-12-23(美国)评分:8.8https://p0.meituan.net/movie/7cb7965469cb7ff95613714389f1ea3d87743.jpg@160w_220h_1e_1c--------------------排名:55《断背山》主演：希斯·莱杰,杰克·吉伦哈尔,米歇尔·威廉姆斯上映时间：2006-01-13(美国)评分:9.0https://p0.meituan.net/movie/e71affe126eeb4f8bfcc738cbddeebc8288766.jpg@160w_220h_1e_1c--------------------排名:56《飞屋环游记》主演：爱德华·阿斯纳,乔丹·长井,鲍勃·彼德森上映时间：2009-08-04评分:8.9https://p0.meituan.net/movie/47dd790e19dad72b50580641de5608c5199014.jpg@160w_220h_1e_1c--------------------排名:57《大话西游之月光宝盒》主演：周星驰,莫文蔚,吴孟达上映时间：2014-10-24评分:9.6https://p0.meituan.net/movie/92eb862c42c49f8e41e459c369c4512b226610.jpg@160w_220h_1e_1c--------------------排名:58《飞越疯人院》主演：杰克·尼科尔森,路易丝·弗莱彻,威尔·萨姆森上映时间：1975-11-19(美国)评分:8.8https://p1.meituan.net/movie/4dddd98730274c3b1464ff0a0ad195e5233381.jpg@160w_220h_1e_1c--------------------排名:59《怦然心动》主演：玛德琳·卡罗尔,卡兰·麦克奥利菲,艾丹·奎因上映时间：2010-08-06(美国)评分:8.9https://p0.meituan.net/movie/457a35fda360cb72090fa6dcbd1db3c1275333.jpg@160w_220h_1e_1c--------------------排名:60《美国往事》主演：罗伯特·德尼罗,詹姆斯·伍兹,伊丽莎白·麦戈文上映时间：1984-02-17(美国)评分:9.1https://p1.meituan.net/movie/92198a6fc8c3f5d13aa1bdf203572c0f99438.jpg@160w_220h_1e_1c--------------------排名:61《致命魔术》主演：休·杰克曼,克里斯蒂安·贝尔,迈克尔·凯恩上映时间：2006-10-20(美国)评分:8.8https://p1.meituan.net/movie/75c0d3eb584be030a01f2e26741a8f41251454.jpg@160w_220h_1e_1c--------------------排名:62《鬼子来了》主演：姜文,姜宏波,陈强上映时间：2000-05-12(法国戛纳)评分:8.9https://p1.meituan.net/movie/0b507aa44c4dfbbcc91949b69b1b39a168922.jpg@160w_220h_1e_1c--------------------排名:63《无敌破坏王》主演：约翰·C·赖利,萨拉·西尔弗曼,简·林奇上映时间：2012-11-06评分:9.1https://p0.meituan.net/movie/fcc17667b8343131101eeb4c67d90bf9150883.jpg@160w_220h_1e_1c--------------------排名:64《美丽心灵》主演：罗素·克洛,詹妮弗·康纳利,艾德·哈里斯上映时间：2001-12-21(美国)评分:8.8https://p0.meituan.net/movie/7b7d1f8aa36d7a15463ce6942708a1a7265296.jpg@160w_220h_1e_1c--------------------排名:65《蝙蝠侠：黑暗骑士崛起》主演：克里斯蒂安·贝尔,迈克尔·凯恩,加里·奥德曼上映时间：2012-08-27评分:8.9https://p1.meituan.net/movie/96bb58f3e9d213fb0438987d16d27561379209.jpg@160w_220h_1e_1c--------------------排名:66《夜访吸血鬼》主演：汤姆·克鲁斯,布拉德·皮特,克尔斯滕·邓斯特上映时间：1994-11-11(美国)评分:8.8https://p0.meituan.net/movie/7ec873ba943f13e3c63789d899bd0e23256871.jpg@160w_220h_1e_1c--------------------排名:67《倩女幽魂》主演：张国荣,王祖贤,午马上映时间：2011-04-30评分:9.2https://p1.meituan.net/movie/6d0510f326bf145dcf49a901fb949b77278838.jpg@160w_220h_1e_1c--------------------排名:68《哈利·波特与死亡圣器（下）》主演：丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃特森上映时间：2011-08-04评分:9.0https://p1.meituan.net/movie/68fa7db99e958c47d7aa07d015845a6f335154.jpg@160w_220h_1e_1c--------------------排名:69《本杰明·巴顿奇事》主演：布拉德·皮特,凯特·布兰切特,塔拉吉·P·汉森上映时间：2008-12-25(美国)评分:8.8https://p0.meituan.net/movie/2526f77c650bf7cf3d5ee2dccdeac332244951.jpg@160w_220h_1e_1c--------------------排名:70《钢琴家》主演：艾德里安·布洛迪,艾米莉娅·福克斯,米哈乌·热布罗夫斯基上映时间：2002-09-25(法国)评分:8.8https://p1.meituan.net/movie/484171372de45945e8bbbcc97db57e09136701.jpg@160w_220h_1e_1c--------------------排名:71《触不可及》主演：弗朗索瓦·克鲁塞,奥玛·希,安娜·勒尼上映时间：2011-11-02(法国)评分:9.1https://p0.meituan.net/movie/7874ba1378033b0b491df0cc56c43d25221208.jpg@160w_220h_1e_1c--------------------排名:72《熔炉》主演：孔刘,郑有美,金智英上映时间：2011-09-22(韩国)评分:8.8https://p1.meituan.net/movie/4ad513be2e9419ec7d7d63ba8cc2b6cc134065.jpg@160w_220h_1e_1c--------------------排名:73《初恋这件小事》主演：马里奥·毛瑞尔,平采娜·乐维瑟派布恩,阿查拉那·阿瑞亚卫考上映时间：2012-06-05评分:8.8https://p1.meituan.net/movie/7ed07b8ea8c0e0d0c7b685d20e3ec64e232004.jpg@160w_220h_1e_1c--------------------排名:74《大话西游之大圣娶亲》主演：周星驰,朱茵,莫文蔚上映时间：2014-10-24评分:8.8https://p1.meituan.net/movie/dc2246233a6f5ac1e34c7176b602c8ca174557.jpg@160w_220h_1e_1c--------------------排名:75《新龙门客栈》主演：张曼玉,梁家辉,甄子丹上映时间：2012-02-24评分:8.8https://p0.meituan.net/movie/9e9f12cfc1f54c973dda6c85bd3a139d334520.jpg@160w_220h_1e_1c--------------------排名:76《甜蜜蜜》主演：黎明,张曼玉,曾志伟上映时间：2015-02-13评分:9.2https://p1.meituan.net/movie/8ad5a0f521fb15637dfdf9cab38d414453783.jpg@160w_220h_1e_1c--------------------排名:77《小鞋子》主演：默罕默德·阿米尔·纳吉,Kamal Mirkarimi,Behzad Rafi上映时间：1999-01-22(美国)评分:9.1https://p1.meituan.net/movie/bc7b6ababa54e11577d45c05e84a33af54072.jpg@160w_220h_1e_1c--------------------排名:78《素媛》主演：李来,薛耿求,严志媛上映时间：2013-10-02(韩国)评分:9.1https://p0.meituan.net/movie/4cc4c55c29b77b090485ce9943bf6f87274708.jpg@160w_220h_1e_1c--------------------排名:79《萤火之森》主演：内山昂辉,佐仓绫音,后藤弘树上映时间：2011-09-17(日本)评分:9.0https://p0.meituan.net/movie/5420be40e3b755ffe04779b9b199e935256906.jpg@160w_220h_1e_1c--------------------排名:80《时空恋旅人》主演：瑞秋·麦克亚当斯,多姆纳尔·格里森,比尔·奈伊上映时间：2013-09-04(英国)评分:8.9https://p0.meituan.net/movie/4abc8c932cfacfc0089e2883765d02d1295222.jpg@160w_220h_1e_1c--------------------排名:81《穿条纹睡衣的男孩》主演：阿沙·巴特菲尔德,维拉·法梅加,大卫·休里斯上映时间：2008-09-12(英国)评分:9.0https://p1.meituan.net/movie/a0e0426a4390f5ecb49d25770a184dc0150779.jpg@160w_220h_1e_1c--------------------排名:82《窃听风暴》主演：乌尔里希·穆埃,塞巴斯蒂安·科赫,马蒂娜·格德克上映时间：2006-03-23(德国)评分:9.0https://p0.meituan.net/movie/3985eaf3858bea0f2a3d966bf7ee2103178217.jpg@160w_220h_1e_1c--------------------排名:83《借东西的小人阿莉埃蒂》主演：志田未来,神木隆之介,大竹忍上映时间：2010-07-17(日本)评分:8.8https://p0.meituan.net/movie/ce262f261f69fc3d679020402336a4af270365.jpg@160w_220h_1e_1c--------------------排名:84《恐怖直播》主演：河正宇,李璟荣,李大为上映时间：2013-07-31(韩国)评分:8.8https://p0.meituan.net/movie/b5ff0216e689b3fcc065590c48cd5105255305.jpg@160w_220h_1e_1c--------------------排名:85《7号房的礼物》主演：柳承龙,郑镇荣,朴信惠上映时间：2013-01-23(韩国)评分:8.9https://p1.meituan.net/movie/6a6e74b2c289f9fa4433dd2dc04a7741331638.jpg@160w_220h_1e_1c--------------------排名:86《海豚湾》主演：里克·奥巴瑞,路易·西霍尤斯,哈迪·琼斯上映时间：2009-07-31(美国)评分:8.9https://p0.meituan.net/movie/7373dbba07b50ce6f24336edb96b2ea4271536.jpg@160w_220h_1e_1c--------------------排名:87《忠犬八公物语》主演：仲代达矢,春川真澄,井川比佐志上映时间：1987-08-01(日本)评分:9.0https://p1.meituan.net/movie/c835b3588d0061ed3b992388a0a96f15160913.jpg@160w_220h_1e_1c--------------------排名:88《上帝之城》主演：亚历桑德雷·罗德里格斯,艾莉丝·布拉加,莱安德鲁·菲尔米诺上映时间：2002-08-30(巴西)评分:8.9https://p1.meituan.net/movie/b553d13f30100db731ab6cf45668e52d94703.jpg@160w_220h_1e_1c--------------------排名:89《辩护人》主演：宋康昊,郭度沅,吴达洙上映时间：2013-12-18(韩国)评分:8.8https://p0.meituan.net/movie/8fabf3894b7d12d3d2f6e66404813670265761.jpg@160w_220h_1e_1c--------------------排名:90《七武士》主演：三船敏郎,志村乔,千秋实上映时间：1954-04-26(日本)评分:9.1https://p1.meituan.net/movie/73349facab53529ab9e079c6c8c7c059281729.jpg@160w_220h_1e_1c--------------------排名:91《英雄本色》主演：狄龙,张国荣,周润发上映时间：2017-11-17评分:9.2https://p0.meituan.net/movie/3e5f5f3aa4b7e5576521e26c2c7c894d253975.jpg@160w_220h_1e_1c--------------------排名:92《一一》主演：吴念真,金燕玲,李凯莉上映时间：2000-09-20(法国)评分:8.9https://p1.meituan.net/movie/2c0a5fedf4b43d142121b91c6ccabe1b59051.jpg@160w_220h_1e_1c--------------------排名:93《完美的世界》主演：凯文·科斯特纳,克林特·伊斯特伍德,T·J·劳瑟上映时间：1993-11-24(美国)评分:8.9https://p1.meituan.net/movie/30310858fdab34c7a17cfd7ec8ad8bfc112201.jpg@160w_220h_1e_1c--------------------排名:94《海洋》主演：雅克·贝汉,姜文,兰斯洛特·佩林上映时间：2011-08-12评分:9.0https://p0.meituan.net/movie/0018b57299d0d4540330a31244c880a9112971.jpg@160w_220h_1e_1c--------------------排名:95《爱·回家》主演：俞承豪,金艺芬,童孝熙上映时间：2002-04-05(韩国)评分:9.0https://p1.meituan.net/movie/36a893c53a13f9bb934071b86ae3b5c492427.jpg@160w_220h_1e_1c--------------------排名:96《黄金三镖客》主演：克林特·伊斯特伍德,李·范·克里夫,埃里·瓦拉赫上映时间：1966-12-23(意大利)评分:8.9https://p1.meituan.net/movie/9bff56ed3ea38bb1825daa1d354bc92352781.jpg@160w_220h_1e_1c--------------------排名:97《我爱你》主演：宋在浩,李顺才,尹秀晶上映时间：2011-02-17(韩国)评分:9.0https://p1.meituan.net/movie/ed50b58bf636d207c56989872a91f4cf305138.jpg@160w_220h_1e_1c--------------------排名:98《迁徙的鸟》主演：雅克·贝汉,Philippe Labro上映时间：2001-12-12(法国)评分:9.1https://p1.meituan.net/movie/a1634f4e49c8517ae0a3e4adcac6b0dc43994.jpg@160w_220h_1e_1c--------------------排名:99《阿飞正传》主演：张国荣,张曼玉,刘德华上映时间：2018-06-25评分:8.8https://p0.meituan.net/movie/885fc379c614a2b4175587b95ac98eb95045650.jpg@160w_220h_1e_1c--------------------排名:100《龙猫》主演：帕特·卡洛尔,蒂姆·达利,丽娅·萨隆加上映时间：2018-12-14评分:9.2https://p0.meituan.net/movie/c304c687e287c7c2f9e22cf78257872d277201.jpg@160w_220h_1e_1c--------------------Process finished with exit code 0 保存到txt文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <url>%2F2019%2F01%2F14%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[切片 产生列表的子集字符串、列表、元组都支持切片操作切片的语法：[起始 ： 结束 ：步长]左闭右开 步长表示选取的间隔 默认是 1 1234567字符串切片name = "abcdefghijk"print(name[4:6]) # 取下表4-6，也就是name[4],name[5]print(name[2:]) # 结束缺省，表示取下标为2开始到最后的字符print(name[:3]) # 开始缺省，表示取开始到下标为3之前的字符print(name[1:-1]) # 负数索引返回离列表末尾相应距离的元素print(name[::-1]) # 步长为负， 表示从后往前切片 1234列表切片cars = ['Audi', 'BMW', 'BenZi', 'Toyota']print(cars[::-1]) # 逆序输出列表,实际结构没有发生改变print(cars[1:3]) # 产生列表的子集，切片始于'BMW',终于‘Benzi’ 123456切片的应用# 实现 [1，2，3，4....100]变成[[1,2,3],[4,5,6],...]a = [x for x in range(1, 101)]print(a)b = [a[x:x+3] for x in range(0, len(a), 3)] # 产生列表的子集print(b) 可变的类型 ： 列表List 字典Dict 集合Set列表List1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 列表nameList = ['zhangsan', 'lisi', 1234]# 打印列表print(nameList)# 访问print(nameList[0])# for循环遍历for name in nameList: print(name)# while循环遍历i = 0while i &lt; len(nameList): print(nameList[i]) i += 1# 列表的相关操作# 1. 添加元素# append()A = ['zhangsan', 'lisi', 1234]temp = input("请输入学生姓名:")A.append(temp)print(A)# extend()可以将另一个元素逐一追加到列表中,append是整体添加a = [1, 2]b = [3, 4]a.append(b)print(a)a.extend(b)print(a)# insert() 在指定位置插入元素(位置，元素)c = [0, 1, 2]c.insert(1, '3')print(c)# 2.修改操作A = ['xiaoming', 'xiaohong', 1234]A[1] = '小红'print(A)# 3.查询# in / not in / index / count# innameList = ['xiaoming', 'xiaohong', 1234]findName = input("请输入要查找的姓名")if findName in nameList: print("你要找的人在列表中")else: print("没找到")#index 返回第一次出现的序号#count 返回出现的次数a = ['a', 'b', 'c', 'a', 'b']index = a.index('a')print(index)count = a.count('a')print(count)# 4.删除nameList = ['xiaoming', 'xiaohong', 1234]# del 根据下表删除del nameList[2]print(nameList)# popprint(nameList)nameList.pop()print(nameList)# remove 根据元素的值进行删除a = ['a', 'b', 'c', 'a', 'b']print(a)a.remove('a')print(a)# 排序a = [1, 3, 4, 2]b = [1, 3, 4, 2]# sort()正序a.sort()#a.reverse(sort=True)print(a)# reverse() 逆序 也可以写作sort(reverse=True)，反过来不可以b.sort(reverse=True)#b.reverse()print(a) 1234567891011121314151617181920212223242526# 一个学校，有三个办公室，8位老师等待分配工位，完成随机分配# 定义一个列表import stringimport random# 定义一个列表来保存3个办公室offices = [[], [], []]# 定义一个列表来保存8个教师姓名names = []for i in range(8): names.append(string.ascii_uppercase[i])for name in names: index = random.randint(0, 2) offices[index].append(name)# print(offices)# 遍历展示i = 1for tempNames in offices: print("办公室%d的人数为 %d : " % (i, len(tempNames)), end='') i += 1 for name in tempNames: print("%s" % name, end=' ') print() print('-'*30) 字典Dict12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 字典 &#123;key1: value1, key2: value2&#125;info = &#123;'name': '马云', id: 100, 'sex': 'm', 'address': '杭州'&#125;# 根据键 进行访问# key: valueprint(info[id])# 访问不存在的键会报错#print(info['age']) #keyError: 'age‘# 面向对象的访问, 若不存在，返回默认值age = info.get('age', 18)print(age)print(type(age))# 常见操作# 1. 查看info = &#123;'name': '西卡', 'age': 26&#125;print(info['age'])# 修改age = input("请输入年龄:")info['age'] = ageprint(info)# 添加 键不存在，就会新增这个元素add = input("请输入户籍所在地:")info['address'] = addprint(info)# 删除 del删除字典某个元素 clear()清空字典# del info['address']# print(info)# info.clear()# print(info)# 字典方法# len() 键值对个数 以列表方式储存print(len(info))# keys()返回所有键 values() 返回所有值 以列表方式储存print(info.keys())print(info.values())# items 返回键值对列表 以列表方式储存print(info.items())# 字典的遍历# key()for key in info.keys(): print(key)# valuefor value in info.values(): print(value)# 项 (元素)for item in info.items(): print(item)for key, value in info.items(): print(key, value)# for 循环迭代# chars = ['a', 'b', 'c', 'd']# for i, chr in enumerate(chars):# print(i, chr) 集合Set123456789101112131415161718# 集合# 无序 元素唯一 一般用于元组或列表的元素去重set1 = &#123;1, 2, 3, 4&#125;# 添加元素 add()set1.add(9)print(set1)# 修改元素 update()set1.update('abcd')print(set1)# 删除元素 remove()不存在会报错set1.remove(1)print(set1)# pop 随机删除集合中某个元素set1.pop()print(set1)# discard 丢弃，放弃，不会报错set1.discard(123)print(set1) 不可变的类型 ：数字Num 字符串Str 元组Tuple数字NumPython Number 数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。 字符串StrPython不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。Python访问子字符串，可以使用方括号来截取字符串1234str = 'today is Sunday'print(str[4])print(len(str))print(type(str)) 元组Tuple123456789101112131415161718# 元组 tuple# python 中的元组和列表类似，元组的元素是无法进行修改的# 元组() 列表[]# return a, b, caTuple = ('et', 77 , 3.14)print(aTuple)print(type(aTuple))# 元组中只有一个元素，需要逗号结尾，否则会引起歧异bTuple = (12,)print(type(bTuple))# 访问元组print(aTuple[1])# 修改元组 不支持修改# aTuple[0] = 123# count indexa = ('a', 'b', 'c', 'd')print(a.index('a', 0, 3))print(a.count('b'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell读取文件并批量添加用户]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[在linux中要求从一个文件中读取用户名和密码，并批量添加账户 文件格式：12345[root@localhost jeremy]# cat users.list apple 12345banana 123456orange 123123pear 123123 第一步：读取用户名和密码 创建 user.sh文件 按行读取用户信息12345678910111213[root@localhost jeremy]# vim user.sh[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo echo $linedone[root@localhost jeremy]# ./user.sh apple 12345banana 123456orange 123123pear 123123 读取每一行内容并输出有多种方式12345678910111213141516171819202122232425262728293031&gt; 第一种 while&gt; while read line&gt; do&gt; echo $line&gt; done &lt; filename&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第二种 while&gt; cat filename | while read line&gt; do&gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第三种 for&gt; for line in `cat filename`&gt; do &gt; echo $line&gt; done&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for循环在读取文件时，任何空白字符都可以作为其读取的分隔符.&gt; while使用是换行符作为标记&gt; ex: &gt; for line in $(&lt;users.list) 结果如下&gt; apple&gt; 12345&gt; banana&gt; 123456&gt; orange&gt; 123123&gt; pear&gt; 123123&gt; 第二步：分割用户名和密码123456789101112131415[root@localhost jeremy]# cat user.sh #!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` echo -n "USERNAME:$username PASSWORD:$password" echodone [root@localhost jeremy]# ./user.sh USERNAME:apple PASSWORD:12345USERNAME:banana PASSWORD:123456USERNAME:orange PASSWORD:123123USERNAME:pear PASSWORD:123123 第三步：批量添加用户12345678910111213141516171819[root@localhost jeremy]# cat user.sh#!/bin/shcat users.list | while read linedo username=`echo $line | cut -f1 -d' '` password=`echo $line | cut -f2 -d' '` useradd $username echo $password | passwd --stdin $usernamedone [root@localhost jeremy]# ./user.sh 更改用户 apple 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 banana 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 orange 的密码 。passwd：所有的身份验证令牌已经成功更新。更改用户 pear 的密码 。passwd：所有的身份验证令牌已经成功更新。 第四步：完善脚本以上脚本再运行一便，会发现新增用户不行了。但会修改了密码.应该增加一个用户是否存在的判断.另外所有非Shell内建命令都建议使用全路径，以避免由于环境变量的问题造成command not found。最后，脚本主体要尽量少使用变量，所以需要在脚本开头定义变量.如下：12345678910111213141516!/bin/bashUSER_INFO=/home/jeremy/users.listUSERADD=/usr/sbin/useraddPASSWD=/usr/bin/passwdCUT=/bin/cutwhile read LINESdo USERNAME=`echo $LINES | $CUT -f1 -d' '` USERPASS=`echo $LINES | $CUT -f2 -d' '` $USERADD $USERNAME if [ $? -ne 0 ];then echo "$USERNAME exists,skip set password" else echo $USERPASS | $PASSWD --stdin $USERNAME fidone &lt; $USER_INFO]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本编程]]></title>
    <url>%2F2018%2F11%2F06%2FShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ShellShell 是一个用C语言编写的程序，它既是一种命令语言，又是一种程序设计语言。 Shell ScriptShell脚本，用shell编写的脚本程序 First Shell 创建一个.sh为文件后缀的文件，hello.sh 内容如下1234#!/bin/bash#注释#author : jeremyecho "Hello Shell !" 保存退出 先赋予执行权限 1# chmod a+x hello.sh 执行 1# ./hello.sh 变量定义变量123456variable_name=variable_value等号左右无空格ex:User="Jeremy"Pwd="123456" 访问变量使用美元符号$访问变量,可以给变量加上{ }花括号，帮助解释器识别变量的边界123456#！/bin/shUser="Jeremy"Pwd=“123456”echo $Userecho $&#123;Pwd&#125; 打印 User 和 Pwd 的值 只读变量使用readonly可以将变量定义为只读变量，只读变量的值不能改变1234#！/bin/shUser="Jeremy"readonly User 删除变量使用unset命令可以删除变量1234#！/bin/shUser="Jeremy"unset User 变量类型局部变量局部变量在脚本或命令中定义，仅在当前shell实例中有效 环境变量所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证正常运行，shell脚本也可以定义环境变量 shell变量shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 特殊变量1234567$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 数组ArraysBash Shell只支持一维数组，初始化时不需要定义数组大小1array_name=(value1...valueN) 定义数组123456array_name[index]=valueex:User[0]="apple"User[1]="banana"User[2]="orange" 访问数组和访问变量格式相同1234567891011$&#123;array_name[index]&#125;ex:User[0]="apple"User[1]="banana"User[2]="orange"echo $&#123;User[0]&#125;echo $&#123;User[@]&#125;以下两种方式可以访问数组中的所有项目$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 基本运算符Bourne shell没有任何机制来执行简单的算术，它使用外部程序awk或expr 运算符和表达式之间必须有空格 ` ` 倒逗号之间包含完整的表达式 1234#!/bin/shval=`expr 2 + 2`echo $val 算术运算符a=10b=20 运算符 说明 举例 + 加法 ` expr $a + $b ` 结果为 30。 - 减法 ` expr $a - $b ` 结果为 -10。 * 乘法 ` expr $a * $b ` 结果为 200。 / 除法 ` expr $b / $a ` 结果为 2。 % 取余 ` expr $b % $a ` 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等 [$a==$b] 返回 false。 != 不相等 [$a!=$b] 返回 true。 关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 Shell条件语句if … fishell expression求值，结果是true，statement被执行，否则不执行1234if[ expression ]then Statement(s) to be executed if expression is truefi if … else … fi123456if[ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi if … elif … fi123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi case .. esac这里的字符串字每个模式进行比较，直到找到一个匹配。执行语句匹配模式。如果没有找到匹配，声明退出的情况下不执行任何动作。没有最大数量的模式，但最小是一个。当语句部分执行，命令;; 表明程序流程跳转到结束整个 case 语句。和C编程语言的 break 类似。1234567891011case word in pattern1) Statement(s) to be executed if pattern1 matches ;; pattern2) Statement(s) to be executed if pattern2 matches ;; pattern3) Statement(s) to be executed if pattern3 matches ;;esac Shell循环类型while 循环这里Shell命令进行计算。如果结果值是 true，给定语句被执行。如果命令为 false，那么没有语句将不执行，程序将跳转到done语句后的下一行。1234while commanddo Statement(s) to be executed if command is truedone for 循环var是一个变量，word1 到 wordN 是由空格分隔的字符（字）序列的名称。每次for 循环的执行，变量var的值被设置为下一个单词的列表中的字，word1 到 wordN 。1234for var in word1 word2 ... wordNdo Statement(s) to be executed if command is truedone until 循环这里Shell命令进行评估计算。如果结果值是false，给定语句（s）被执行。如果命令没有语句为true，那么将不执行，程序会跳转到下一行done语句后。1234until commanddo Statement(s) to be executed until command is truedone select 循环var是一个变量，word1 到 wordN是由空格分隔的字符（字）序列的名称。每次for循环的执行，变量var的值被设置为下一个单词的列表中的字，由 word1 到wordN。 对于每一个选择的一组命令将被执行，在循环中。这个循环在ksh，并已被改编成的bash。这不是在sh。1234select var in word1 word2 ... wordNdo Statement(s) to be executed for every word.done]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[列出磁盘使用量df1# df [‐ahikHTm] 目录或文件名 -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes，MBytes，KBytes 等格式显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来 检查磁盘空间使用量du1# du [‐ahskm] 文件或目录名称 -a ：递归列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 ­s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显 磁盘分区fdisk1# fdisk [‐l] 装置名称（或者叫分区名称，下同） -l ：输出后面参数指定装置所有的分区内容。若仅有fdisk -l时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来 磁盘格式化1# mkfs [-t 文件系统格式] 装置名称（系统分区名称） -t ：可以指令文件系统格式，例如 xfs，ext4，ext3，ext2, vfat 等(系统有支持才会生 12将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：# mkfs ‐t ext3 /dev/hdc6 注意：如果一个分区已经格式化，则需要再次格式化时，可以加参数 -f 表示强制再次格式化。注意：如果一个分区已经挂载到一个目录之下，则不能在挂载的情况下进行再次格式化操作 磁盘检验fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck 命令对文件系统进行检查 1# fsck [‐t 文件系统] [‐ACay] 装置名称 -t ： 给定文件系统的格式，若在 /etc/fstab 中已有定义或 kernel 本身已支持的则需加上此参数-s ：依序一个一个地执行 fsck 的指令来检查-A ：对/etc/fstab 中所有列出来的 分区（partition）做检查-C ：显示完整的检查进度-d ：打印出 e2fsck 的 debug 结果-p ：同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R ：同时有 -A 条件时，省略 / 不检查-V ：详细显示模式-a ：如果检查有错则自动修复-r ：如果检查有错则由使用者回答是否修复-y ：选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复 磁盘挂载与卸载Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令 123456789101112131415挂载# mount [‐t 文件系统] [‐L Label名] [‐o 额外选项] [‐n] 装置文件名（也叫分区名称） 挂载点（也叫目录名）将刚刚创建的 /dev/hdc6 分区挂载到 /mnt/hdc6 上面# mkdir /mnt/hdc6# mount /dev/hdc6 /mnt/hdc6# dfFilesystem 1K‐blocks Used Available Use% Mounted on.....中间省略...../dev/hdc6 1976312 42072 1833836 3% /mnt/hd6卸载# umount /dev/hdc6-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况卸除]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux用户管理]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[系统用户账号的管理添加用户1# useradd &lt;选项&gt; 用户名 #添加新的用户账号 -c comment 指定一段用户注释性描述。-d 目录，指定用户主目录，如果此目录不存在，则同时配合使用-m 选项，可以自动创建主目录。-g 用户组，指定用户所属的用户组（主组）。-G 用户组，指定用户所属的附加组（可指定多个，当然并不建议太多个）。-s Shell 文件，指定用户的登录 Shell。默认是 /bin/bash，注意 /bin/bash 不等于是 /bin/sh。-u 用户号，指定用户的用户号，如果同时有-o 选项，则可以重复使用其它用户的标识 删除用户12# userdel 用户名 #删除用户# userdel -r 用户名 #把用户的主目录一起删除 修改账号1# usermod &lt;选项&gt; 用户名 #修改已有用户的信息 修改用户口令1# passwd &lt;选项&gt; 用户名 -l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令，即清除密码（设置空密码）-f 强迫用户下次登录时修改口令 系统用户组的管理增加用户组1# groupadd &lt;选项&gt; 用户组 -g GID 指定新用户组的组标识号（GID）。-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID相同。 删除用户组1# groupdel 用户组 修改用户组1# groupmod &lt;选项&gt; 用户组 -g GID 为用户组指定新的组标识号。-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。-n 新用户组，将用户组的名字改为新名字 切换用户组1# newgrp 用户组 与用户账号有关的系统文件/etc/passwd12# cat /etc/passwd用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/shadow/etc/shadow 中的记录行与 /etc/passwd 中的一一对应，它由 pwconv 命令根据/etc/passwd 中的数据自动产生。它的文件格式与 /etc/passwd 类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。“最小时间间隔”指的是两次修改口令之间所需的最小天数。“最大时间间隔”指的是口令保持有效的最大天数。“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了 /etc/group用户组的所有信息都存放在 /etc/group 文件中。此文件的格式也类似于 /etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与 /etc/passwd 中的登录名一样，组名不应重复。“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。”组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件基本属性及权限设置]]></title>
    <url>%2F2018%2F10%2F31%2FLinux%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[文件基本属性123456789101112[jeremy@localhost ~]$ lltotal 0drwxrwxr-x. 2 jeremy jeremy 110 Oct 17 20:11 aaadrwxrwxr-x. 3 jeremy jeremy 30 Oct 6 20:43 bbbdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Desktopdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Documentsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Downloadsdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Musicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Picturesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Publicdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Templatesdrwxr-xr-x. 2 jeremy jeremy 6 Oct 17 16:27 Videos 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录当为[ - ]则是文件；若是[ l ]则表示为链接文件(link file)；若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置 接下来的字符中，以三个为一组，且均为 “rwx” 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 从左至右用 0-9 这些数字来表示。第 0 位确定文件类型，第 1-3 位确定文件属主（该文件的所有者）拥有该文件的权限。第 4-6 位确定文件属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。其中，第 1、4、7 位表示读权限，如果用 “r” 字符表示，则有读权限，如果用 “-“ 字符表示，则没有读权限；第 2、5、8 位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权 文件属主和属组 属主 ：该文件具有所有权的用户，通常时文件的所有者是指创建此文件的用户，或者手动指定的拥有者 属组 ：Linux中，用户时按组分类的，一个用户可以属于一个或者多个组。文件所有者以外的用户，又可以分为文件所有者的同组用户和其它用户。root是顶级用户，可以无视权限，进行任何操作。 更改文件属性chgrp1# chgrp [-R] 属组名 文件名 #更改文件属组，前提是组已经存在 -R : 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改 chown12# chown [-R] 属主名 文件名 #更改文件属主# chown [-R] 属主名：属组名 文件名 #更改文件属主，同时修改文件属组 chmodLinux 文件属性有两种设置方法，一种是数字，一种是符号。 数字类型Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己read/write/execute 权限123r:4w:2x:1 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的， 例如当权限为： [-rwxrwx—] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0 1# chmod [-R] xyz 文件或目录 #修改文件的9个属性 xyz ：为rwx属性数值的相加 R ：进行递归recursive的持续变更，即连同次目录下的所有文件都会变更 12345# ls ‐al .bashrc‐rw‐r‐‐r‐‐ 1 root root 395 Jul 4 11:45 .bashrc# chmod 777 .bashrc# ls ‐al .bashrc‐rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 符号类型基本上就九个权限分别是(1)user (2)group (3)others三种身份，那么我们就可以藉由u，g，o来代表三种身份的权限。此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r，w，x。也就是可以使用底下的方式1234# chmod [ugoa] +/-/= [rwx] 文件或目录+（加入）-(除去) =（设定）将文件权限设置为 -rwxr-xr-- 可以使用 chmod u=rwx,g=rx,o=r 文件名]]></content>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理及操作]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux 系统目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445/bin：bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。实际上是链接到/usr/bin。/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。/dev ：dev 是 Device(设备)的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的DLL文件，几乎所有的应用程序都需要用到这些共享库。64 位系统还有一个lib64，这两个目录连接到 /usr下对应的lib目录。/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。/media：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/ 上，然后进入该目录就可以查看光驱里的内容了。/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all/root：该目录为系统管理员，也称作超级权限者的用户主目录（相当于普通用户的家目录）。/sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。实际上连接到 /usr/sbin/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。/srv：该目录存放一些服务启动之后需要提取的数据。/sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。/tmp：这个目录是用来存放一些临时文件的。/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。/usr/bin：系统用户使用的应用程序。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点.. 来表示。12. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。 文件、目录常用命令绝对路径路径的写法，由根目录/写起，例如：/usr/share/doc这个目录。 相对路径路径的写法，不是由/写起，例如由 /usr/share/doc要到/usr/share/man底下时，可以写成：cd ../man这就是相对路径的写法 显示当前工作目录pwd12# pwd #Print Working Directory 显示当前所在目录# pwd -P #显示出确实的路径，而非使用连接路径 列出目录ls123# ls [‐aAdfFhilnrRSt] 目录名称# ls [‐‐color=&#123;never,auto,always&#125;] 目录名称# ls [‐‐full‐time] 目录名称 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来（常用）-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-l ：以长格式列出，包含文件的属性与权限等等数据；(常用)-i ：在第 1 列显示文件的 inode 节点号 切换目录cd1234567891011121314#使用 mkdir 命令创建 runoob 目录# mkdir runoob#使用绝对路径切换到 runoob 目录# cd /root/runoob/#使用相对路径切换到 runoob 目录# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；# cd .. 创建新目录mkdir1# mkdir [-mp] 目录名称 -m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色。-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来 删除空目录rmdir1# rmdir [-p] 目录名称 -p ：连同上一级的“空的”目录也一起删除 移除文件或目录rm1# rm [-fir] 文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除，最常用的目录删除！这是非常危险的选项 复制文件或目录cp12# cp [‐adfilprsu] 来源档(source) 目标档(destination)# cp [options] source1 source2 source3 .... directory -a：相当于 ­pdr 的意思，至于 pdr 请参考下列说明；(常用)-d：若来源文件为连接文件的属性(link file)，则复制连接文件而非文件本身；-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)-l：进行硬连接(hard link)的文件创建，而非复制文件本身；-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；-r：递归持续复制，用于目录的复制行为；(常用)-s：复制成为符号连接 (symbolic link)，亦即『连接』文件；-u：若 destination 比 source 旧才升级 destination 移动文件与目录，或修改名称mv12# mv [‐fiu] source destination# mv [options] source1 source2 source3 .... directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 文件内容查看cat1# cat [-AbEnTv] #由第一行开始显示文件内容 -A ：相当於 ­vET 的整合选项，可显示出一些特殊字符（如空白字符）；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字节 $ 显示出来；-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符 tactac 与 cat 命令刚好相反，文件内容从最后一行开始向前逐行显示，可以看出 tac 是cat 的倒写 nl1# nl [-bnw] 文件 #显示行号 -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数 more一页页翻动 空白键 (space)：代表向下翻一页；Enter ：代表向下翻『一行』/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；:f ：立刻显示出档名以及目前显示的行数；q ：代表立刻离开 more ，不再显示该文件内容b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用 less一页一页翻动 空白键 ：向下翻动一页；[pagedown]：向下翻动一页；[pageup] ：向上翻动一页；/字串 ：向下搜寻『字串』的功能；?字串 ：向上搜寻『字串』的功能；n ：重复前一个搜寻 (与 / 或 ? 有关！)N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)q ：离开 less 这个程序； head取出文件前面的几行1# head [-n number] 文件 -n ：后面接数字，代表显示几行的意思 tail取出文件后面几行1# tail [-nf number] 文件 -n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[终端12# clear #清空当前终端命令历史记录# exit #退出终端 关机和重启1234# reboot #重启# shutdown -r now #重启。等同reboot# shutdown -h now #关机，慎用，通常情况远程服务器关机后，物理机无法重启# halt #关机，慎用 目录和文件操作12345678910111213141516171819202122232425# cd &lt;directory&gt; #切换到指定目录下，参数可使用通配符，按下 tab 键可自动补足，连按两下 tab 键，则会将所有相关文件列出。directory 既可是绝对路径，也可是相对路径，./ 表示当前路径，../ 表示上一级路径，下同。# ls &lt;directory&gt; #列出指定目录下所有文件，如无参数，则列出当前目录下所有文件。directory 既可是绝对路径，也可是相对路径。# ls -l #以长格式形式列出所有文件，可简写为 ll。长格式规则：第1列：1位文件类型，9位权限标志。第2列：文件索引节点编号，第3列：文件所有者名称，第4列：文件属主所在组名称，第5列：文件大小，第6列：文件最后修改日期，第7列：文件名称。# ls -a #列出所有文件，包括隐藏文件。在 Linux 中，隐藏文件的文件名以 “.”开头。另外，命令参数若有多个可以合写，如ls ‐la。# cp &lt;source&gt; &lt;target&gt; #将 source 文件复制到 target 位置。source和 target 既可是绝对路径，也可是相对路径，支持通配符，下同。第二个参数是目录的话，表示将文件复制到指定目录下，第二个参数如果是文件名称的话，表示将源文件复制成参数2指定的新文件。# cp -r &lt;source&gt; &lt;target&gt; #递归复制，‐f 参数表示静默操作，无提示。有时 ‐f 可能会失效，详细原因见最后附录部分。# mv &lt;source&gt; &lt;target&gt; #移动 source 文件到 target 位置，相当于剪切，重命名也是使用此命令。‐f 参数表示静默操作，无警告提示。mv 没有 ‐r参数。# rm &lt;source&gt; #删除文件# rm -r &lt;source&gt; #递归删除，-f 参数表示静默操作，无警告提示# mkdir &lt;directory&gt; #创建目录# mkdir -p &lt;directory&gt; #递归操作# rmdir #删除空目录# man &lt;命令&gt; #查看命令帮助文档或使用说明，按q 退出说明 查看系统版本123# ll /etc/centos* # ll 命令等同于ls ‐l# ll /etc/centos‐release #按 tab 键可自动补足# cat /etc/centos‐release #cat 命令是直接在终端中显示 查看内核版本123456# uname ‐r #显示内核版本# uname ‐m #查看系统位数# uname ‐a #显示更全面的信息# arch #与 uname ‐m 命令非常类似。如果输出 x86_64 则表示为 64 位系统，如果输出i686 或 i386 则表示为 32 位系统# getconf LONG_BIT #查看系统位数# echo $LANG #查看语言与本地化 查看网络及网卡状态123456# ifconfig #查看网络及网卡状态# nmcli dev show #检查网卡状态# nmcli device show #与之上命令效果等同# nmcli #以简单模式显示网卡状态# nmcli con up ens33 #最后一个参数是网卡名称，执行此命令后，将会激活连接此网卡# nmcli con down ens33 #表示断开此网卡 查看当前系统用户12345# whoami #查看当前系统操作用户身份，本指令等同于执行 id -un 指令 # id -un #查看当前系统操作用户的身份# who am i #查看当前系统登录用户，注意：是登录 id# who ‐m #等同于 who am i# who #显示系统当前登录的所有用户 切换用户12345# su snow #切换到普通snow 账户# su root #切换到 root 账户，切换后相对路径与当前路径一致# su #等同于上一条# su ‐ #切换到 root 账户，切换后相对路径为 ~ ，即家目录。同时会显示最后一次登录时间。# exit #退出当前的临时切换账户状态 CentOS 7.5 系统配置国内 yum 源和 epel 首先进入 /etc/yum.repos.d/目录下，新建一个 repo_bak.d目录，用于保存系统中原来的 repo 文件 123# cd /etc/yum.repos.d/# mkdir repo_bak.d# mv *.repo repo_bak.d/ 在 CentOS 中配置使用网易和阿里的开源镜像点击右上角的网络管理器，连接网络。因为 CentOS 默认是不自动连接网络的。首选使用 su ‐ 命令切换到 root 用户。否则某些操作是无法完成的，需要 root 权限到网易和阿里开源镜像站点下载系统对应版本的 repo 12345# cd yum.repos.d# wget http://mirrors.aliyun.com/repo/Centos‐7.repo# wget http://mirrors.163.com/.help/CentOS7‐Base‐163.repo# lsCentos‐7.repo CentOS‐Base‐163.repo repo.bak 或者手动下载 repo 文件并上传到/etc/yum.repos.d/ 清除系统 yum 缓存并生成新的 yum 12# yum clean all# yum update #更新软件 安装 epel 源 1# yum ‐y install epel‐release 安装压缩、解压缩工具123# yum install zip unzip gzip p7zip #安装压缩与解压缩工具# yum remove zip unzip gzip p7zip #卸载压缩与解压缩工具# yum unzip -0 cp936 xxx.zip #解决使用unzip命令时中文乱码的问题 安装中文输入法1# yum install ibus ibus-table-wubi*]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux修改密码]]></title>
    <url>%2F2018%2F10%2F30%2FLinux%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[修改/重置普通用户密码 passwd #用于当前操作用户自行修改密码。注意：修改密码时，需要输入当前操作用户的当前密码。root 用户也可使用此命令修改自行修改密码。 passwd &lt;用户名&gt; #此命令只能由 root 用户执行，当前用户是 root时，可更改任意其它用户的密码 修改/重置 root 用户密码重置root密码如果 root 用户密码忘记，需要重置 root 密码的话。可按如下步骤操作（前提，有条可以操作物理机开机重启）： 第一种方法 ： 开机，随意按一个键，进入开机项选择状态，否则 5 秒钟后系统默认选择第一项自动启动。按方向键选中第一项，按 e 进入编辑状态。事实上，选择其它项也可以，只不过，第一项是默认开机项，一般是最新的内核启动 进入编辑模式后。注意，显示的内容有可能并不是全部的内容，可以按方向键上下来查看更多内容 按方向键下，一直到内容的尾部。找到 linux16 这一行，将 ro 更改成rw init=/sysroot/bin/sh，按 ctrl + x 启动。注意：修改属临时修改，仅本次生效，重启电脑，又会恢复到原来的内容 启动后，进入单用户纯文本命令模式，注意：命令提示符是:/# 使用指令chroot /sysroot切换根目录。经测试，此句之前无须执行挂载指令mount ‐o remount,rw /sysroot 使用指令 passwd root ，来重置 root 用户的密码。由于本机安装了中文语言包，而当前文本命令模式不支持中文，所以修改密码时的提示，全部显示成了方块。如果未安装中文语言包的话，提示应该是英文的。不过操作很简单，就是输入两次密码，正确输入即可。注意1：不要输入过于简单的密码。注意2：更改LANG=en_US.UTF-8，依然是中文提示，且中文仍然会显示成方块。 使用touch /.autorelabel命令，会在 / 目录下创建一个 .autorelabel 文件，有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling。 使用命令 exit 退出 chroot 状态，使用命令 reboot 重启，使用 root 新密码登录。如果使用 reboot 不能重启，可以加入 -f 参数， reboot ‐f 强制重启。 重启后，进入以下状态 等待一会，系统会再次重启。正常进入系统。 第二种方法 ： 同样是开机时，按 e 进入编辑状态。将 ro 更改为 rw ，将 LANG=zh_CN.UTF-8 更改为 LANG=en_US.UTF-8，并在末尾追加空格，init=/bin/sh，注意：一定是在末尾添加。 按 Ctrl + x 启动。启动后如下 执行如下指令，修改密码。 123# passwd root# touch /.autorelabel #注意文件名称# exec /sbin/init #重启即可 注意：此种方式，修改 LANG=en_US.UTF-8，是可以显示英文的。注意：本方法命令行前缀是sh‐4.2# 启动后进入以下状态 第三种方法： 按 e 编辑，添加rd.break 启动后，如下状态：注意命令前缀switch_root，这是固定不变（不因不同的机器而变）的 依次输入以下指令，与第一种方法相同。注意指令前缀的变化123456# mount ‐o remount,rw /sysroot #如果不加这一句，是没有效果的。但第一种方法经测试，无须加此句。# chroot /sysroot# passwd root# touch /.autorelabel# exit# reboot #重启 两次重启后就会生效。注意：CentOS 6.x 版本和 7.x 版本，重置 root 密码的方法是不一样的。具体方法可查询网络。重置 root 用户密码是 Redhat RHCE 认证考试必须先完成的第一步操作，很明显，意味着这是最简单的必备技能。第二种方法相对简单一些。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linxu</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说点心情]]></title>
    <url>%2F2018%2F10%2F24%2F1024%E8%AF%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[还有人知道今天给我过节很开心有人记得我]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort快速排序算法]]></title>
    <url>%2F2018%2F10%2F09%2FQuicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序算法思想：二分法，分治法，递归 排序实例6 1 2 7 9 3 4 5 10 86为基准，也就是temp先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。 如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它 找到7 和 56 1 2 7 9 3 4 5 10 8 交换后得到6 1 2 5 9 3 4 7 10 8 依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下6 1 2 5 4 3 9 7 10 8 此时交换基准数与33 1 2 5 4 6 9 7 10 8 这样就保证了基准数6左边都比他小，右边都比他大这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序也就是进行递归排序算法，最终就得到排序结果1 2 3 4 5 6 7 8 9 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;void QuickSort(int* a, int left, int right) &#123; int i = left; int j = right; int temp = a[left]; int t = 0; if (left &gt;= right) return; while (i != j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= temp)//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp j--;//从右向左找第一个小于x的数 while (i &lt; j &amp;&amp; a[i] &lt;= temp)//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp i++;//从左向右找第一个大于x的数 //交换两个数在数组中的位置 if (i &lt; j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //将基准数归位 a[left] = a[i]; a[i] = temp; QuickSort(a, left, i - 1); QuickSort(a, i + 1, right); return;&#125;int main()&#123; int n; int a[101] = &#123;0&#125;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; QuickSort(a, 0, n-1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 测试用例： Input:113 4 5 1 34 61 22 41 111 2 87 Output:1 2 3 4 5 22 34 41 61 87 111]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络物理层]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的主要任务确定与传输媒体的接口有关的一些特性： 机械特性 电气特性 功能特性 过程特性 传输方式的转换 数据在计算机中多采用 并行传输 方式 数据在通信线路上的传输方式一般是 串行传输 数据通信的基础知识数据通信系统的模型 数据通信基本概念 模拟信号（连续信号） ：一般是正弦或余弦波形 数字信号（离散信号）：脉冲信号 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形 模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声 数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积信道及其极限容量 信道：数据传输的通道 单向通信：单工，单向传输 双向交替通信：半双工，一方发，一方收，不能同时 双向同时通信：全双工，同时发送和接收信息，需要两条信道 信道参数 数据传输速率 = 带宽 载波频率：信道对应的频率 采样频率：模拟信号转化为数字信号时采样的速率 量化：对采样信号的数字化 噪声、信噪比： 信噪比（dB）= 10log10(S/N)（dB） Nyquist定理——计算机通信的基本定理比特率 = log2V波特率在无噪信道中，当带宽为H Hz，信号电平为V级： 数据传输速率 = 2Hlog2V (b/s) V：信号电平的级数，在二进制中，仅为0、1两级采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰 香农（Shannon)定理：在噪声信道中，当带宽为H Hz，信噪比为 S/N ：最大数据传输速率（b/s）= Hlog2（1+S/N） 信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法让每一个码元携带更多比特的信息量 数据传输基带传输：​ - 基带信号：信号源产生的原始电信号，也叫基本频带信号​ - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制宽带传输​ - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输​ - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段​ - 宽带传输：多个频带的带通信号在同一个物理媒体上传输​ 数字数据在模拟信道上传输：数字信号——&gt;模拟信号 将数字数据调制成模拟信号进行传输，把0、1用波形表示 通常有三种基本的调制方式 调幅ASK：用载波的两种不同的振幅来表示两个二进制 调频FSK：用载波附近的两种不同的频率来表示两个二级制 调相PSK：用载波的相位移动来表示两个二进制 正交调相QPSK 正交调幅QAM 数字数据的数字信号传输 数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题 常用的数字信号编码方式： 不归零编码NRZ 曼切斯特编码——自同步编码方式 差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1 编码方式的比较： 不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟 曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟 差分曼切斯特编码与曼切斯特编码基本相同 模拟数据在数字信道上传输 模拟数据变成数字数据在数字信道上传递 采用脉冲编码调制（PCM–Pulse Code Modulation）技术 关键点：在接收端还原成模拟数据 PCM以Nyquist采样定理为基础 采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息 信道复用技术频分复用FDMFrequency Division Multiplexing前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和频分复用的所有用户再同样的时间占用不同的带宽资源 时分复用TDMTime Division Multiplexing每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输​ - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。​ - 每一个用户所占用的时隙是周期性地出现​ - TDM信号也称为等时信号​ - 时分复用地所有用户是在不同的时间占用同样的频带宽度 TDM的同步和异步：​ - 同步TDM:​ - 时间片与输入装置一一对应，同步​ - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲​ - 传输介质的传输速率不能低于各个输入信号的数据速率之和​ - 同步TDM可能会造成线路资源的浪费​ - 异步TDM​ - 时间片是按需动态分配的​ - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号​ - 在传输的数据单元中必须包含地址信息，以便寻址目的节点​ - 传输介质的传输速率只要不低于各个输入信号的平均速率即可​ - 异步TDM又称统计TDM(STDM) 波分复用WDMWavelength Division Multiplexing光的频分复用 码分复用CDMCode Division Multiplexing 码分多址（Code Division Multiple Access） 每个用户可以CDMA在同样的时间使用同样的频带进行通信 抗干扰强，频谱类似白噪声，不易被发现 采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等 码片序列（chip sequence） 每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。 通常m取值为64或128（在后面的原理性说明中，取为8） 每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 例如，S 站的 8 bit 码片序列是 00011011。 发送比特 1 时，就发送序列 00011011， 发送比特 0 时，就发送序列 11100100。 为了方便，将码片0写为–1 ，将1写为+1 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。 码片序列的正交关系 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0 交换技术物理媒体中间设备传递数据的技术 电路交换 在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接 一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址 服务质量好 线路的利用率较低 建立连接时间长，因连接建立时冲突概率高 报文交换 无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站 数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞 每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时） 分组交换 与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文 可以为分组在内存预留空间 每个分组中必须包含目的地址，并采用存储-转发机制 线路的利用率较高 由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计 每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置存储转发的速度较报文交换高 接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文 虚电路交换 将电路交换的概念引入到分组交换 信息传递依然采用分组（定义最大分组长度） 引入电路交换的连接建立过程 找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点 发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2018%2F09%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[因特网发展的三个阶段第一阶段：从单个网络ARPANET向互联网发展的过程ARPANET： 1969年美国国防部创建的第一个分组交换网 1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生 1990年关闭第二阶段：三级结构的因特网1985年美国国家科学基金会：NSFNET三级计算机网络： 主干网 地区网 校园网（或企业网）第三阶段：多层次ISP结构因特网 第一层：服务面积最大(一般是国家范围)，拥有高速主干网 NAP 第二层：第一层ISP的用户 第三层：又称本地ISP，拥有本地范围的网络 ISP: (Internet Service Provider) 互联网服务提供者（商）NAP:网络接入点NAP (Network Access Point)：分散主干网流量，又称对等点（peering point）IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组 英特网的组成因特网的边缘部分：由所有连接在因特网上的主机组成（通信和资源共享）因特网的核心部分：由大量网络和连接这些网络的路由器（router）组成，为边缘部分提供服务（连通性和交换） 另一种分法：资源子网，通信子网 边缘部分通信方式： 客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程 客户程序特点： 客户程序必须知道服务器程序的地址 不需要特殊的硬件和复杂的操作系统 服务程序特点： 可同时处理多个远地或本地客户的请求 系统启动后自动调用并一直不断的运行着 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器 核心部分三种交换方式： 路由器：实现分组交换的关键构建，转发收到的分组交换（switching）按照某种方式动态地分配传输线路的资源 电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源 通话前先拨号建立连接（经过一个或多个交换机） 通话过程中，通信双方一直占用所建立的连接 通话结束后，挂机释放连接 报文交换 分组交换 在发送端，先把较长的报文划分成较短的固定长度的数据端 每一个数据段前面添加上首部构成分组 依次把各分组发送到接收端 接收端剥去首部，抽出数据部分，还原成报文 每一个分组的首部都含有地址等控制信息结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机 路由器处理分组的过程： 把收到的分组先放入缓存； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去 优点： 高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。 缺点： 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 计算机网络分类1.按照网络的作用分类：​ - 广域网WAN（Wide Area Network）​ - 城域网MAN (Metropolitan Area Network)​ - 局域网LAN (Local Area Network)​ - 个人区域网PAN (Personal Area Network)2.按照网络的使用者分类：​ - 公用网（public network）​ - 专用网 (private network)3.原来把用户接入到互联网的网络：接入网 AN(Access Network) 计算机网络的性能 速率 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒） 带宽 某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ 计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s 吞吐量 表示在单位时间内通过某个网络（或信道、接口）的实际数据量 时延 发送时延主机或路由器发送数据帧所需要的时间​ 发送时延 = 数据帧长度 / 发送速率 传播时延电磁波在信道中传播一定的距离需要花费的时间​ 传播时延 = 信道长度 / 电磁波在信道上的传播速率 处理时延主机或路由器在收到分组时需要花费时间处理 排队时延分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 时延带宽积 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度） 往返时间RTT（Round-Trip Time） 发送时长 = 数据长度 / 发送速率 有效数据率 = 数据长度 / （发送时间 + RTT） 利用率 信道利用率和网络利用率，过高会产生非常大的时延 计算机网络的体系结构实体、协议、服务和服务访问点 实体： 表示任何可发送或接收信息的硬件或软件进程 对等实体peer entity 协议（protocol）： 控制两个对等实体进行通信的规则、标准或约定的集合 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务 网络协议的组成要素 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 同步：事件实现顺序的详细说明 协议与服务： 本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的 协议是”水平的“，协议是控制对等实体之间通信的规则 服务是”垂直的“，服务是由下层向上层通过层间接口提供的 并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语 服务访问点 SAP（Service Access Point）： 同一系统相邻两层实体进行交互的地方称为SAP 服务数据单元SDU(Service Data Unit) OSI/RM体系结构 层次 名称 作用 第七层 应用层(applicationg layer) 约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致 第六层 表示层(presentation layer) 表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义 第五层 会话层(session layer) 建立有关会话的机制，是双向的还是单向对话或重新建立会话 第四层 传输层(transport layer) 提供端到端的通路，应用到应用的通路 第三层 网络层(network layer) 提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括- 选择路由- 拥塞控制- 协议的转换- 分段和重组- 对用户的分组、字符等统计 第二层 数据连路层(data link layer) 提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收- 识别帧的标志- 帧的发送和接收，需校验、确认- 发送方在超时或收到否定性确认后，要重发- 重复帧要丢弃在共享网络中，需解决信道共享问题等——mac层 第一层 物理层(physical layer) 与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换 会话层及以下关心的是信息的传输表示层及以上关心的是信息的理解 TCP/IP的体系结构 层次 名称 作用 第五层 应用层 通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等 第四层 传输层 负责向两台主机中进程之间的通信提供通用的数据传输服务TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付 第三层 网络层 为分组交换网上的不同主机提供通信服务把传输层产生的报文段或用户数据报封装成分组或包进行传送选择合适路由网际协议IP和多路由选择协议 第二层 数据链路层 将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息 第一层 物理层 透明的传送比特流 传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层 数据传递过程 PDU(Protocol Data Unit)：对等层次间传送的数据单位 主机1 应用进程数据先传送到应用层,加上应用层首部，称为PDU 应用层PDU再传送到传输层，加上传输层首部，成为传输层报文 传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组 IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧 数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体 电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层 物理层接收到比特流，上交给数据链路层 数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层 网络层剥去首部，取出数据部分上交给传输层 传输层剥去首部，取出数据部分上交给应用层 应用层剥去首部，取出应用程序数据上交给应用进程主机2]]></content>
      <categories>
        <category>计算机网络笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT 6 添加字数和阅读时间统计]]></title>
    <url>%2F2018%2F09%2F14%2FNexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[打开hexo目录，运行git bush，安装插件$ npm install hexo-symbols-count-time --save 修改博客配置文件，添加以下代码12345symbols_count_time:symbols: truetime: truetotal_symbols: truetotal_time: true 修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码123456symbols_count_time:separated_meta: trueitem_text_post: trueitem_text_total: falseawl: 4wpm: 275 重启服务]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给Hexo正确添加RSS订阅]]></title>
    <url>%2F2018%2F09%2F09%2Fhexo-rss%2F</url>
    <content type="text"><![CDATA[安装feed插件 本地hexo目录下运行git bash here 输入指令npm install hexo-generator-feed 等待安装完成 添加配置文件 打开hexo目录下配置文件_config.yml，末尾添加以下配置 # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 打开主题配置文件_config.yml,搜索rss，添加配置 rss: /atom.xml 发布hexo s]]></content>
      <categories>
        <category>Hexo搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>rss</tag>
      </tags>
  </entry>
</search>
