<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s Blog</title>
  
  <subtitle>艰险我奋进，困乏我多情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coderjeremy.github.io/"/>
  <updated>2018-10-09T13:44:07.646Z</updated>
  <id>https://coderjeremy.github.io/</id>
  
  <author>
    <name>吴健伟_Jeremy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Quicksort快速排序算法</title>
    <link href="https://coderjeremy.github.io/2018/10/09/Quicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://coderjeremy.github.io/2018/10/09/Quicksort快速排序算法/</id>
    <published>2018-10-09T12:04:05.000Z</published>
    <updated>2018-10-09T13:44:07.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><p>思想：二分法，分治法，递归</p><p>排序实例<br>6    1    2    7    9    3    4    5    10    8<br>6为基准，也就是temp<br>先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。</p><blockquote><p>如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它</p></blockquote><p>找到7 和 5<br>6     1    2    <strong>7</strong>    9    3    4    <strong>5</strong>    10    8</p><hr><p>交换后得到<br>6    1    2    <strong>5</strong>    9    3    4    <strong>7</strong>    10    8</p><hr><p>依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下<br>6    1    2    5    4    <strong>3</strong>    9    7    10    8</p><hr><p>此时交换基准数与<strong>3</strong><br><strong>3</strong>    1    2    5    4    <strong>6</strong>    9    7    10    8</p><hr><p>这样就保证了基准数6左边都比他小，右边都比他大<br>这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序<br>也就是进行递归排序算法，最终就得到排序结果<br>1    2    3    4    5    6    7    8    9    10</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">int</span> temp = a[left];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= temp)<span class="comment">//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp</span></span><br><span class="line">j--;<span class="comment">//从右向左找第一个小于x的数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= temp)<span class="comment">//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp</span></span><br><span class="line">i++;<span class="comment">//从左向右找第一个大于x的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将基准数归位</span></span><br><span class="line">a[left] = a[i];</span><br><span class="line">a[i] = temp;</span><br><span class="line">QuickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">QuickSort(a, i + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试用例：</p><p>Input:<br>11<br>3 4 5 1 34 61 22 41 111 2 87</p><p>Output:<br>1 2 3 4 5 22 34 41 61 87 111</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序算法&quot;&gt;&lt;a href=&quot;#快速排序算法&quot; class=&quot;headerlink&quot; title=&quot;快速排序算法&quot;&gt;&lt;/a&gt;快速排序算法&lt;/h1&gt;&lt;p&gt;思想：二分法，分治法，递归&lt;/p&gt;
&lt;p&gt;排序实例&lt;br&gt;6    1    2    7    9    
      
    
    </summary>
    
      <category term="算法" scheme="https://coderjeremy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://coderjeremy.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="QuickSort" scheme="https://coderjeremy.github.io/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络物理层</title>
    <link href="https://coderjeremy.github.io/2018/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://coderjeremy.github.io/2018/09/25/计算机网络物理层/</id>
    <published>2018-09-25T07:56:16.000Z</published>
    <updated>2018-10-23T12:53:59.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h1><p>确定与传输媒体的接口有关的一些特性：</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><p>传输方式的转换</p><ul><li>数据在计算机中多采用<strong><em> 并行传输 </em></strong> 方式</li><li>数据在通信线路上的传输方式一般是<strong><em> 串行传输 </em></strong></li></ul><h1 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h1><h2 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h2><img src="/2018/09/25/计算机网络物理层/数据通信系统的模型.png" title="数据通信系统的模型"><h2 id="数据通信基本概念"><a href="#数据通信基本概念" class="headerlink" title="数据通信基本概念"></a>数据通信基本概念</h2><ul><li>模拟信号（连续信号） ：一般是正弦或余弦波形</li><li><p>数字信号（离散信号）：脉冲信号</p><blockquote><p>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote></li><li><p>模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声</p></li><li>数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积<h2 id="信道及其极限容量"><a href="#信道及其极限容量" class="headerlink" title="信道及其极限容量"></a>信道及其极限容量</h2></li><li>信道：数据传输的通道<ul><li>单向通信：单工，单向传输</li><li>双向交替通信：半双工，一方发，一方收，不能同时</li><li>双向同时通信：全双工，同时发送和接收信息，需要两条信道</li></ul></li><li>信道参数<ul><li>数据传输速率 = 带宽</li><li>载波频率：信道对应的频率</li><li>采样频率：模拟信号转化为数字信号时采样的速率</li><li>量化：对采样信号的数字化</li><li>噪声、信噪比：<strong> 信噪比（dB）= 10log<sub>10</sub>(S/N)（dB）</strong></li></ul></li></ul><blockquote><p><strong><em>Nyquist定理</em></strong>——计算机通信的基本定理<br>比特率 = log<sub>2</sub>V波特率<br>在无噪信道中，当带宽为H Hz，信号电平为V级：<br><strong> 数据传输速率 = 2Hlog<sub>2</sub>V (b/s) </strong><br>V：信号电平的级数，在二进制中，仅为0、1两级<br>采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复</p><blockquote><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题<br>如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰</p></blockquote></blockquote><blockquote><p><strong><em>香农（Shannon)定理：</em></strong><br>在噪声信道中，当带宽为H Hz，信噪比为 S/N ：<br><strong>最大数据传输速率（b/s）= Hlog<sub>2</sub>（1+S/N）</strong></p><blockquote><p>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高<br>只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输<br>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法<strong>让每一个码元携带更多比特的信息量</strong></p></blockquote></blockquote><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>基带传输：<br>​    - 基带信号：信号源产生的原始电信号，也叫基本频带信号<br>​    - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制<br>宽带传输<br>​    - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输<br>​    - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段<br>​    - 宽带传输：多个频带的带通信号在同一个物理媒体上传输<br>​    </p><ul><li><p><strong>数字数据在模拟信道上传输：数字信号——&gt;模拟信号</strong></p><ul><li>将数字数据调制成模拟信号进行传输，把0、1用波形表示</li><li>通常有三种基本的调制方式<ul><li>调幅ASK：用载波的两种不同的振幅来表示两个二进制</li><li>调频FSK：用载波附近的两种不同的频率来表示两个二级制</li><li>调相PSK：用载波的相位移动来表示两个二进制</li></ul></li><li>正交调相QPSK</li><li>正交调幅QAM</li></ul></li><li><p><strong>数字数据的数字信号传输</strong></p><ul><li>数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题</li><li>常用的数字信号编码方式：<ul><li>不归零编码NRZ</li><li>曼切斯特编码——自同步编码方式</li><li>差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1</li></ul></li><li>编码方式的比较：<ul><li>不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟</li><li>曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟</li><li>差分曼切斯特编码与曼切斯特编码基本相同</li></ul></li></ul></li><li><p><strong>模拟数据在数字信道上传输</strong></p><ul><li>模拟数据变成数字数据在数字信道上传递</li><li>采用脉冲编码调制（PCM–Pulse Code Modulation）技术</li><li>关键点：在接收端还原成模拟数据</li><li>PCM以Nyquist采样定理为基础<blockquote><p>采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息</p></blockquote></li></ul></li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><p>Frequency Division Multiplexing<br>前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和<br>频分复用的所有用户再同样的时间占用不同的带宽资源</p><h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><p>Time Division Multiplexing<br>每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输<br>​    - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。<br>​    - 每一个用户所占用的时隙是周期性地出现<br>​    - TDM信号也称为等时信号<br>​    - 时分复用地所有用户是在不同的时间占用同样的频带宽度</p><img src="/2018/09/25/计算机网络物理层/时分复用.png" title="时分复用"><p>TDM的同步和异步：<br>​    - 同步TDM:<br>​        - 时间片与输入装置一一对应，同步<br>​        - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲<br>​        - 传输介质的传输速率不能低于各个输入信号的数据速率之和<br>​        - 同步TDM可能会造成线路资源的浪费<br><img src="/2018/09/25/计算机网络物理层/同步TDM.png" title="同步TDM"><br>​    - 异步TDM<br>​        - 时间片是按需动态分配的<br>​        - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号<br>​        - 在传输的数据单元中必须包含地址信息，以便寻址目的节点<br>​        - 传输介质的传输速率只要不低于各个输入信号的平均速率即可<br>​        - 异步TDM又称<strong>统计TDM(STDM)</strong></p><img src="/2018/09/25/计算机网络物理层/异步TDM.png" title="异步TDM"><h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><p>Wavelength Division Multiplexing<br>光的频分复用</p><h3 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h3><p>Code Division Multiplexing</p><h4 id="码分多址（Code-Division-Multiple-Access）"><a href="#码分多址（Code-Division-Multiple-Access）" class="headerlink" title="码分多址（Code Division Multiple Access）"></a>码分多址（Code Division Multiple Access）</h4><ul><li>每个用户可以CDMA在同样的时间使用同样的频带进行通信</li><li>抗干扰强，频谱类似白噪声，不易被发现</li><li>采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等</li></ul><h4 id="码片序列（chip-sequence）"><a href="#码片序列（chip-sequence）" class="headerlink" title="码片序列（chip sequence）"></a>码片序列（chip sequence）</h4><ul><li>每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。<br>  通常m取值为64或128（在后面的原理性说明中，取为8）</li><li>每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。<br>  如发送比特 1，则发送自己的 m bit 码片序列。<br>  如发送比特 0，则发送该码片序列的二进制反码。<br>  例如，S 站的 8 bit 码片序列是 00011011。<br>  发送比特 1 时，就发送序列 00011011，<br>  发送比特 0 时，就发送序列 11100100。<br>  为了方便，将码片0写为–1 ，将1写为+1<br>  S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</li><li>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。<br>在实用的系统中是使用伪随机码序列。</li></ul><h4 id="码片序列的正交关系"><a href="#码片序列的正交关系" class="headerlink" title="码片序列的正交关系"></a>码片序列的正交关系</h4><ul><li>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 </li><li>两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0<img src="/2018/09/25/计算机网络物理层/码片正交.png" title="码片正交"></li></ul><img src="/2018/09/25/计算机网络物理层/码片规格化.png" title="码片规格化"><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>物理媒体中间设备传递数据的技术</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接</li><li>一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址<ul><li>服务质量好</li><li>线路的利用率较低</li><li>建立连接时间长，因连接建立时冲突概率高 </li></ul></li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul><li>无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站</li><li>数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制<ul><li>线路的利用率较高</li><li>由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞</li><li>每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时）</li></ul></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li>与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文<br>  可以为分组在内存预留空间</li><li>每个分组中必须包含目的地址，并采用存储-转发机制<ul><li>线路的利用率较高</li><li>由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计</li><li>每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置<br>存储转发的速度较报文交换高</li><li>接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文</li></ul></li></ul><h3 id="虚电路交换"><a href="#虚电路交换" class="headerlink" title="虚电路交换"></a>虚电路交换</h3><ul><li>将电路交换的概念引入到分组交换<ul><li>信息传递依然采用分组（定义最大分组长度）</li><li>引入电路交换的连接建立过程</li><li>找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点</li><li>发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;物理层的主要任务&quot;&gt;&lt;a href=&quot;#物理层的主要任务&quot; class=&quot;headerlink&quot; title=&quot;物理层的主要任务&quot;&gt;&lt;/a&gt;物理层的主要任务&lt;/h1&gt;&lt;p&gt;确定与传输媒体的接口有关的一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机械特性&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://coderjeremy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="物理层" scheme="https://coderjeremy.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
      <category term="计算机网络" scheme="https://coderjeremy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://coderjeremy.github.io/2018/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://coderjeremy.github.io/2018/09/18/计算机网络概述/</id>
    <published>2018-09-18T13:30:01.000Z</published>
    <updated>2018-09-25T08:07:50.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><h3 id="第一阶段：从单个网络ARPANET向互联网发展的过程"><a href="#第一阶段：从单个网络ARPANET向互联网发展的过程" class="headerlink" title="第一阶段：从单个网络ARPANET向互联网发展的过程"></a>第一阶段：从单个网络ARPANET向互联网发展的过程</h3><p>ARPANET：</p><ul><li>1969年美国国防部创建的第一个分组交换网</li><li>1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生</li><li>1990年关闭<h3 id="第二阶段：三级结构的因特网"><a href="#第二阶段：三级结构的因特网" class="headerlink" title="第二阶段：三级结构的因特网"></a>第二阶段：三级结构的因特网</h3>1985年美国国家科学基金会：NSFNET<br>三级计算机网络：</li></ul><ul><li>主干网</li><li>地区网</li><li>校园网（或企业网）<h3 id="第三阶段：多层次ISP结构因特网"><a href="#第三阶段：多层次ISP结构因特网" class="headerlink" title="第三阶段：多层次ISP结构因特网"></a>第三阶段：多层次ISP结构因特网</h3></li><li>第一层：服务面积最大(一般是国家范围)，拥有高速主干网</li><li>NAP </li><li>第二层：第一层ISP的用户</li><li>第三层：又称本地ISP，拥有本地范围的网络<blockquote><p>ISP: (Internet Service Provider) 互联网服务提供者（商）<br>NAP:网络接入点<strong>NAP</strong> (Network Access Point)：分散主干网流量，又称对等点（peering point）<br>IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组</p></blockquote></li></ul><h2 id="英特网的组成"><a href="#英特网的组成" class="headerlink" title="英特网的组成"></a>英特网的组成</h2><p>因特网的<strong>边缘部分</strong>：由所有连接在因特网上的<strong>主机</strong>组成（通信和资源共享）<br>因特网的<strong>核心部分</strong>：由大量网络和连接这些网络的<strong>路由器（router）</strong>组成，为边缘部分提供服务（连通性和交换）</p><blockquote><p>另一种分法：资源子网，通信子网</p></blockquote><hr><h3 id="边缘部分通信方式："><a href="#边缘部分通信方式：" class="headerlink" title="边缘部分通信方式："></a>边缘部分通信方式：</h3><ol><li>客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程</li></ol><ul><li>客户程序特点：<ul><li>客户程序必须知道服务器程序的地址</li><li>不需要特殊的硬件和复杂的操作系统</li></ul></li><li>服务程序特点：<ul><li>可同时处理多个远地或本地客户的请求</li><li>系统启动后自动调用并一直不断的运行着</li><li>一般需要强大的硬件和高级的操作系统支持</li></ul></li></ul><ol start="2"><li>对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器</li></ol><h3 id="核心部分三种交换方式："><a href="#核心部分三种交换方式：" class="headerlink" title="核心部分三种交换方式："></a>核心部分三种交换方式：</h3><blockquote><p>路由器：实现分组交换的关键构建，转发收到的分组<br>交换（switching）按照某种方式动态地分配传输线路的资源</p><ol><li>电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放<br> 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源<ul><li>通话前先拨号建立连接（经过一个或多个交换机）</li><li>通话过程中，通信双方一直占用所建立的连接</li><li>通话结束后，挂机释放连接</li></ul></li></ol></blockquote><ol start="2"><li><p>报文交换</p></li><li><p>分组交换</p><ul><li>在发送端，先把较长的报文划分成较短的固定长度的数据端</li><li>每一个数据段前面添加上首部构成分组</li><li>依次把各分组发送到接收端</li><li><p>接收端剥去首部，抽出数据部分，还原成报文</p><blockquote><p>每一个分组的首部都含有地址等控制信息<br>结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机</p></blockquote><p>路由器处理分组的过程：</p></li><li>把收到的分组先放入缓存；</li><li>查找转发表，找出到某个目的地址应从哪个端口转发；</li><li><p>把分组送到适当的端口转发出去</p><p>优点：</p></li><li>高效    动态分配传输带宽，对通信链路是逐段占用。 </li><li>灵活    以分组为传送单位和查找路由。</li><li>迅速    不必先建立连接就能向其他主机发送分组。</li><li><p>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。   </p><p>缺点：</p></li><li>分组在各结点存储转发时需要排队，这就会造成一定的时延。</li><li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</li></ul></li></ol><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>1.按照网络的作用分类：<br>​    - 广域网WAN（Wide Area Network）<br>​    - 城域网MAN (Metropolitan Area Network)<br>​    - 局域网LAN (Local Area Network)<br>​    - 个人区域网PAN (Personal Area Network)<br>2.按照网络的使用者分类：<br>​    - 公用网（public network）<br>​    - 专用网 (private network)<br>3.原来把用户接入到互联网的网络：接入网 AN(Access Network)</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol><li>速率<br> 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒）</li><li>带宽<ul><li>某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ</li><li>计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s</li></ul></li><li>吞吐量<br> 表示在单位时间内通过某个网络（或信道、接口）的实际数据量</li><li><p>时延</p><ul><li><p>发送时延<br>主机或路由器发送数据帧所需要的时间<br>​    发送时延 = 数据帧长度 / 发送速率</p></li><li><p>传播时延<br>电磁波在信道中传播一定的距离需要花费的时间<br>​    传播时延  = 信道长度  /  电磁波在信道上的传播速率</p></li><li><p>处理时延<br>主机或路由器在收到分组时需要花费时间处理</p></li><li><p>排队时延<br>分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理</p><blockquote><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></blockquote></li></ul></li><li><p>时延带宽积<br> 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度）</p></li><li>往返时间RTT（Round-Trip Time）<br> 发送时长 = 数据长度 / 发送速率<br> 有效数据率 = 数据长度 / （发送时间 + RTT）</li><li>利用率<br> 信道利用率和网络利用率，过高会产生非常大的时延</li></ol><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h3><ol><li>实体：<ul><li>表示任何可发送或接收信息的硬件或软件进程</li><li>对等实体peer entity</li></ul></li><li>协议（protocol）：<ul><li>控制两个对等实体进行通信的规则、标准或约定的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</li><li>网络协议的组成要素<ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul></li></ul></li><li><p>协议与服务：</p><ul><li>本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的</li><li>协议是”水平的“，协议是控制对等实体之间通信的规则</li><li>服务是”垂直的“，服务是由下层向上层通过层间接口提供的<blockquote><p>并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务<br>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语</p></blockquote></li></ul></li><li><p>服务访问点 SAP（Service Access Point）：</p><ul><li>同一系统相邻两层实体进行交互的地方称为SAP</li><li>服务数据单元SDU(Service Data Unit)</li></ul></li></ol><h3 id="OSI-RM体系结构"><a href="#OSI-RM体系结构" class="headerlink" title="OSI/RM体系结构"></a>OSI/RM体系结构</h3><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">第七层</td><td style="text-align:center">应用层(applicationg layer)</td><td style="text-align:left">约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致</td></tr><tr><td style="text-align:center">第六层</td><td style="text-align:center">表示层(presentation layer)</td><td style="text-align:left">表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义</td></tr><tr><td style="text-align:center">第五层</td><td style="text-align:center">会话层(session layer)</td><td style="text-align:left">建立有关会话的机制，是双向的还是单向对话或重新建立会话</td></tr><tr><td style="text-align:center">第四层</td><td style="text-align:center">传输层(transport layer)</td><td style="text-align:left">提供端到端的通路，应用到应用的通路</td></tr><tr><td style="text-align:center">第三层</td><td style="text-align:center">网络层(network layer)</td><td style="text-align:left">提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括<br>- 选择路由<br>- 拥塞控制<br>- 协议的转换<br>- 分段和重组<br>- 对用户的分组、字符等统计</td></tr><tr><td style="text-align:center">第二层</td><td style="text-align:center">数据连路层(data link layer)</td><td style="text-align:left">提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收<br>- 识别帧的标志<br>- 帧的发送和接收，需校验、确认<br>- 发送方在超时或收到否定性确认后，要重发<br>- 重复帧要丢弃<br>在共享网络中，需解决信道共享问题等——mac层</td></tr><tr><td style="text-align:center">第一层</td><td style="text-align:center">物理层(physical layer)</td><td style="text-align:left">与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换</td></tr></tbody></table><blockquote><p>会话层及以下关心的是信息的传输<br>表示层及以上关心的是信息的理解</p></blockquote><h3 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a>TCP/IP的体系结构</h3><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">第五层</td><td style="text-align:center">应用层</td><td style="text-align:left">通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等</td></tr><tr><td style="text-align:center">第四层</td><td style="text-align:center">传输层</td><td style="text-align:left">负责向两台主机中进程之间的通信提供通用的数据传输服务<br>TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付<br>UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付</td></tr><tr><td style="text-align:center">第三层</td><td style="text-align:center">网络层</td><td style="text-align:left">为分组交换网上的不同主机提供通信服务<br>把传输层产生的报文段或用户数据报封装成分组或包进行传送<br>选择合适路由<br>网际协议IP和多路由选择协议</td></tr><tr><td style="text-align:center">第二层</td><td style="text-align:center">数据链路层</td><td style="text-align:left">将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息</td></tr><tr><td style="text-align:center">第一层</td><td style="text-align:center">物理层</td><td style="text-align:left">透明的传送比特流</td></tr></tbody></table><blockquote><p>传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层</p></blockquote><h3 id="数据传递过程"><a href="#数据传递过程" class="headerlink" title="数据传递过程"></a>数据传递过程</h3><blockquote><p>PDU(Protocol Data Unit)：对等层次间传送的数据单位</p></blockquote><p>主机1</p><ol start="5"><li>应用进程数据先传送到应用层,加上应用层首部，称为PDU</li><li>应用层PDU再传送到传输层，加上传输层首部，成为传输层报文</li><li>传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组</li><li>IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧</li><li>数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体</li></ol><p>电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层</p><ol><li>物理层接收到比特流，上交给数据链路层</li><li>数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层</li><li>网络层剥去首部，取出数据部分上交给传输层</li><li>传输层剥去首部，取出数据部分上交给应用层</li><li>应用层剥去首部，取出应用程序数据上交给应用进程<br>主机2</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;因特网发展的三个阶段&quot;&gt;&lt;a href=&quot;#因特网发展的三个阶段&quot; class=&quot;headerlink&quot; title=&quot;因特网发展的三个阶段&quot;&gt;&lt;/a&gt;因特网发展的三个阶段&lt;/h2&gt;&lt;h3 id=&quot;第一阶段：从单个网络ARPANET向互联网发展的过程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://coderjeremy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="https://coderjeremy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>NexT 6 添加字数和阅读时间统计</title>
    <link href="https://coderjeremy.github.io/2018/09/14/NexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1/"/>
    <id>https://coderjeremy.github.io/2018/09/14/NexT 6 添加字数和阅读时间统计/</id>
    <published>2018-09-14T14:04:25.000Z</published>
    <updated>2018-09-14T14:13:07.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开hexo目录，运行git-bush，安装插件"><a href="#打开hexo目录，运行git-bush，安装插件" class="headerlink" title="打开hexo目录，运行git bush，安装插件"></a>打开hexo目录，运行git bush，安装插件</h2><p><code>$ npm install hexo-symbols-count-time --save</code></p><h2 id="修改博客配置文件，添加以下代码"><a href="#修改博客配置文件，添加以下代码" class="headerlink" title="修改博客配置文件，添加以下代码"></a>修改博客配置文件，添加以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码"><a href="#修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码" class="headerlink" title="修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码"></a>修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;打开hexo目录，运行git-bush，安装插件&quot;&gt;&lt;a href=&quot;#打开hexo目录，运行git-bush，安装插件&quot; class=&quot;headerlink&quot; title=&quot;打开hexo目录，运行git bush，安装插件&quot;&gt;&lt;/a&gt;打开hexo目录，运行git
      
    
    </summary>
    
      <category term="Hexo搭建" scheme="https://coderjeremy.github.io/categories/Hexo%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://coderjeremy.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://coderjeremy.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>如何给Hexo正确添加RSS订阅</title>
    <link href="https://coderjeremy.github.io/2018/09/09/hexo-rss/"/>
    <id>https://coderjeremy.github.io/2018/09/09/hexo-rss/</id>
    <published>2018-09-09T13:36:23.000Z</published>
    <updated>2018-09-14T14:01:03.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装feed插件"><a href="#安装feed插件" class="headerlink" title="安装feed插件"></a>安装feed插件</h1><ol><li>本地hexo目录下运行<code>git bash here</code></li><li>输入指令<code>npm install hexo-generator-feed</code></li><li>等待安装完成</li></ol><h1 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h1><ol><li><p>打开hexo目录下配置文件_config.yml，末尾添加以下配置</p><blockquote><pre><code># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20</code></pre></blockquote></li><li><p>打开主题配置文件_config.yml,搜索rss，添加配置</p></li></ol><p><code>rss: /atom.xml</code></p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p><code>hexo s</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装feed插件&quot;&gt;&lt;a href=&quot;#安装feed插件&quot; class=&quot;headerlink&quot; title=&quot;安装feed插件&quot;&gt;&lt;/a&gt;安装feed插件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本地hexo目录下运行&lt;code&gt;git bash here&lt;/code&gt;&lt;/l
      
    
    </summary>
    
      <category term="Hexo搭建" scheme="https://coderjeremy.github.io/categories/Hexo%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://coderjeremy.github.io/tags/Hexo/"/>
    
      <category term="rss" scheme="https://coderjeremy.github.io/tags/rss/"/>
    
  </entry>
  
</feed>
