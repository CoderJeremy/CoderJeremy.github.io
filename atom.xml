<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s Blog</title>
  
  <subtitle>艰险我奋进，困乏我多情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coderjeremy.github.io/"/>
  <updated>2020-03-09T10:34:31.919Z</updated>
  <id>https://coderjeremy.github.io/</id>
  
  <author>
    <name>吴健伟_Jeremy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://coderjeremy.github.io/2020/03/09/Mybatis/"/>
    <id>https://coderjeremy.github.io/2020/03/09/Mybatis/</id>
    <published>2020-03-09T10:34:02.000Z</published>
    <updated>2020-03-09T10:34:31.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li>是软件开发过程中的一套解决方案，不同的框架解决不同的问题</li><li>优点：框架封装了很多细节，使开发者可以使用极简的方式实现功能，大大提高开发效率</li></ul><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>表现层：用于展示数据，Spring MVC</li><li>业务层：处理业务需求，Spring</li><li>持久层：操作数据库，Mybatis</li></ul><h3 id="持久层技术解决方案"><a href="#持久层技术解决方案" class="headerlink" title="持久层技术解决方案"></a>持久层技术解决方案</h3><ul><li><p>JDBC技术：</p><ul><li>Connection</li><li>PreparedStatement</li><li>ResultSet</li></ul></li><li><p>Spring的JdbcTemplate：Spring中对JDBC的简单封装</p></li><li><p>Apache的DBUtils：对JDBC的简单封装</p></li><li><p>JDBC是规范，以上这些只是工具类</p></li></ul><h3 id="Mybatis-1"><a href="#Mybatis-1" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul><li><p>Mybatis是一个优秀的基于java的持久层框架，它内部封装了JDBC，使开发者只需要关注SQL语句本身，而不需要花费精力去加载驱动、创建连接、创建Statement等复杂的过程。</p></li><li><p>Mybatis通过<strong>xml</strong>或<strong>注解</strong>的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由Mybatis框架执行SQL并将结果映射为Java对象并返回</p></li><li><p>采用 ORM 思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</p></li></ul><blockquote><p>ORM思想:Object Relational Mapping 对象关系映射，把数据库表和实体类及实体类的属性对应起来，通过操作实体类完成数据库表操作</p></blockquote><h2 id="Mybatis入门"><a href="#Mybatis入门" class="headerlink" title="Mybatis入门"></a>Mybatis入门</h2><h3 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h3><ul><li><p>第一步：创建maven工程并导入坐标</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--Mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步：创建实体类和dao的接口</p></li><li><p>第三步：创建Mybatis的主配置文件<code>SqlMapConfig.xml</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Mybatis的主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Mysql的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置事务的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源(连接池) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/nogizaka/dao/UserDao.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第四步：创建映射配置文件<code>UserDao.xml</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">                "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.nogizaka.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置查询所有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id 对应 查询方法名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType 对应 查询结果封装的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>在Mybatis中把持久层的操作接口名称和映射文件也叫做：Mapper</li><li>Mybatis的映射配置文件位置必须和dao接口的包结构相同</li><li>映射配置文件的mapper标签<code>namespace</code>属性的取值<strong>**必须是dao接口的全限定类名</strong>，不能使用别名</li><li>映射配置文件的操作配置(select)，id属性取值必须是dao接口的方法名</li></ul><h3 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h3><ul><li>第一步： 读取配置文件</li><li>第二步： 创建SqlSessionFactory工厂</li><li>第三步： 使用工厂生产SqlSession对象</li><li>第四步： 使用SqlSession创建Dao接口的代理对象</li><li>第五步： 使用代理对象执行方法</li><li>第六步： 释放资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 读取配置文件</span></span><br><span class="line">InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line"><span class="comment">// 2. 创建SqlSessionFactory工厂</span></span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(in);</span><br><span class="line"><span class="comment">// 3. 使用工厂生产SqlSession对象</span></span><br><span class="line">SqlSession session = factory.openSession();</span><br><span class="line"><span class="comment">// 4. 使用SqlSession创建Dao接口的代理对象</span></span><br><span class="line">UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line"><span class="comment">// 5. 使用代理对象执行方法</span></span><br><span class="line">List&lt;User&gt; users = userDao.findAll();</span><br><span class="line"><span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 释放资源</span></span><br><span class="line">session.close();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>（第一步）读取配置文件：直接写绝对路径和相对路径都不合适，一般采用以下两种方式</p><ul><li>使用类加载器，它只能读取类路径的配置文件</li><li>使用ServletContext对象的getRealPath()获取全局路径</li></ul></li><li><p>（第二步）创建SqlSessionFactory：使用了<strong>构建者模式</strong></p><blockquote><p>构建者模式：把对象的创建细节隐藏，使用者直接调用方法即可拿到对象</p></blockquote></li><li><p>（第三步）使用工厂生产SqlSession对象：使用了<strong>工厂模式</strong></p><blockquote><p>工厂模式：降低类之间的依赖关系，降低耦合度</p></blockquote></li><li><p>（第四步）使用SqlSession对象创建Dao的代理对象：使用了<strong>代理模式</strong></p><blockquote><p>代理模式：在不修改源码的基础上，对已有方法进行增强</p></blockquote></li><li><p>不要忘记在映射配置中告知mybatis要封装到哪个实体类中</p><ul><li>配置的方式：在<code>resultType</code>属性指定实体类的全限定类名</li></ul></li></ul><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><ul><li>在Dao接口的方法上，使用<code>@Select(&quot;..&quot;)</code>注解，并且指定执行SQL语句</li><li>同时需要在<code>SqlMapConfig.xml</code>中的mapper配置中，使用<code>class属性</code>指定<code>Dao接口</code>的全限定类名</li></ul><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.nogizaka.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--parameterType 参数类型--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置插入操作后，获取插入数据的id值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">            select last_insert_id();</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into user(username,address,sex,birthday) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,</span><br><span class="line">        address=#&#123;address&#125; where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--删除数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delUser"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过ID查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据姓名模糊查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--select * from user where username like #&#123;name&#125;--&gt;</span></span><br><span class="line">        select * from user where username like '%$&#123;value&#125;%';</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--查询总用户数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findTotal"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select count(id) from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="与-的区别"><a href="#与-的区别" class="headerlink" title="#{}与${}的区别"></a>#{}与${}的区别</h4><ul><li><p><strong>#{}表示一个占位符号</strong></p><blockquote><p>通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。</p></blockquote></li><li><p><strong>${}表示拼接 sql 串</strong></p><blockquote><p>通过${}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。</p></blockquote></li></ul><h4 id="获取新增用户id的返回值"><a href="#获取新增用户id的返回值" class="headerlink" title="获取新增用户id的返回值"></a>获取新增用户id的返回值</h4><ul><li><p>使用<code>&lt;selectKEy&gt;</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--插入数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置插入操作后，获取插入数据的id值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        select last_insert_id();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user(username,address,sex,birthday) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="arameterType"><a href="#arameterType" class="headerlink" title="arameterType"></a>arameterType</h4><ul><li>Mybatis使用OGNL表达式解析对象字段的值，#{}或者${}中为Pojo的属性名称</li><li><p>OGNL表达式：Object Graphic Navigation Language 对象导航图语言</p><ul><li><p>通过对象的取值方法来获取数据，在写法上把get和省略了   </p><ul><li>类中获取名称：user.getUsername()</li><li>OGNL中获取名称：user.username</li></ul></li><li><p>mybatis在parameterType中已经提供了属性所属的类，所以此时不需要写对象名</p></li></ul></li></ul><h3 id="标签中的属性"><a href="#标签中的属性" class="headerlink" title="标签中的属性"></a>标签中的属性</h3><h4 id="Select标签中的属性"><a href="#Select标签中的属性" class="headerlink" title="Select标签中的属性"></a>Select标签中的属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td>parameterMap</td><td>这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。</td></tr><tr><td>resultType</td><td>从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。</td></tr><tr><td>resultMap</td><td>外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。</td></tr><tr><td>flushCache</td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td></tr><tr><td>useCache</td><td>将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td>fetchSize</td><td>这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td>statementType</td><td>STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>resultSetType</td><td>FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr><tr><td>resultOrdered</td><td>这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td></tr><tr><td>resultSets</td><td>这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。</td></tr></tbody></table><h4 id="Insert-Update-Delete-标签的属性"><a href="#Insert-Update-Delete-标签的属性" class="headerlink" title="Insert, Update, Delete 标签的属性"></a>Insert, Update, Delete 标签的属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>命名空间中的唯一标识符，可被用来代表这条语句。</td></tr><tr><td>parameterType</td><td>将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器推断出具体传入语句的参数，默认值为未设置（unset）</td><td>。</td></tr><tr><td>parameterMap</td><td>这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。</td></tr><tr><td>flushCache</td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true（对于 insert、update 和 delete 语句）。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td>statementType</td><td>STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr></tbody></table><h3 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h3><ul><li>查询的列名和实体类的属性名称不一致:<ul><li>方法一：使用sql语言中的起别名，如 <code>Select id as userId</code>，（执行效率高）</li><li>方法二：<code>resultMap</code>标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。（开发效率高）</li></ul></li></ul><ul><li>在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"com.nogizaka.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--主键字段的对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非主键字段的对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"useraddress"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SqlMapConfig中的配置"><a href="#SqlMapConfig中的配置" class="headerlink" title="SqlMapConfig中的配置"></a>SqlMapConfig中的配置</h3><h4 id="SqlMapConfig-xml配置内容和顺序"><a href="#SqlMapConfig-xml配置内容和顺序" class="headerlink" title="SqlMapConfig.xml配置内容和顺序"></a>SqlMapConfig.xml配置内容和顺序</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">properties（属性）</span></span><br><span class="line"><span class="ruby">    --property</span></span><br><span class="line"><span class="ruby">-settings（全局配置参数）</span></span><br><span class="line"><span class="ruby">    --setting</span></span><br><span class="line"><span class="ruby">-typeAliases（类型别名）</span></span><br><span class="line"><span class="ruby">    --typeAliase</span></span><br><span class="line"><span class="ruby">    --package</span></span><br><span class="line"><span class="ruby">-typeHandlers（类型处理器）</span></span><br><span class="line"><span class="ruby">-objectFactory（对象工厂）</span></span><br><span class="line"><span class="ruby">-plugins（插件）</span></span><br><span class="line"><span class="ruby">-environments（环境集合属性对象）</span></span><br><span class="line"><span class="ruby">    --environment（环境子属性对象）</span></span><br><span class="line"><span class="ruby">        ---transactionManager（事务管理）</span></span><br><span class="line"><span class="ruby">        ---dataSource（数据源）</span></span><br><span class="line"><span class="ruby">-mappers（映射器）</span></span><br><span class="line"><span class="ruby">    --mapper</span></span><br><span class="line"><span class="ruby">    --package</span></span><br></pre></td></tr></table></figure><h4 id="properties属性"><a href="#properties属性" class="headerlink" title="properties属性"></a>properties属性</h4><ul><li>properties属性：<ul><li>可以在标签内部配置连接数据库的信息，也可通过属性引用外部配置文件信息<ul><li>resource属性： 用于指定配置文件的位置，是按照类路径的写法，并且必须存在于类路径下</li><li>url属性；要求按照url的写法来写地址：协议 主机 端口 URI</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方法一：标签内部配置连接数据库的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方法二：通过标签属性引用外部配置文件信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--此时我们的 dataSource 标签就变成了引用上面的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="typeAliases属性"><a href="#typeAliases属性" class="headerlink" title="typeAliases属性"></a>typeAliases属性</h4><ul><li>typeAliases必须按照configuration的配置顺序进行配置</li><li><p>配置domain中类的别名</p><ul><li>type属性：指定是实体类全限定类名</li><li>alias属性：指定别名，指定别名后，不区分大小写</li></ul></li><li><p>package ：用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且<strong>类名</strong>就是<strong>别名</strong>，不再区分大小写</p></li></ul><blockquote><p>mapper中的<code>package</code> 标签是用于指定dao接口所在的包，当指定了之后就不需要再写mapper已经resource或者class属性了</p></blockquote><ul><li>配置别名后，domain中的实体类都可以用简写，不区分大小写<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.nogi.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h4><ul><li><p><code>&lt;mapper resource=&quot; &quot; /&gt;</code></p><ul><li>使用相对于类路径的资源如：<code>&lt;mapper resource=&quot;com/nogi/dao/UserDao.xml&quot; /&gt;</code></li></ul></li><li><p><code>&lt;mapper class=&quot; &quot; /&gt;</code></p><ul><li>使用 mapper 接口类路径如：<code>&lt;mapper class=&quot;com.nogi.dao.UserDao&quot;/&gt;</code><ul><li>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 </li></ul></li></ul></li><li><p><code>&lt;package name=&quot;&quot;/&gt;</code></p><ul><li>注册指定包下的所有 mapper 接口如：<code>&lt;package name=&quot;com.nogi.mybatis.mapper&quot;/&gt;</code><ul><li>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--写法不同效果相同--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/nogi/dao/UserDao.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.nogi.dao.UserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.nogi.dao"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mybatis连接池"><a href="#Mybatis连接池" class="headerlink" title="Mybatis连接池"></a>Mybatis连接池</h2><ul><li>mybatis连接池提供了3种方式的配置</li><li>配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式</li><li>type属性的取值：<ul><li><strong>POOLED</strong> ：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现</li><li><strong>UNPOOLED</strong> ：采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没用使用池的思想</li><li><strong>JNDI</strong> ：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的。如果不是web或者maven的war工程，是不能使用，tomcat采用dbcp连接池</li></ul></li></ul><h2 id="Mybatis事务控制"><a href="#Mybatis事务控制" class="headerlink" title="Mybatis事务控制"></a>Mybatis事务控制</h2><ul><li><p>Mybatis中的事务提交：SqlSession对象的<code>commit()</code>方法</p></li><li><p>Mybatis中的事务回滚：SqlSession对象的<code>rollback()</code>方法</p></li><li><p>设置自动提交：SqlSessionFactory对象的<code>openSession(boolean autocommit)</code></p></li></ul><h2 id="Mybatis基于XML配置的动态SQL语句"><a href="#Mybatis基于XML配置的动态SQL语句" class="headerlink" title="Mybatis基于XML配置的动态SQL语句"></a>Mybatis基于XML配置的动态SQL语句</h2><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><ul><li>原理：sql语句的拼接</li><li>test属性：判断条件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据条件查询--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--where 1=1 可以防止SQL语句报错,一般用于动态SQL拼接和查询表结构--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByProp"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"USER"</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER WHERE 1=1</span><br><span class="line">    <span class="comment">&lt;!--test为判定内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"uname!=null"</span>&gt;</span></span><br><span class="line">        AND USERNAME LIKE #&#123;uname&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"usex!=null"</span>&gt;</span></span><br><span class="line">        AND SEX=#&#123;usex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h3><ul><li>简化上面 where 1=1 的条件拼装，我们可以采用<code>&lt;where&gt;</code>标签来简化开发</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByProp"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"USER"</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--test为判定内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"uname!=null"</span>&gt;</span></span><br><span class="line">            AND USERNAME LIKE #&#123;uname&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"usex!=null"</span>&gt;</span></span><br><span class="line">            AND SEX=#&#123;usex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><ul><li><p><code>&lt;foreach&gt;</code>标签用于遍历集合，它的属性：</p><ul><li>collection:代表要遍历的集合元素，注意编写时不要写#{}</li><li>open:代表语句的开始部分</li><li>close:代表结束部分</li><li>item:代表遍历集合的每个元素，生成的变量名</li><li>sperator:代表分隔符</li></ul></li><li><p>SQL语句：<code>SELECT 字段 FROM 表名 WHERE id IN (?)</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--传入多个 id 查询用户信息，根据一组条件集合查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIDS"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"USER"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids!=null and ids.size()&gt;0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"ID IN ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"vid"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                #&#123;vid&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mybatis多表操作"><a href="#Mybatis多表操作" class="headerlink" title="Mybatis多表操作"></a>Mybatis多表操作</h2><h3 id="ResultMap-1"><a href="#ResultMap-1" class="headerlink" title="ResultMap"></a>ResultMap</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--column不做限制，可以为任意表的字段，而property须为type 定义的pojo属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"唯一的标识"</span> <span class="attr">type</span>=<span class="string">"映射的pojo对象"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"表的主键字段，或者可以为查询语句中的别名字段"</span> <span class="attr">jdbcType</span>=<span class="string">"字段类型"</span> <span class="attr">property</span>=<span class="string">"映射pojo对象的主键属性"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"表的一个字段（可以为任意表的一个字段）"</span> <span class="attr">jdbcType</span>=<span class="string">"字段类型"</span> <span class="attr">property</span>=<span class="string">"映射到pojo对象的一个属性（须为type定义的pojo对象中的一个属性）"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"pojo的一个对象属性"</span> <span class="attr">javaType</span>=<span class="string">"pojo关联的pojo对象"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"关联pojo对象对应表的主键字段"</span> <span class="attr">jdbcType</span>=<span class="string">"字段类型"</span> <span class="attr">property</span>=<span class="string">"关联pojo对象的主键属性"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>  <span class="attr">column</span>=<span class="string">"任意表的字段"</span> <span class="attr">jdbcType</span>=<span class="string">"字段类型"</span> <span class="attr">property</span>=<span class="string">"关联pojo对象的属性"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 集合中的property须为oftype定义的pojo对象的属性--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"pojo的集合属性"</span> <span class="attr">ofType</span>=<span class="string">"集合中的pojo对象"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"集合中pojo对象对应的表的主键字段"</span> <span class="attr">jdbcType</span>=<span class="string">"字段类型"</span> <span class="attr">property</span>=<span class="string">"集合中pojo对象的主键属性"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"可以为任意表的字段"</span> <span class="attr">jdbcType</span>=<span class="string">"字段类型"</span> <span class="attr">property</span>=<span class="string">"集合中的pojo对象的属性"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一对多</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.asuka.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMapAccount"</span> <span class="attr">type</span>=<span class="string">"com.asuka.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--主键--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非主键--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置user中accounts集合的映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"com.asuka.domain.Account"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"aid"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userMapAccount"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user u LEFT OUTER JOIN account a ON u.id=a.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><ul><li><p>JNDI：Java Naming and Directory Interface。是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。</p></li><li><p>在服务器中注册数据源：</p><ul><li>在webapp目录下创建META-INF文件夹</li><li>创建context.xml文件</li><li>修改SqlMapConfig中的数据源</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Context.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">&lt;Resource </span></span><br><span class="line"><span class="comment">name=数据源的名称</span></span><br><span class="line"><span class="comment">type=数据源类型</span></span><br><span class="line"><span class="comment">auth=数据源提供者</span></span><br><span class="line"><span class="comment">maxActive=最大活动数</span></span><br><span class="line"><span class="comment">maxWait=最大等待时间</span></span><br><span class="line"><span class="comment">maxIdle=最大空闲数</span></span><br><span class="line"><span class="comment">username=用户名</span></span><br><span class="line"><span class="comment">password=密码</span></span><br><span class="line"><span class="comment">driverClassName=驱动类</span></span><br><span class="line"><span class="comment">url=连接url字符串</span></span><br><span class="line"><span class="comment">/&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Resource</span> </span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">"jdbc/mybatis_demo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></span></span><br><span class="line"><span class="tag"><span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxActive</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxWait</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxIdle</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag"><span class="attr">username</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag"><span class="attr">password</span>=<span class="string">"1234"</span></span></span><br><span class="line"><span class="tag"><span class="attr">driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag"><span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--修改SqlMapConfig配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"JNDI"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"data_source"</span> <span class="attr">value</span>=<span class="string">"java:comp/env/jdbc/mybatis_demo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mybatis延迟加载"><a href="#Mybatis延迟加载" class="headerlink" title="Mybatis延迟加载"></a>Mybatis延迟加载</h2><ul><li>概念：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.</li><li>优点：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快</li><li>缺点：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</li><li>多对一、一对一：直接加载</li><li>多对多、一对多：延迟加载</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>在SqlMapConfig配置文件中加入<code>&lt;settings&gt;标签</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认为false--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--任一方法的调用都会加载该对象的所有延迟加载属性,3.4以后默认为false--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将原始的关联查询代码改为单表查询</p></li><li>更改关联查询的resultMap内的映射association标签加入懒加载需要的查询条件和sql语句statementId原始resultMap映射</li></ul><h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><ul><li>指的是Mybatis中SqlSession对象的缓存。</li><li>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块Map结构的区域。当我们在此查询同样的数据，mybatis会优先去数据库查询是否存在。</li><li>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。</li></ul><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ul><li><p>二级缓存指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession对象共享</p></li><li><p>使用步骤：</p><ul><li><p>第一步：在 SqlMapConfig.xml 文件开启二级缓存：<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p></li><li><p>第二步：配置相关的 Mapper 映射文件：<code>&lt;cache/&gt;</code></p></li><li><p>第三步：配置 statement 上面的 useCache 属性：<code>&lt;select id=&quot;findAll&quot; resultMap=&quot;userMapAccount&quot; useCache=&quot;true&quot;&gt;</code></p></li></ul></li><li><p>注意：</p><ul><li><p>将 UserDao.xml 映射文件中的<code>&lt;select&gt;</code>标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。</p></li><li><p>针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。</p></li><li><p>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。</p></li></ul></li></ul><h2 id="Mybatis注解开发"><a href="#Mybatis注解开发" class="headerlink" title="Mybatis注解开发"></a>Mybatis注解开发</h2><ul><li>常用注解<ul><li>@Insert:实现新增</li><li>@Update:实现更新</li><li>@Delete:实现删除</li><li>@Select:实现查询</li><li>@Result:实现结果集封装</li><li>@Results:可以与@Result 一起使用，封装多个结果集</li><li>@ResultMap:实现引用@Results 定义的封装</li><li>@One:实现一对一结果集封装</li><li>@Many:实现一对多结果集封装</li><li>@SelectProvider: 实现动态 SQL 映射</li><li>@CacheNamespace:实现注解二级缓存的使用</li></ul></li></ul><ul><li><p>@Results 注解</p><ul><li>代替的是标签<code>&lt;resultMap&gt;</code></li><li>该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（{@Result（），@Result（）}）或@Results（@Result（））</li></ul></li><li><p>@Resutl 注解</p><ul><li>代替了 <code>&lt;id&gt;</code>标签和<code>&lt;result&gt;</code>标签@Result 中 属性介绍：id 是否是主键字段column 数据库的列名property 需要装配的属性名one 需要使用的@One 注解（@Result（one=@One）（）））many 需要使用的@Many 注解（@Result（many=@many）（）））</li></ul></li><li><p>@One 注解（一对一）</p><ul><li>代替了<code>&lt;assocation&gt;</code>标签，是多表查询的关键，在注解中用来指定子查询返回<strong>单一对象</strong>。</li><li>@One 注解属性介绍：<ul><li><code>select</code>：指定用来多表查询的 sqlmapper</li><li><code>fetchType</code>： 会覆盖全局的配置参数 lazyLoadingEnabled。</li></ul></li><li>使用格式：<code>@Result(column=&quot; &quot;,property=&quot;&quot;,one=@One(select=&quot;&quot;))</code></li></ul></li><li><p>@Many 注解（多对一）</p><ul><li>代替了<code>&lt;Collection&gt;</code>标签,是是多表查询的关键，在注解中用来指定子查询返回<strong>对象集合</strong>。</li><li>注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType一般为 ArrayList）但是注解中可以不定义；</li><li>使用格式：<code>@Result(property=&quot;&quot;,column=&quot;&quot;,many=@Many(select=&quot;&quot;))</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://coderjeremy.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Serializable</title>
    <link href="https://coderjeremy.github.io/2020/03/08/Serializable/"/>
    <id>https://coderjeremy.github.io/2020/03/08/Serializable/</id>
    <published>2020-03-08T14:27:41.000Z</published>
    <updated>2020-03-08T14:27:53.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><ul><li>java.io.Serializable</li><li>序列化接口没有方法或字段，仅用于标识可序列化的语义。</li><li>一个类只有实现了Serializable接口，它的对象才能被序列化</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</li><li>序列化：把对象转换为字节序列的过程称</li><li>反序列化：把字节序列恢复为对象的过程</li></ul><h2 id="序列化原因"><a href="#序列化原因" class="headerlink" title="序列化原因"></a>序列化原因</h2><ul><li>将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本</li><li>按值将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复</li><li>要持久化和网络传输就得转为字节流，所以在分布式应用中及设计数据持久化的场景中，就得实现序列化</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>实现Serializable接口：<code>implements Serializable</code></li><li>定义serialversionUID变量：<code>private static final long serialVersionUID = 1L;</code></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>在NoSql数据库中，并没有与我们java基本类型对应的数据结构，所以在往nosql数据库中存储时，我们就必须将对象进行序列化</li><li>同时在网络传输中我们要注意到两个应用中javabean的serialVersionUID要保持一致，不然就不能正常的进行反序列化。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Serializable接口&quot;&gt;&lt;a href=&quot;#Serializable接口&quot; class=&quot;headerlink&quot; title=&quot;Serializable接口&quot;&gt;&lt;/a&gt;Serializable接口&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;java.io.Serializ
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://coderjeremy.github.io/2020/03/08/Redis/"/>
    <id>https://coderjeremy.github.io/2020/03/08/Redis/</id>
    <published>2020-03-08T14:25:10.000Z</published>
    <updated>2020-03-08T14:26:26.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li>概念：Redis是一款高性能的NoSQL系列 非关系型数据库</li><li>NoSQL：NoSQL = Not Only SQL，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指<strong>非关系型的数据库</strong>。<blockquote><p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p></blockquote></li></ul><h2 id="NoSQL和关系型数据库的比较"><a href="#NoSQL和关系型数据库的比较" class="headerlink" title="NoSQL和关系型数据库的比较"></a>NoSQL和关系型数据库的比较</h2><ul><li>优点：<ul><li>成本：NoSQL数据库简单易部署，基本都是开源软件，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li><li>查询速度：NoSQL数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及NoSQL数据库。</li><li>存储数据的格式：NoSQL的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li><li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</li></ul></li></ul><ul><li><p>缺点</p><ul><li>维护的工具和资料有限，因为NoSQL是属于新的技术，不能和关系型数据库10几年的技术同日而语。</li><li>不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</li><li>不提供关系型数据库对事务的处理。</li></ul></li><li><p>非关系型数据库的优势</p><ul><li>高性能：性能NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li>易扩展：可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul></li><li><p>关系型数据库的优势</p><ul><li>复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持使得对于安全性能很高的数据访问要求得以实现。</li></ul></li><li><p>总结：关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在Nosql数据库中备份存储关系型数据库的数据N</p></li></ul><h2 id="主流的NoSQL产品"><a href="#主流的NoSQL产品" class="headerlink" title="主流的NoSQL产品"></a>主流的NoSQL产品</h2><ul><li>键值(Key-Value)存储数据库<ul><li>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</li><li>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </li><li>数据模型： 一系列键值对</li><li>优势： 快速查询</li><li>劣势： 存储的数据缺少结构化</li></ul></li><li>列存储数据库<ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul></li><li>文档型数据库<ul><li>相关产品：CouchDB、MongoDB</li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型： 一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势： 查询性能不高，而且缺乏统一的查询语法</li></ul></li><li>图形(Graph)数据库<ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法。</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li></ul></li></ul><h2 id="Redis详解"><a href="#Redis详解" class="headerlink" title="Redis详解"></a>Redis详解</h2><ul><li><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p><ul><li>字符串类型 string</li><li>哈希类型 hash</li><li>列表类型 list</li><li>集合类型 set</li><li>有序集合类型 sortedset</li></ul></li><li><p>应用场景</p><ul><li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li><li>聊天室的在线好友列表</li><li>任务队列。（秒杀、抢购、12306等等）</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理（可以精确到毫秒</li><li>分布式集群架构中的session分离</li></ul></li></ul><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><ul><li>官网：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li><li>中文网：<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">http://www.redis.net.cn/</a></li><li>解压直接可以使用：<ul><li>redis.windows.conf：配置文件</li><li>redis-cli.exe：redis的客户端</li><li>redis-server.exe：redis服务器端</li></ul></li></ul><h2 id="Redis操作命令和数据结构"><a href="#Redis操作命令和数据结构" class="headerlink" title="Redis操作命令和数据结构"></a>Redis操作命令和数据结构</h2><ul><li>redis存储的是：key,value 格式的数据，其中<strong>key</strong>都是<strong>字符串</strong>，<strong>value</strong>有5种不同的数据结构:<ul><li>字符串类型 string</li><li>哈希类型 hash ： map格式(key,value)</li><li>列表类型 list ： linkedlist格式。支持重复元素</li><li>集合类型 set  ： 不允许重复元素</li><li>有序集合类型 sortedset：不允许重复元素，且元素有顺序</li></ul></li></ul><h3 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型 String"></a>字符串类型 String</h3><ul><li>存储：set key value</li><li>获取：get key</li><li>删除：del key</li></ul><h3 id="哈希类型-Hash"><a href="#哈希类型-Hash" class="headerlink" title="哈希类型 Hash"></a>哈希类型 Hash</h3><ul><li>存储：hset key field value</li><li><p>获取：</p><ul><li>获取指定的field对应的值：hget key field</li><li>获取所有的field和value： hgetall key</li></ul></li><li><p>删除：hdel key field</p></li></ul><h3 id="列表类型-List"><a href="#列表类型-List" class="headerlink" title="列表类型 List"></a>列表类型 List</h3><ul><li>可以添加一个元素到列表的头部（左边）或者尾部（右边）</li><li><p>添加： </p><ul><li>lpush key value：将元素加入列表左边</li><li>rpush key value：将元素加入列表右边</li></ul></li><li><p>获取：</p><ul><li>范围获取：lrange key start end </li></ul></li><li><p>删除：</p><ul><li>lpop key：删除列表最左边的元素，并将元素返回</li><li>rpop key：删除列表最右边的元素，并将元素返回</li></ul></li></ul><h3 id="集合类型-Set"><a href="#集合类型-Set" class="headerlink" title="集合类型 Set"></a>集合类型 Set</h3><ul><li>不允许重复元素</li><li>存储：sadd key value</li><li>获取：smembers key：获取set集合中所有元素</li><li>删除：srem key value：删除set集合中的某个元素</li></ul><h3 id="有序集合类型-Sorted-Set"><a href="#有序集合类型-Sorted-Set" class="headerlink" title="有序集合类型 Sorted Set"></a>有序集合类型 Sorted Set</h3><ul><li>不允许重复元素，且元素有顺序。每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li><li>存储：zadd key score value</li><li>获取：zrange key start end [withscores]</li><li>删除：zrem key value</li></ul><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ul><li>查询所有的键：keys *</li><li>获取键对应的value的类型：type key</li><li>删除指定的key value ：del key</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul><li>redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</li><li><p>redis持久化机制：</p><ul><li><p><strong>RDB</strong>：默认方式，不需要进行配置。在一定的间隔时间中，检测key的变化情况，然后持久化数据</p><ul><li><p>编辑<code>redis.windwos.conf</code>文件</p>  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># after <span class="number">900</span> sec (<span class="number">15</span> min) if at least <span class="number">1</span> <span class="type">key</span> <span class="section">changed</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line"># after <span class="number">300</span> sec (<span class="number">5</span> min) if at least <span class="number">10</span> keys <span class="section">changed</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line"># after <span class="number">60</span> sec if at least <span class="number">10000</span> keys <span class="section">changed</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p>重新启动redis服务器，并指定配置文件名称<br>  <code>redis-server.exe redis.windows.conf</code></p></li></ul></li></ul></li></ul><pre><code>- **AOF**：日志记录的方式。可以记录每一条命令的操作。可以每一次命令操作后，持久化数据    - 编辑`redis.windwos.conf`文件        <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span><span class="string">（关闭aof）</span> <span class="bullet">--&gt;</span> <span class="string">appendonly</span> <span class="literal">yes</span> <span class="string">（开启aof）</span></span><br><span class="line"><span class="comment"># appendfsync always ： 每一次操作都进行持久化</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="string">：</span> <span class="string">每隔一秒进行一次持久化</span></span><br><span class="line"><span class="comment"># appendfsync no ： 不进行持久化</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="Java客户端：Jedis"><a href="#Java客户端：Jedis" class="headerlink" title="Java客户端：Jedis"></a>Java客户端：Jedis</h2><ul><li>Jedis：一款java操作redis数据库的工具</li><li><p>步骤</p><ul><li>导入Jedis的jar包</li><li>获取连接：<code>Jedis jedis = new Jedis(&quot;localhost&quot;,6379);</code></li><li>操作数据库：<code>jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);</code></li><li>关闭连接：<code>edis.close();</code></li></ul></li><li><p>特殊方法：</p><ul><li>指定数据过期时间：<code>setex(&quot;key&quot;,time,&quot;value&quot;)</code></li></ul></li><li><p>JedisPool：Jedis连接池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"><span class="comment">//3. 使用</span></span><br><span class="line">jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li><li><p>连接池工具类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(<span class="string">"jedis.properties"</span>);</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取连接方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;概念：Redis是一款高性能的NoSQL系列 非关系型数据库&lt;/li&gt;
&lt;li&gt;NoSQL：NoSQL 
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://coderjeremy.github.io/tags/Redis/"/>
    
      <category term="NoSQL" scheme="https://coderjeremy.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://coderjeremy.github.io/2020/03/08/Maven/"/>
    <id>https://coderjeremy.github.io/2020/03/08/Maven/</id>
    <published>2020-03-08T14:25:00.000Z</published>
    <updated>2020-03-08T14:25:43.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p></li><li><p>功能：</p><ul><li>jar包管理</li><li>构建工程</li><li>单元测试</li><li>项目部署</li></ul></li><li><p>构建：从编译、测试、运行、打包、安装 、部署整个过程都交给 maven 进行管理，</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>下载</li><li>配置环境变量</li><li>目录结构<ul><li>bin：存放了maven的命令</li><li>boot：存放了一些maven本身的引导程序，如类加载器等</li><li>conf：存放了maven的一些配置文件，如 setting.xml 文件</li><li>lib：存放了maven本身运行所需的一些jar包</li></ul></li></ul><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><ul><li>本地仓库：<ul><li>修改本地仓库：<code>/conf/settings.xml</code><ul><li><code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></li></ul></li></ul></li><li>远程仓库</li><li>中央仓库</li></ul><h2 id="Maven项目标准目录结构"><a href="#Maven项目标准目录结构" class="headerlink" title="Maven项目标准目录结构"></a>Maven项目标准目录结构</h2><ul><li><code>src/main/java</code> ：核心代码部分</li><li><code>src/main/resources</code> ：配置文件部分</li><li><code>src/test/java</code> ：测试代码部分</li><li><code>src/test/resources</code> ：测试配置文件 </li><li><code>src/main/webapp</code> ；页面资源</li></ul><h2 id="Maven指令"><a href="#Maven指令" class="headerlink" title="Maven指令"></a>Maven指令</h2><table><thead><tr><th>指令</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td><code>mvn clean</code></td><td>清理命令</td><td>删除 target 目录及内容</td></tr><tr><td><code>mvn compile</code></td><td>编译命令</td><td>是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。</td></tr><tr><td><code>mvn test</code></td><td>测试命令</td><td>执行 src/test/java 下的单元测试类</td></tr><tr><td><code>mvn package</code></td><td>打包命令</td><td>对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包。</td></tr><tr><td><code>mvn install</code></td><td>安装命令</td><td>执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库</td></tr><tr><td><code>mvn deploy</code></td><td>发布命令</td><td>将maven的web项目部署到远程服务器</td></tr></tbody></table><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><ul><li>maven 对项目构建过程分为<strong>三套相互独立</strong>的生命周期<ul><li><strong>Clean Lifecycle</strong> : 清理生命周期。在进行真正的构建之前进行一些清理工作。</li><li><strong>Default Lifecycle</strong> : 默认生命周期。构建的核心部分，编译，测试，打包，部署等等。</li><li><strong>Site Lifecycle</strong> : 站点生命周期。生成项目报告，站点，发布站点。</li></ul></li></ul><h2 id="Maven概念模型"><a href="#Maven概念模型" class="headerlink" title="Maven概念模型"></a>Maven概念模型</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li>项目对象模型（Project Object Model）<ul><li>pom.xml<ul><li>项目信息</li><li>项目所依赖的jar包信息</li><li>项目运行环境信息，比如：jdk,tomcat等</li></ul></li></ul></li></ul><ul><li><p>依赖管理系统（Dependency Management System）</p><ul><li><p>通过maven的依赖管理对项目所依赖的jar包进行统一管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖关系 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit 的项目名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit 的模块名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit 版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖范围：单元测试时使用 junit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h3><ul><li>项目生命周期：maven 管理项目生命周期过程都是基于插件完成的。<ul><li>清理</li><li>编译</li><li>测试</li><li>打包</li><li>安装</li><li>部署</li></ul></li></ul><h3 id="坐标定义"><a href="#坐标定义" class="headerlink" title="坐标定义"></a>坐标定义</h3><ul><li>在pom.xml中定义坐标，内容包括：groupId、artifactid、version</li><li>POM基本配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> &gt;</span> ：文件的根节点 .</span><br><span class="line"><span class="tag">&lt;<span class="name">modelversion</span> &gt;</span> ： pom.xml 使用的对象模型版本</span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span> &gt;</span> ：项目名称，一般写项目的域名</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span> &gt;</span> ：模块名称，子项目名或模块名称</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span> &gt;</span> ：产品的版本号 .</span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span> &gt;</span> ：打包类型，一般有 jar、war、pom 等</span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> &gt;</span> ：项目的显示名，常用于 Maven 生成的文档。</span><br><span class="line"><span class="tag">&lt;<span class="name">description</span> &gt;</span> ：项目描述，常用于 Maven 生成的文档</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> ：项目依赖构件配置，配置项目依赖构件的坐标</span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> ：项目构建配置，配置编译、运行插件等。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
    
      <category term="maven" scheme="https://coderjeremy.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://coderjeremy.github.io/2020/03/08/Ajax&amp;Json/"/>
    <id>https://coderjeremy.github.io/2020/03/08/Ajax&amp;Json/</id>
    <published>2020-03-08T14:23:42.000Z</published>
    <updated>2020-03-08T14:24:38.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>AJAX：ASynchronous JavaScript And XML ，异步的JavaScript和XML</p></li><li><p>异步和同步：客户端和服务器相互通信的基础上</p><ul><li><strong>同步</strong>：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</li><li><strong>异步</strong>：客户端不需要再等待服务器端的响应。服务器处理请求的过程中，客户端可以进行其他的操作</li></ul></li><li><p>AJAX是一种在 <em>无需重新加载</em> 整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX可以网页实现异步更新。</p></li><li><p>提升用户体验</p></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li>原生JS实现方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1.创建核心对象</span></span><br><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 建立连接</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        1. 请求方式：GET、POST</span></span><br><span class="line"><span class="comment">            * get方式，请求参数在URL后边拼接。send方法为空参</span></span><br><span class="line"><span class="comment">            * post方式，请求参数在send方法中定义</span></span><br><span class="line"><span class="comment">        2. 请求的URL：</span></span><br><span class="line"><span class="comment">        3. 同步或异步请求：true（异步）或 false（同步）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajaxServlet?username=tom"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接受并处理来自服务器的响应结果</span></span><br><span class="line"><span class="comment">//获取方式 ：xmlhttp.responseText</span></span><br><span class="line"><span class="comment">//什么时候获取？当服务器响应成功后再获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span></span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断readyState就绪状态是否为4，判断status响应状态码是否为200</span></span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取服务器的响应结果</span></span><br><span class="line">        <span class="keyword">var</span> responseText = xmlhttp.responseText;</span><br><span class="line">        alert(responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>JQuery实现方式</p><ul><li><p><code>$.ajax()</code></p><ul><li>语法：<code>$.ajax({键值对})</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用$.ajax发送异步请求</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"ajaxServlet"</span>,<span class="comment">//请求路径</span></span><br><span class="line">    type:<span class="string">"POST"</span>,<span class="comment">//请求方式</span></span><br><span class="line">    <span class="comment">//data:"username=jack&amp;password=123",//请求参数</span></span><br><span class="line">    data:&#123;<span class="string">"username"</span>:<span class="string">"jack"</span>,<span class="string">"password"</span>:<span class="number">123</span>&#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(data);</span><br><span class="line">    &#125;,<span class="comment">//响应成功后的回调函数</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"出错了"</span>)</span><br><span class="line">    &#125;,<span class="comment">//表示如果请求响应出现错误，会执行的回调函数</span></span><br><span class="line">    dataType:<span class="string">"text"</span><span class="comment">//设置接收到的响应数据格式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>$.get()</code>：发送get请求</p><ul><li>语法：<code>$.get(url, [data], [callback], [type])</code></li><li>参数：<ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：响应结果查询</li></ul></li></ul></li><li><p><code>$.post()</code>：发送post请求</p><ul><li>语法：<code>$.post(url, [data], [callback], [type])</code></li><li>参数：<ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：响应结果查询</li></ul></li></ul></li></ul></li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>JSON：JavaScript Object Notation。JavaScript对象表示法</li><li>JSON现在多用于存储和交换文本信息的语法。进行数据的传输。</li><li>JSON 比 XML 更小、更快，更易解析</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p>基本规则</p><ul><li><p>数据在名称/值对中：json数据是由键值对构成的</p><ul><li>键用引号(单双都行)引起来，也可以不使用引号</li><li>值的取值类型：<ol><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）    <code>{&quot;persons&quot;:[{},{}]}</code></li><li>对象（在花括号中） <code>{&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}}</code></li><li>null</li></ol></li></ul></li><li><p>数据由逗号分隔</p></li><li>花括号保存对象</li><li>方括号保存数组</li></ul></li><li><p>获取数据</p><ul><li>json对象.键名</li><li>json对象[“键名”]</li><li>数组对象[索引]</li></ul></li><li><p>遍历:for in循环</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">name</span>:<span class="string">"飞鸟"</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">gender</span>:<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json嵌套数组</span></span><br><span class="line"><span class="keyword">var</span> people=&#123;</span><br><span class="line">    person:[</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟"</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">gender</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">"麻衣"</span>,<span class="attr">age</span>:<span class="number">22</span>,<span class="attr">gender</span>:<span class="literal">true</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组嵌套json</span></span><br><span class="line"><span class="keyword">var</span> persons=[</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="attr">age</span>:<span class="number">24</span>,<span class="attr">gender</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">"李四"</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">gender</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">"王五"</span>,<span class="attr">age</span>:<span class="number">14</span>,<span class="attr">gender</span>:<span class="literal">false</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for in遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;persons.length;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = persons[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> p)&#123;</span><br><span class="line">        alert(key+<span class="string">":"</span>+p[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON数据和Java对象的相互转换"><a href="#JSON数据和Java对象的相互转换" class="headerlink" title="JSON数据和Java对象的相互转换"></a>JSON数据和Java对象的相互转换</h2><ul><li><p>JSON解析器</p><ul><li>Jsonlib,Gson,fastjson,jackson</li></ul></li><li><p>JSON转Java对象</p><ul><li>导入jackson的相关jar包</li><li>创建Jackson核心对象 ObjectMapper</li><li>调用ObjectMapper的相关方法进行转换<ul><li><code>readValue(json字符串数据,Class)</code></li></ul></li></ul></li></ul><ul><li><p>Java对象转换为JSON</p><ul><li><p>使用步骤：</p><ul><li>导入jackson相关jar包</li><li>创建jackson核心对象 ObjectMapper</li><li>调用ObjectMapper的相关方法进行转换</li><li><p>转换方法：</p><ul><li><code>writeValue(参数1，obj)</code>:<ul><li>参数1：<ul><li>File：将obj对象转换为JSON字符串，并保存到指定的文件中</li><li>Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</li><li>OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</li></ul></li></ul></li><li><code>writeValueAsString(obj)</code>:将对象转为json字符串</li></ul></li><li><p>注解：</p><ul><li><code>@JsonIgnore</code>：排除属性。</li><li><code>@JsonFormat</code>：属性值得格式化<code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code></li></ul></li><li><p>复杂java对象转换</p><ol><li>List：数组</li><li>Map：对象格式一致</li></ol></li></ul></li></ul></li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><ul><li><p>校验用户名是否存在</p><ul><li>输入用户名</li><li>事件：失去焦点</li><li>发送ajax请求</li><li>服务器响应 </li></ul></li><li><p>服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：</p><ol><li>$.get(type):将最后一个参数type指定为”json”</li><li>在服务器端设置MIME类型：response.setContentType(“application/json;charset=utf-8”);//设置响应数据格式</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AJAX&quot;&gt;&lt;a href=&quot;#AJAX&quot; class=&quot;headerlink&quot; title=&quot;AJAX&quot;&gt;&lt;/a&gt;AJAX&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h
      
    
    </summary>
    
    
      <category term="json" scheme="https://coderjeremy.github.io/tags/json/"/>
    
      <category term="ajax" scheme="https://coderjeremy.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Cookie&amp;Session</title>
    <link href="https://coderjeremy.github.io/2020/03/03/Cookie&amp;Session/"/>
    <id>https://coderjeremy.github.io/2020/03/03/Cookie&amp;Session/</id>
    <published>2020-03-03T06:50:29.000Z</published>
    <updated>2020-03-03T06:51:37.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><ul><li><p>会话：一次会话中包含多次请求和响应</p><ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li></ul></li><li><p>功能：在一次会话的范围内的多次请求间，共享数据</p></li><li><p>方式：</p><ul><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ul></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>客户端会话技术，将数据保存到客户端</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul><li>创建Cookie对象，绑定数据：<code>new Cookie(String,String)</code></li><li>发送Cookie对象：<code>response.addCookie(Cookie cookie)</code></li><li>获取Cookie对象：<code>Cookie[] request.getCookies()</code></li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>基于响应头<code>set-cookie</code>和请求头<code>cookie</code>实现</li></ul><h3 id="Cookie的一些细节"><a href="#Cookie的一些细节" class="headerlink" title="Cookie的一些细节"></a>Cookie的一些细节</h3><ul><li><p>一次可以发送多个Cookie：可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可</p></li><li><p>Cookie在浏览器中保存的时间</p><ul><li>默认：浏览器关闭，Cookie数据被销毁</li><li>持久化存储：<code>setMaxAge(int seconds)</code><ul><li>正数：将Cookie数据写到硬盘的文件中。并指定cookie存活时间，到时间后，自动销毁。</li><li>负数：默认值，关闭删除</li><li>0：删除cookie信息</li></ul></li></ul></li><li><p>Cookie中文数据</p><ul><li><p>tomcat8之前cookie不能直接存储中文数据</p><ul><li>解决方法：将中文数据转码–一般采用URL编码<ul><li>编码：<code>URLEncode.encode(String str,&quot;utf-8&quot;)</code></li><li>解码：<code>URLDecode.decode(String str,&quot;utf-8&quot;)</code></li></ul></li></ul></li><li><p>tomcat8之后cookie支持存储中文数据，但是不支持特殊字符(使用URL解决)</p></li></ul></li></ul><ul><li><p>Cookie数据共享</p><ul><li>默认：项目内cookie共享</li><li><p>同一个服务器，多个Web项目：<code>setPath(String path)</code>。设置cookie的获取范围，默认情况下，设置当前的虚拟目录，如果需要共享，可以将Path设置为<code>/</code></p></li><li><p>不同服务器，不同项目：<code>setDomain(String path)</code>：如果设置一级域名相同，那么多个服务器之间cookie可以共享</p><blockquote><p>例如：setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p></blockquote></li></ul></li></ul><h3 id="Cookie的特点和作用"><a href="#Cookie的特点和作用" class="headerlink" title="Cookie的特点和作用"></a>Cookie的特点和作用</h3><ul><li>Cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie的大小有限制(4KB)以及对同一个域名下的总cookie数量也有限制(20)</li><li>作用：<ol><li>cookie一般用于存储少量的不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ol></li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。<code>HttpSession</code></li></ul><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><ul><li><p>创建：<code>HttpSession session = request.getSession();</code></p></li><li><p>使用：</p><ul><li><code>Object getAttribute(String name)</code></li><li><code>void setAttribute(String name,Object value)</code></li><li><code>void removeAttribute(String name)</code></li></ul></li></ul><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>Session的实现依赖于Cookie（set-cookie:JSESSIONID）</li></ul><h3 id="Session的一些细节"><a href="#Session的一些细节" class="headerlink" title="Session的一些细节"></a>Session的一些细节</h3><ul><li><p>当客户端关闭后，服务器不关闭，两次获取的Session不是同一个</p><ul><li><p>如果需要相同，可以创建Cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,session.getId());</span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当客户端关闭后，服务器关闭后，两次获取的Session不是同一个</p><ul><li>为了确保数据不丢失，tomcat会自动完成以下工作<ul><li>session的<strong>钝化</strong>：在服务器正常关闭之前，将session对象系列化到硬盘上</li><li>session的<strong>活化</strong>：在服务器启动后，将session文件转化为内存中的session对象</li></ul></li></ul></li><li><p>session的销毁</p><ul><li>服务器关闭</li><li>session对象调用<code>invalidate()</code></li><li><p>session默认失效时间 30min，可以修改配置参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Session的特点"><a href="#Session的特点" class="headerlink" title="Session的特点"></a>Session的特点</h3><ul><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ul><h3 id="Session与Cookie的区别"><a href="#Session与Cookie的区别" class="headerlink" title="Session与Cookie的区别"></a>Session与Cookie的区别</h3><ul><li>session存储数据在服务器端，cookie在客户端</li><li>session没有数据大小限制，cookie有</li><li>session数据安全，cookie相对不安全</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;会话技术&quot;&gt;&lt;a href=&quot;#会话技术&quot; class=&quot;headerlink&quot; title=&quot;会话技术&quot;&gt;&lt;/a&gt;会话技术&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;会话：一次会话中包含多次请求和响应&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次会话：浏览器第一次给服务器资源发送请求，
      
    
    </summary>
    
    
      <category term="cookie" scheme="https://coderjeremy.github.io/tags/cookie/"/>
    
      <category term="session" scheme="https://coderjeremy.github.io/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>过滤器&amp;监听器</title>
    <link href="https://coderjeremy.github.io/2020/03/03/%E8%BF%87%E6%BB%A4%E5%99%A8&amp;%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://coderjeremy.github.io/2020/03/03/过滤器&amp;监听器/</id>
    <published>2020-03-03T06:43:07.000Z</published>
    <updated>2020-03-03T06:46:45.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter:过滤器"></a>Filter:过滤器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li><li>作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li>定义一个类，实现Filter接口（javax.servlet.filter）</li><li>复写方法</li><li>配置拦截路径（拦截准备去访问的资源）<ul><li>web.xml</li><li>注解（@WebFilter）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Filter过滤器被执行了"</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器细节"><a href="#过滤器细节" class="headerlink" title="过滤器细节"></a>过滤器细节</h2><ul><li><p>web.xml配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.nogizaka.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--拦截路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>过滤器执行流程</p><ol><li>执行过滤器</li><li>执行放行后的资源</li><li>回来执行过滤器放行代码下的代码</li></ol></li><li><p>过滤器生命周期方法</p><ol><li><p><code>init</code>：在服务器启动后，会创建Filter对象，然后调用init方法。<strong>只执行一次</strong>。用于加载资源</p></li><li><p><code>doFilter</code>：每一次请求被拦截资源时，会执行。<strong>执行多次</strong></p></li><li><p><code>destroy</code>：在服务器关闭后，Filter对象被销毁。如果服务器是<strong>正常关闭</strong>，则会执行destroy方法。<strong>只执行一次</strong>。用于释放资源</p></li></ol></li><li><p>过滤器配置详解</p><ul><li><p>拦截路径配置：</p><ol><li>具体资源路径：<code>/index.jsp</code>,只有访问index.jsp资源时，过滤器才会被执行</li><li>拦截目录：<code>/user/*</code>，访问/user下的所有资源时，过滤器都会被执行</li><li>后缀名拦截：<code>*.jsp</code>，访问所有后缀名为jsp资源时，过滤器都会被执行</li><li>拦截所有资源：<code>/*</code>，访问所有任意资源时，过滤器都会被执行</li></ol></li><li><p>拦截方式配置：</p><ul><li><p>注解配置：设置dispatcherTypes的属性</p><ul><li>REQUEST：默认值，浏览器直接请求资源</li><li>FORWARD：转发访问资源</li><li>INCLUDE：包含访问资源</li><li>ERROR：错误跳转资源</li><li>ASYNC：异步访问资源</li></ul></li><li><p>web.xml</p><ul><li>设置<code>&lt;dispatcher&gt;&gt;&lt;/dispatcher&gt;</code>标签</li></ul></li></ul></li></ul></li><li><p>过滤器链(配置多个过滤器)</p><ul><li><p>执行顺序：如果有两个过滤器1，过滤器2</p><ul><li>过滤器1-&gt;过滤器2-&gt;资源执行-&gt;过滤器2-&gt;过滤器1</li></ul></li><li><p>过滤器先后顺序：</p><ul><li>注解配置：按照类名的字符串比较规则，值小的先执行</li><li>web.xml配置：<code>&lt;filter-mapper&gt;</code>谁先定义谁先执行</li></ul></li></ul></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li>真实对象：被代理的对象</li><li>代理对象</li><li>代理模式：代理对象 代理 真实对象，达到增强真实对象功能的目的</li><li><p>实现方法：</p><ul><li>静态代理：有一个类文件描述代理模式</li><li><p>动态代理：在内存中形成代理类</p><ul><li><p>实现步骤：</p><ol><li>代理对象和真实对象实现相同的接口</li><li>代理对象 = <code>Proxy.newProxyInstance()</code></li><li>使用代理对象调用方法</li><li>增强方法</li></ol></li><li><p>增强方式</p><ol><li>增强参数列表</li><li>增强返回值类型</li><li>增强方法体执行逻辑 </li></ol></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建真实对象</span></span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 动态代理增强Apple对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 三个对象：</span></span><br><span class="line"><span class="comment">        *   1.类加载器:真实对象.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">        *   2.接口数组:真实对象.getClass().getInterfaces()</span></span><br><span class="line"><span class="comment">        *   3.处理器:使用匿名内部类 new InvocationHandler()</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        SaleComputer proxy_apple = (SaleComputer) Proxy.newProxyInstance(apple.getClass().getClassLoader(), apple.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行</span></span><br><span class="line"><span class="comment">            * 参数：</span></span><br><span class="line"><span class="comment">            *   1. proxy:代理对象</span></span><br><span class="line"><span class="comment">            *   2. method:代理对象的调用的方法，被封装为的对象</span></span><br><span class="line"><span class="comment">            *   3. args:代理对象调用的方法时，传递的实际参数</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 判断是否是sale方法</span></span><br><span class="line">                <span class="keyword">if</span>(method.getName()==<span class="string">"sale"</span>)&#123;</span><br><span class="line">                    <span class="comment">// 增强参数</span></span><br><span class="line">                    <span class="keyword">double</span> money = (<span class="keyword">double</span>) args[<span class="number">0</span>];</span><br><span class="line">                    money += <span class="number">1000</span>;</span><br><span class="line">                    <span class="comment">// 使用真实对象调用该方法</span></span><br><span class="line">                    String obj = (String) method.invoke(apple, money);</span><br><span class="line">                    <span class="keyword">return</span> obj+<span class="string">"和鼠标"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不是sale方法，将实际参数返回</span></span><br><span class="line">                    Object obj = method.invoke(apple, args);</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用方法</span></span><br><span class="line">        String computer = proxy_apple.sale(<span class="number">8000</span>);</span><br><span class="line">        System.out.println(computer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener:监听器"></a>Listener:监听器</h1><ul><li><p>概念：web的三大组件之一</p><ul><li>事件监听机制<ul><li>事件    ：一件事情</li><li>事件源 ：事件发生的地方</li><li>监听器 ：一个对象</li><li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li></ul></li></ul></li><li><p><code>ServletContextListener</code>：监听ServletContext对象的创建和销毁</p><ul><li><p>方法</p><ul><li><code>void contextDestroyed(ServletContextEvent sce)</code> ：ServletContext对象被销毁之前会调用该方法</li><li><code>void contextInitialized(ServletContextEvent sce)</code> ：ServletContext对象创建后会调用该方法</li></ul></li><li><p>步骤：</p><ol><li>定义一个类，实现ServletContextListener接口</li><li>复写方法</li><li><p>配置</p><ul><li><p>注解：<code>@WebListener</code></p></li><li><p>web.xml</p></li></ul></li></ol></li></ul></li></ul><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>全类名<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Filter-过滤器&quot;&gt;&lt;a href=&quot;#Filter-过滤器&quot; class=&quot;headerlink&quot; title=&quot;Filter:过滤器&quot;&gt;&lt;/a&gt;Filter:过滤器&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="filter" scheme="https://coderjeremy.github.io/tags/filter/"/>
    
      <category term="listener" scheme="https://coderjeremy.github.io/tags/listener/"/>
    
  </entry>
  
  <entry>
    <title>JSP</title>
    <link href="https://coderjeremy.github.io/2020/03/01/JSP/"/>
    <id>https://coderjeremy.github.io/2020/03/01/JSP/</id>
    <published>2020-03-01T11:50:19.000Z</published>
    <updated>2020-03-02T16:34:56.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><ul><li><p>概念：Java Server Pages：Java服务器端页面</p></li><li><p>原理：JSP本质上是一个Servlet</p><ol><li>服务器解析请求消息，找是否有index.jsp页面</li><li>如果有，会将index.jsp转换为.java文件</li><li>编译.java文件，生成.class字节码文件</li><li>由字节码文件提供访问</li></ol></li><li><p>JSP的脚本：JSP定义Java代码的方式</p><ol><li><code>&lt;% 代码 %&gt;</code>：定义的java代码，在<code>service</code>方法中。service方法中可以定义什么，该脚本就可以定义什么内容</li><li><code>&lt;%! 代码 %&gt;</code>：定义的java代码，在jsp转换后的java类的成员位置</li><li><code>&lt;%= 代码 %&gt;</code>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么</li></ol></li><li><p>JSP的内置对象</p><ul><li>在jsp页面中不需要获取和创建，可以直接使用的对象</li><li>一共9个内置对象<ul><li><code>request</code></li><li><code>response</code></li><li><code>out</code>：字符输出流对象，可以将数据输出到页面上。和response.getWriter()类似<ul><li><code>response.getWriter()</code>和<code>out.write()</code>的区别<ul><li>在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</li><li><code>response.getWriter()</code>数据输出永远在<code>out.write()</code>之前</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h2><ul><li>作用：用于配置JSP页面，导入资源文件</li><li>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ...%&gt;</code></li><li><p>分类：</p><ul><li><p><code>page</code>：配置JSP页面</p><ul><li><p><code>contentType</code>：等同于response.setContentType()</p><ol><li>设置响应体的MIME类型以及字符集</li><li>设置当前JSP页面的编码。（只能是高级的IDE才能生效，如果使用低级工具，则需要设置<code>pageEncoding</code>属性设置当前页面的字符集）</li></ol></li><li><p><code>import</code>：导包</p></li><li><p><code>errorPage</code>：当前页面发生异常后，回自动跳转到指定的错误页面</p></li><li><p><code>isErrorPage</code>：标识当前页面是否是错误页面</p><ul><li><p>true：是，可以使用内置对象<code>exception</code></p></li><li><p>false；否，默认值。不可以使用内置对象exception<br></p></li></ul></li></ul></li><li><code>include</code>：页面包含的。导入页面的资源文件<ul><li>格式： <code>&lt;%@inlude file=&quot;xxx.jsp&quot;%&gt;</code><br></li></ul></li><li><code>taglib</code>：导入资源，导入标签库<ul><li>格式：<code>&lt;%@ taglib prefix=&quot; &quot; uri=&quot; &quot; %&gt;</code></li><li>prefix：前缀，自定义的</li></ul></li></ul></li></ul><h2 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h2><ul><li>html注释：<br>  <code>&lt;!-- --&gt;</code>：只能注释html代码片段</li><li>jsp注释：推荐使用<br>  <code>&lt;%-- --%&gt;</code>：可以注释所有</li></ul><h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><table><thead><tr><th>变量名</th><th>真实类型</th><th>作用</th></tr></thead><tbody><tr><td>pageContext</td><td>PageContext</td><td>当前页面共享数据，还可以获取其他八个内置对象</td></tr><tr><td>request</td><td>HttpServletRequest</td><td>一次请求访问的多个资源(转发)</td></tr><tr><td>session</td><td>HttpSession</td><td>一次会话的多个请求间</td></tr><tr><td>application</td><td>ServletContext</td><td>所有用户间共享数据</td></tr><tr><td>response</td><td>HttpServletResponse</td><td>响应对象</td></tr><tr><td>page</td><td>Object</td><td>当前页面(Servlet)的对象  this</td></tr><tr><td>out</td><td>JspWriter</td><td>输出对象，数据输出到页面上</td></tr><tr><td>config</td><td>ServletConfig</td><td>Servlet的配置对象</td></tr><tr><td>exception</td><td>Throwable</td><td>异常对象</td></tr></tbody></table><h1 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h1><ul><li><p>jsp演变历史</p><ol><li>早期只有servlet，只能使用response输出标签数据，非常麻烦</li><li>后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中写大量的java代码，又写html标签，造成难于维护，难于分工协作</li><li>再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性</li></ol></li><li><p>MVC</p><ul><li><p>Model：模型。JavaBean</p><ul><li>完成具体的业务操作。如：查询数据库，封装对象</li></ul></li><li><p>View：View视图。JSP</p><ul><li>展示数据</li></ul></li><li><p>Controller：控制器。Servlet</p><ul><li>获取用户的输入</li><li>调用模型</li><li>将数据交给视图进行展示</li></ul></li></ul></li><li><p>优点：</p><ol><li>耦合性低，方便维护，可以利于分工协作</li><li>重用性高</li></ol></li><li><p>缺点：</p><ul><li>使得项目架构变得复杂，对开发人员要求高</li></ul></li></ul><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><ol><li>概念：Expression Language 表达式语言</li><li>作用：替换和简化jsp页面中java代码的编写</li><li>语法：<code>${表达式}</code></li><li><p>注意：JSP默认支持EL表达式。如果要忽略EL表达式</p><ul><li>设置jsp中<code>page</code>指令中：<code>isELIgnored=&quot;true&quot;</code>，忽略当前jsp页面中所有的el表达式</li><li><code>\${表达式}</code> ：忽略当前这个el表达式</li></ul></li><li><p>使用：</p><ul><li><p>运算</p><ol><li>算数运算符 ： + - * /(div) %(mod)</li><li>比较运算符： &gt; &lt; &gt;= &lt;= == !=</li><li>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</li><li><p>空运算符： empty</p><ul><li><p>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</p></li><li><p><code>${empty list}</code>：判断字符串、集合、数组对象是否为null或者长度为0</p></li><li><p><code>${not empty str}</code>：判断字符串、集合、数组对象是否不为null 并且长度大于0</p></li></ul></li></ol></li><li><p>获取值</p><ul><li>el表达式只能从域对象中获取值</li><li><p>语法：</p><ol><li><p><code>${域名称.键名}</code>：从指定域中获取指定键的值 </p><ul><li>pageScope–&gt;pageContext </li><li>requestScope–&gt;request</li><li>sessionScope–&gt;session</li><li>applicationScope–&gt;application（ServletContext</li></ul></li><li><p><code>${键名}</code>：表示依次从最小的域中查找是否有该键对应的值，直到找到为止</p></li><li><p>获取对象、List集合、Map集合的值</p><ul><li><p>对象：<code>${域名称.键名.属性名}</code></p><ul><li>本质上会区调用对象的<code>getter</code>方法</li></ul></li><li><p>List集合</p><ul><li><code>${域名称.键名[索引]}</code><br></li></ul></li><li><p>Map集合：</p><ul><li><code>${域名称.键名.key名称}</code></li><li><code>${域名称.键名[&quot;key名称&quot;]}</code><br></li></ul></li></ul></li></ol></li></ul></li><li><p>隐式对象：</p><ul><li>EL表达式中有11个隐式对象</li><li><code>pageContext</code>：获取JSP其他八个内置对象<br><ul><li><code>${pageContext.request.contextPath}</code>：在JSP页面动态获取虚拟目录</li></ul></li></ul></li></ul></li></ol><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><ul><li><p>概念：JavaServer Pages Tag Library JSP标准标签库</p><ul><li>由Apache组织提供的开源的免费的jsp标签</li></ul></li><li><p>作用：用于简化和替换jsp页面上的java代码</p></li><li><p>使用步骤：</p><ol><li>导入jstl相关的jar包：<br><br><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></li><li>引入标签库：taglib指令：<code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt;</code></li><li>使用标签</li></ol></li><li><p>常用的JSTL标签</p><ul><li><p>if：相当于java的if</p><ul><li><p>test：必须属性，接受boolean表达式</p><ul><li><p>如果表达式为true,则显示if标签体内容，如果为false，则不显示标签体内容</p></li><li><p>一般情况下，test属性值会结合EL表达式一起使用</p></li></ul></li><li><p>注意</p><ul><li>c:if标签没有else情况，需要else情况，则可以再定义一个c:if标签</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;h3&gt;这是真的&lt;/h3&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>choose：相当于java的switch语句</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==1&#125;&#125;"&gt;星期一&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==2&#125;&#125;"&gt;星期二&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==3&#125;&#125;"&gt;星期三&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==4&#125;&#125;"&gt;星期四&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==5&#125;&#125;"&gt;星期五&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==6&#125;&#125;"&gt;星期六&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;requestScope.day==7&#125;&#125;"&gt;星期日&lt;/c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;数字输入有误&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure></li><li><p>foreach：相当于java代码的for语句</p><ol><li><p>完成重复操作</p><ul><li>begin：开始值</li><li>end：结束值</li><li>var：临时变量</li><li>step：步长</li><li><p>varStatus：循环状态对象</p><ul><li>index：容器中元素的索引，从0开始</li><li>count：循环次数，从1开始</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">"0"</span> end=<span class="string">"5"</span> var=<span class="string">"i"</span> step=<span class="string">"1"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">    $&#123;s.index&#125;</span><br><span class="line">    $&#123;s.count&#125;&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>遍历容器</p><ul><li>item：容器对象</li><li>var：容器中元素的临时变量</li></ul></li></ol></li></ul></li></ul><h1 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h1><ol><li><p>界面层(表示层/web)：用户可以通过界面上的组件和服务器进行交互。</p><ul><li>接收用户参数，封装数据，调用业务逻辑层完成处理，转发jsp页面完成显示</li><li>SpringMVC</li></ul></li><li><p>业务逻辑层(service)：处理业务逻辑的。</p><ul><li>组合DAO层中的简单方法，形成复杂的业务逻辑操作</li><li>Spring</li></ul></li><li><p>数据访问层(dao)：操作数据存储文件。</p><ul><li>定义对于数据库基本的CRUD操作</li><li>Mybatis</li></ul></li></ol><img src="/2020/03/01/JSP/三层架构.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; title=&quot;JSP&quot;&gt;&lt;/a&gt;JSP&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;概念：Java Server Pages：Java服务器端页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原理：JSP本质
      
    
    </summary>
    
    
      <category term="jsp" scheme="https://coderjeremy.github.io/tags/jsp/"/>
    
      <category term="el" scheme="https://coderjeremy.github.io/tags/el/"/>
    
      <category term="jstl" scheme="https://coderjeremy.github.io/tags/jstl/"/>
    
      <category term="mvc" scheme="https://coderjeremy.github.io/tags/mvc/"/>
    
      <category term="三层架构" scheme="https://coderjeremy.github.io/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://coderjeremy.github.io/2020/02/27/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://coderjeremy.github.io/2020/02/27/HTTP协议/</id>
    <published>2020-02-27T10:18:59.000Z</published>
    <updated>2020-02-27T10:20:38.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Hyper Text Transfer Protocol ：超文本传输协议</li><li><p>特点：</p><ol><li>基于TCP/IP的高级协议</li><li>默认端口号：80</li><li>基于请求/响应模型：一次请求对应一次响应</li><li>无状态：每次请求之间相互独立，不能交互数据</li></ol></li><li><p>历史版本</p><ul><li><p>1.0 ：每次请求都会建立新的连接</p></li><li><p>1.1 ：可以复用连接</p></li></ul></li></ul><h2 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h2><ul><li><p>请求行</p><ul><li>格式：<code>请求方式 请求url 请求协议/版本</code></li><li><p>请求方式：共7种</p><ul><li><p>GET</p><ol><li>请求参数在请求行中，（在url后）</li><li>请求的url长度有限制</li><li>安全性低</li></ol></li><li><p>POST</p><ol><li>请求参数在请求体中。</li><li>请求的url长度没有限制</li><li>相对安全</li></ol></li></ul></li></ul></li><li><p>请求头</p><ul><li><p>客户端浏览器告诉服务器的一些信息</p></li><li><p>格式：<code>请求头名称 : 请求头值1,请求头值2...</code></p></li><li><p>常见请求头：</p><ul><li><p><code>User-Agent</code>：浏览器版本信息，可以在服务器端获取该头的信息，解决浏览器的兼容性问题</p></li><li><p><code>Referer</code>：包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。</p></li></ul></li></ul></li><li><p>请求空行</p><ul><li>空行：用于分割POST请求的请求头和请求体</li></ul></li><li><p>请求体（正文）</p><ul><li>封装POST请求消息的请求参数</li></ul></li></ul><h2 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h2><ul><li><p>响应行</p><ul><li>格式：<code>协议/版本 响应状态码 状态码描述</code></li><li><p>响应状态码：服务器高速客户端浏览器本次请求和响应的一个状态</p><ol><li><p><code>1xx</code>：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码</p></li><li><p><code>2xx</code>：成功。200</p></li><li><p><code>3xx</code>：重定向。</p><ul><li>302：重定向</li><li>304：访问缓存</li></ul></li><li><p><code>4xx</code>：客户端错误。</p><ul><li>404：请求路径没有对应的资源</li><li>405：请求方式没有对应的doXXX方法</li></ul></li><li><p><code>5xx</code>：服务器错误。500(服务器内部异常)</p></li></ol></li></ul></li><li><p>响应头</p><ul><li>格式：<code>头名称:值</code></li><li><p>常见的响应头：</p><ul><li><p><code>Content-Type</code>：服务器高速客户端本次响应体数据格式以及编码格式</p></li><li><p><code>Content-disposition</code>：服务器告诉客户端以什么样的格式打开响应体数据</p><ul><li><code>in-line</code>：默认值，在当前页眉内打开</li><li><code>attachment;filename=xxx</code>：以附件形式打开响应体。（文件下载）</li></ul></li></ul></li></ul></li><li><p>响应空行：分隔响应头和响应体</p></li><li><p>响应体：传输的数据</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://coderjeremy.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://coderjeremy.github.io/2020/02/27/Servlet/"/>
    <id>https://coderjeremy.github.io/2020/02/27/Servlet/</id>
    <published>2020-02-27T10:18:23.000Z</published>
    <updated>2020-02-27T10:21:52.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="Web服务器软件"><a href="#Web服务器软件" class="headerlink" title="Web服务器软件"></a>Web服务器软件</h2><ul><li>Web服务器软件：接收用户的请求，处理请求，做出响应。web容器，部署web项目。</li><li><p>常见的web服务器：</p><ul><li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</li></ul></li><li><p>Java SE：Java Standard Edition，Java 标准版。是Java技术的核心和基础，是Java ME和Java EE编程的基础。</p></li><li><p>Java EE：Java Platform Enterprise Edition企业级应用程序版本。Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</p></li><li><p>Java ME：Java Platform Micro Edition，是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。</p></li></ul><h2 id="Tomcat-1"><a href="#Tomcat-1" class="headerlink" title="Tomcat"></a>Tomcat</h2><ul><li><p>目录结构</p><ul><li>bin：可执行文件</li><li>conf：配置文件</li><li>libs：依赖jar包</li><li>logs：日志文件</li><li>temp：临时文件</li><li>webapps：存放web项目</li><li>work：存放运行时的数据</li></ul></li><li><p>可能遇到的问题</p><ul><li><p>黑窗一闪而过</p><ul><li>原因：没有正确配置JAVA_HOME环境变量</li></ul></li><li><p>启动报错</p><ul><li>端口被占用：找到占用的端口号，杀死该进程，或修改自身端口号(<code>查看进程和端口号netstat -ano</code>)</li><li><p>修改端口号：conf/server.xml</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span> <span class="attribute">protocol</span>=<span class="string">"HTTP/1.1"</span></span><br><span class="line">    <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span></span><br><span class="line">    <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端号。在访问时，就不用输入端口号</p></li></ul></li></ul></li><li><p>关闭</p><ul><li><p>正常关闭</p><ul><li>bin/shutdown.bat</li><li>ctrl+c</li></ul></li><li><p>强制关闭</p><ul><li>关闭窗口</li></ul></li></ul></li><li><p>部署</p><ul><li><p>简单部署：将项目打成一个war包，再将war包放置到webapps目录下。（war包会自动解压缩）</p></li><li><p>配置conf/server.xml文件</p>  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在&lt;Host&gt;标签体中配置</span><br><span class="line">&lt;Context docBase=<span class="string">"D:\xxx"</span> <span class="built_in">path</span>=<span class="string">"/xxx"</span> /&gt;</span><br><span class="line"><span class="comment">// docBase:项目存放的路径</span></span><br><span class="line"><span class="comment">// path：虚拟目录</span></span><br></pre></td></tr></table></figure></li><li><p>热部署：在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"D:\xxx"</span> /&gt;</span></span><br><span class="line">* 虚拟目录：xml文件的名称</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul><li>Server Applet：运行再服务器端的小程序<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2></li><li>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</li><li>Servlet就是一个接口，定义了Java类被浏览器访问到（tomcat识别）的规则</li><li>需要自定义一个类，实现Servlet接口，复写方法。</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li><p>创建JavaEE项目</p></li><li><p>定义一个类，实现Servlet接口</p><ul><li><code>public class 类名 implements Servlet</code></li></ul></li><li><p>实现接口中的抽象方法</p><ul><li>init：创建</li><li>ServletConfig：获取Servlet配置对象</li><li>service：提供服务</li><li>getServletInfo：获取Servlet信息</li><li>destroy：销毁</li></ul></li></ul><ul><li>配置Servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.nogizaka.servlet.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置映射路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>执行原理<ol><li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li><li>查找<code>web.xml</code>文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li><li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li><li>tomcat会将字节码文件加载进内存，并且创建其对象</li><li>调用其方法</li></ol></li></ul><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><code>init</code>方法，只执行一次</li><li>默认情况：第一次被访问时，Servlet被创建</li><li><p>配置执行创建时机：</p><ol><li>在<code>&lt;servlet&gt;</code>标签下配置<code>&lt;load-on-startup&gt;</code></li><li>负数：第一次被访问时创建</li><li>0或正整数：服务器启动时创建</li></ol></li><li><p>注意：Servlet的iniy方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。</p><ul><li>多个用户同时访问时，可能存在线程安全问题</li><li>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要修改值。</li></ul></li></ul><h3 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h3><ul><li>提供服务：执行<code>service</code>方法，执行多次</li><li>每次访问Servlet时，service方法都会被调用一次</li></ul><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ul><li>销毁：<code>destroy</code>方法，只执行一次</li><li>只有服务器正常关闭时，才会执行destroy方法。</li><li><code>destroy方法</code>在Servlet被销毁之前执行，一般用于释放资源</li></ul><h2 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h2><ul><li><p>支持注解配置，无需web.xml</p></li><li><p>步骤</p><ol><li>创建JavaEE项目。选择Servlet的版本3.0以上，可以不创建web.xml</li><li>定义一个类，实现Servlet接口</li><li>复写方法</li><li><p>在类上使用<code>@WebServlet</code>注解，进行配置</p><ul><li><p><code>@WebServlet(urlPatterns = &quot;资源路径&quot;)</code></p></li><li><p><code>@WebServlet</code></p></li></ul></li></ol></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)b</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//相当于&lt;Servlet-name&gt;</span></span><br><span class="line"></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//代表urlPatterns()属性配置</span></span><br><span class="line"></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//相当于&lt;url-pattern&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;<span class="comment">//相当于&lt;load-on-startup&gt;</span></span><br><span class="line"></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">displayName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><ul><li><p>IDEA会为每一个tomcat部署的项目单独建立一份配置文件</p><ul><li>查看控制台的log：Using CATALINA_BASE</li></ul></li><li><p><code>工作空间项目</code>和<code>tomcat部署的web项目</code></p><ul><li>tomcat真正访问的是“tomcat部署的web项目”(out文件夹)，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源</li><li>WEB-INF目录下的资源不能被浏览器直接访问。</li></ul></li></ul><h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><pre><code><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Servlet <span class="comment">-- 接口</span></span><br><span class="line">    |</span><br><span class="line">GenericServlet <span class="comment">-- 抽象类</span></span><br><span class="line">    |</span><br><span class="line">HttpServlet  <span class="comment">-- 抽象类</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p><code>GenericServlet</code>：将Servlet接口中其他的方法做了默认<code>空实现</code>，只将<code>service()</code>方法作为抽象</p><ul><li>将来定义Servlet类时，可以继<code>承GenericServlet</code>，实现<code>service()</code>方法即可</li></ul></li><li><p><code>HttpServlet</code>：对http协议的一种封装，简化操作</p><ol><li>定义类继承<code>HttpServlet</code></li><li>复写<code>doGet/doPost</code>方法</li></ol></li></ul><h3 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h3><ul><li><p><code>urlPattern</code>：Servlet访问路径</p><ol><li>一个Servlet可以定义多个访问路径 ：<code>@WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})</code></li><li>路径定义规则：<ol><li><code>/xxx</code>：路径匹配</li><li><code>/xxx/xxx</code>:多层路径，目录结构</li><li><code>*.do</code>：扩展名匹配</li></ol></li></ol></li></ul><h1 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h1><ul><li><code>request</code>对象和<code>response</code>对象的原理<ol><li>request和response对象是由服务器创建的</li><li>request对象是来获取<strong>请求消息</strong>，response对象是来设置<strong>响应消息</strong></li></ol></li></ul><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="request对象继承体系结构"><a href="#request对象继承体系结构" class="headerlink" title="request对象继承体系结构"></a>request对象继承体系结构</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletRequest--接口</span><br><span class="line">    <span class="string">|继承</span></span><br><span class="line">HttpServletRequest-- 接口</span><br><span class="line">    <span class="string">|实现</span></span><br><span class="line">org.apache.catalina.connector.RequestFacade 类(tomcat)</span><br></pre></td></tr></table></figure><h3 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a>request功能</h3><ul><li><p>获取请求消息数据</p><ul><li><p>获取请求行数据</p><ol><li>获取当前请求方式：<code>String getMethod()</code></li><li>获取当前虚拟目录：<code>String getContextPath()</code></li><li>获取Servlet路径：<code>String getServletPath()</code></li><li>获取<code>get</code>方式请求参数：<code>String getQueryString()</code></li><li><p>获取请求URI：</p><ul><li><code>String getRequestURI()</code>：URI：统一资源标识符</li><li><code>StringBuffer getRequestURL()</code>：URL:统一资源定位符</li></ul></li><li><p>获取协议及版本：<code>String getProtocol()</code></p></li><li>获取客户机的IP地址：<code>String getRemoteAddr()</code></li></ol></li><li><p>获取请求头数据</p><ul><li><code>String getHeader(String name)</code>：通过请求头的名称获取请求头的值</li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code>：获取所有的请求头名称</li></ul></li><li><p>获取请求体数据</p><ul><li>请求体：只有POST请求方式才有，请求体中封装了POST请求的请求参数</li><li><code>BufferedReader getReader()</code>：获取字符输入流，只能操作字符数据</li><li><code>ServletInputStream getInputStream()</code>：获取字节输入流，可以操作所有类型数据</li></ul></li></ul></li><li><p>其他功能</p><ul><li><p>获取请求参数通用方法</p><ul><li><code>String getParameter(String name)</code>：根据参数名称获取参数值</li><li><code>String[] getParameterValues(String name)</code>：根据参数名称获取参数值的数组</li><li><code>Enumeration&lt;String&gt; getParameterNames()</code>：获取所有请求的参数名称</li><li><p><code>Map&lt;String,String[]&gt; getParameterMap()</code>：获取所有参数的map集合</p></li><li><p>中文乱码问题：</p><ul><li>get方式：tomcat 8 已经将get方式乱码问题解决了</li><li>post方式：会乱码<ul><li>解决：在获取参数前，设置request的编码<ul><li><code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></li></ul></li></ul></li></ul></li></ul></li><li><p>请求转发</p><ul><li>一种在服务器内部的资源跳转方式</li><li><p>步骤</p><ol><li>通过request对象获取请求<code>转发器对象</code>，<ul><li><code>RequestDispatcher getRequestDispatcher(String path)</code></li></ul></li><li>使用RequestDistpatcher对象来进行转发：<ul><li><code>forward(ServletRequest request,ServletRespons response)</code></li></ul></li></ol></li><li><p>特点：</p><ol><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器内部资源中</li><li>转发是一次请求</li></ol></li></ul></li><li><p>共享数据</p><ul><li>域对象：一个有作用范围的对象，可以在范围内共享数据</li><li><code>request</code>域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li><li>方法：<ul><li><code>void setAttribute(String name,Object obj)</code>：存储数据</li><li><code>Object getAttribute(String name)</code>：通过键 获取 值</li><li><code>void removeAttribute(String name)</code>：通过键 移除 键值对</li></ul></li></ul></li><li><p>获取ServletContext</p><ul><li><code>ServletContext getServletContext()</code></li></ul></li></ul></li></ul><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建项目，导入html页面，配置文件，jar包</li><li>创建数据库</li><li><p>创建包domain,创建类User</p><ul><li>domain 存放 javabean</li></ul></li><li><p>创建包util,编写工具类JDBCUtils</p><ul><li>JDBC工具类：<ul><li>获取连接池<code>DataSource</code>对象</li><li>获取数据库连接<code>Connection</code>对象 </li></ul></li></ul></li><li><p>创建包dao,创建类UserDao,提高login方法</p><ul><li>dao：datasource access object，数据库连接对象</li><li>dao：处理所有的数据库相关操作</li></ul></li><li><p>单元测试，数据库是否正常连接</p></li><li><p>创建web.servlet包，实现LoginServlet类</p></li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>html中的<code>form</code>表单中的<code>action</code>属性：<strong>虚拟目录+Servlet的资源路径</strong></li></ul><h3 id="BeanUtils工具类"><a href="#BeanUtils工具类" class="headerlink" title="BeanUtils工具类"></a>BeanUtils工具类</h3><ul><li>导包:<code>commons-beanutils-1.8.0.jar</code></li><li>用于封装JavaBean</li><li><p>JavaBean:</p><ol><li>类必须被public修饰</li><li>必须提供空参的构造器</li><li>成员变量必须使用private修饰</li><li>提供公共setter和getter方法</li></ol></li><li><p>JavaBean中的属性：setter和getter方法截取后的产物</p><ul><li>例如：getUsername() –&gt; Username–&gt; username（一般和成员方法名相同）</li></ul></li><li><p>常用方法：</p><ul><li><code>setProperty(Object bean, String name, Object value)</code>：设置属性</li><li><code>getProperty(Object bean, String name)</code>：获取属性</li><li><code>populate(Object bean, Map&lt;String,? extends Object&gt; properties)</code>：将map集合的键值对信息，封装到对应的JavaBean对象中</li></ul></li></ul><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><ul><li><p>功能：设置响应消息</p><ol><li><p>设置响应行</p><ul><li>格式：<code>HTTP/1.1 200 OK</code></li><li>设置状态码：<code>setStatus(int sc)</code></li></ul></li><li><p>设置响应头</p><ul><li><code>setHeader(String name,String value)</code></li></ul></li><li><p>设置响应体</p><ul><li><p>获取输出流</p><ul><li>字符输出流：<code>PrintWriter getWriter()</code></li><li>字节输出流：<code>ServletOutputStream getOutputStream()</code></li></ul></li><li><p>使用输出流：将数据输出到客户端浏览器</p></li></ul></li></ol></li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li><p>资源的跳转</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置状态码为302</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line"><span class="comment">// 设置响应头location</span></span><br><span class="line">response.setHeader(<span class="string">"location"</span>,<span class="string">"/JavaEE_Response/responseDemo2"</span>);</span><br></pre></td></tr></table></figure></li><li><p>方法：<code>sendRedirect(&quot;/虚拟目录/资源路径&quot;)</code></p></li><li><p>特点：</p><p>  ||地址栏|服务器|请求|<br>  |—|—|—|—|<br>  |<strong>转发Forward</strong>|地址栏路径不变|只能访问当前服务器下的资源|一次请求<br>可以使用request对象共享数据|<br>  |<strong>重定向Redirect</strong>|地址栏发送变化|可以访问其他站点(服务器)资源|两次请求<br>不可以使用request对象共享数据|</p></li></ul><h3 id="路径写法"><a href="#路径写法" class="headerlink" title="路径写法"></a>路径写法</h3><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><ul><li>通过相对路径不可以确定唯一资源</li><li>不以<code>/</code>开头，以<code>.</code>开头</li><li>规则：找到当前资源和目标资源之间的相对位置关系<ul><li><code>./</code>：当前目录</li><li><code>../</code>:后退一级目录</li></ul></li></ul><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><ul><li>通过绝对路径可以确定唯一资源</li><li>以<code>/</code>开头</li><li><p>规则：判断定义的路径是给谁用</p><ul><li><p>给客户端浏览器使用：需要加虚拟目录(项目的访问路径)</p><ul><li>建议虚拟目录动态获取：<code>request.getContextPath()</code></li><li><code>&lt;a&gt;,&lt;form&gt;,重定向</code></li></ul></li><li><p>给服务器使用：不需要加虚拟目录()</p><ul><li>转发路径</li></ul></li></ul></li></ul><h3 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h3><ul><li><p>步骤：</p><ol><li>获取字符输出流</li><li><p>输出数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字符输出流</span></span><br><span class="line">PrintWriter pw = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数据</span></span><br><span class="line">pw.write(<span class="string">"&lt;h1&gt;hello response&lt;/h1&gt;&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>中文乱码</p><ul><li>浏览器：与操作系统有关，windows GBK</li><li><code>PrintWriter pw = response.getWriter();</code>：获取的流的默认编码是ISO-8859-1</li><li>设置该流的默认编码</li><li><p>告诉浏览器响应体使用的编码(设置响应头<code>content-type</code>)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="comment">//或者使用简单的形式，设置编码，是在获取流之前设置</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><ul><li>概念：代表整个web应用，可以和程序的容器(服务器)进行通信</li><li><p>获取：</p><ul><li>通过<code>request</code>对象获取：<code>request.getServletContext();</code></li><li>通过<code>HttpServlet</code>获取：<code>this.getServletContext();</code></li></ul></li><li><p>功能：</p><ol><li><p>获取<code>MIME</code>类型</p><ul><li>MIME：在互联网通信过程中定义的一种文件数据类型</li><li>格式：大类型/小类型 text/html image/jpeg</li><li>获取方法：<code>String getMimeType(String file)</code></li></ul></li><li><p>域对象：共享数据</p><ul><li>ServletContext对象范围：所有用户所有请求的数据</li><li><code>setAttribute(String name,Object value)</code></li><li><code>getAttribute(String name)</code></li><li><code>removeAttribute(String name)</code></li></ul></li></ol></li></ul><pre><code>3. 获取文件的真实(服务器)路径    - 方法：`String getRealPath(String path)`</code></pre><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><ul><li><p>步骤：</p><ol><li>获取下载文件名：request.getParameter()</li><li><p>将资源按字节输入流读入内存</p><ul><li>找到资源在服务器内的路径：ServletContext对象getRealPath方法</li><li>读入字节输入流：创建FileInputStream对象，传递路径</li></ul></li><li><p>设置response响应头</p><ul><li>获取文件类型：ServletContext对象的getMimeType()</li><li>设置响应头类型：content-type</li><li>设置响应头打开方式：content-disposition</li></ul></li><li><p>将输入流数据 写出到 response输出流</p><ul><li>获取输出流对象：response.getOutputStream()</li><li>设置缓冲区：byte[] buff = new byte[1024*4];</li><li>输出数据：write方法</li><li>关闭缓冲区：close方法</li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件名称</span></span><br><span class="line">String filename = request.getParameter(<span class="string">"filename"</span>);</span><br><span class="line"><span class="comment">// 使用字节输入流加载进入内存</span></span><br><span class="line">    <span class="comment">// 找到文件的服务器路径</span></span><br><span class="line">ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">String realPath = context.getRealPath(<span class="string">"/img/"</span> + filename);</span><br><span class="line">    <span class="comment">// 字节流关联</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定response的响应头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应头类型：content-type</span></span><br><span class="line">String mimeType = context.getMimeType(filename);</span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>,mimeType);</span><br><span class="line"><span class="comment">// 设置想要头打开方式：content-disposition</span></span><br><span class="line">response.setHeader(<span class="string">"content-disposition"</span>,<span class="string">"attachmemt;filename="</span>+filename);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入流数据写出到response输出流</span></span><br><span class="line">ServletOutputStream sos = response.getOutputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buff=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">8</span>];<span class="comment">// 缓冲区</span></span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    sos.write(buff,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><ul><li>中文乱码<ol><li>获取客户端使用的浏览器版本信息</li><li>根据不同的版本信息，设置filename的编码方式不同</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat&quot;&gt;&lt;a href=&quot;#Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Tomcat&quot;&gt;&lt;/a&gt;Tomcat&lt;/h1&gt;&lt;h2 id=&quot;Web服务器软件&quot;&gt;&lt;a href=&quot;#Web服务器软件&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="tomcat" scheme="https://coderjeremy.github.io/tags/tomcat/"/>
    
      <category term="Servlet" scheme="https://coderjeremy.github.io/tags/Servlet/"/>
    
      <category term="request" scheme="https://coderjeremy.github.io/tags/request/"/>
    
      <category term="response" scheme="https://coderjeremy.github.io/tags/response/"/>
    
  </entry>
  
  <entry>
    <title>一些异常</title>
    <link href="https://coderjeremy.github.io/2020/02/26/%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8/"/>
    <id>https://coderjeremy.github.io/2020/02/26/一些异常/</id>
    <published>2020-02-26T10:54:39.000Z</published>
    <updated>2020-02-26T11:00:36.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><blockquote><p>Caused by: java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException</p></blockquote><ul><li>原因：找不到DataAccessException类，可能是jar包导入异常</li><li>解决方案：查看依赖jar包是否配置在<code>WEB-INF</code>下的<code>lib</code>文件夹中（不是<code>libs</code>）或者是否缺少相关jar包</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;h2 id=&quot;NoClassDefFoundError&quot;&gt;&lt;a href=&quot;#NoClassDefFoundError&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Exception" scheme="https://coderjeremy.github.io/tags/Exception/"/>
    
      <category term="异常" scheme="https://coderjeremy.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="https://coderjeremy.github.io/2020/02/21/XML/"/>
    <id>https://coderjeremy.github.io/2020/02/21/XML/</id>
    <published>2020-02-21T09:42:16.000Z</published>
    <updated>2020-02-21T09:45:36.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Extensible Markup Language 可扩展标记语言</p><ul><li>可扩展：标签都是自定义的</li><li><p>功能：存储数据</p><ul><li>配置文件</li><li>在网络中传输</li></ul></li><li><p>xml与html的区别</p><ul><li>xml标签都是自定义的,html标签都是预定义的</li><li>xml的语法严格，html语法比较松</li><li>xml是存储数据的，html是展示数据的</li></ul></li></ul></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>xml文档的后缀名 .xml</li><li>xml<strong>第一行</strong>必须定义为文档声明</li><li>xml文档中<strong>有且仅有一个</strong>根标签</li><li>属性值必须使用引号(单双都可)引起来</li><li>标签必须正确关闭(围堵标签、自闭合标签)</li><li>xml标签名称区分大小写</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">'2'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li><p>文档声明</p><ul><li>格式：<code>&lt;?xml 属性列表?&gt;</code></li><li>属性列表：<ul><li>version：版本号，必须的属性</li><li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值ISO-8859-1</li><li>standalone：是否独立（yes/no）</li></ul></li></ul></li><li><p>指令：结合css<code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</code></p></li><li><p>标签：标签名称自定义</p><ul><li>名称可以包含字母、数字以及其他的字符</li><li>名称不能以数字或者标点开始</li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li><li>名称不能包含空格</li></ul></li><li><p>属性：id属性值唯一</p></li><li>文本：CDATA区：在该区域中的数据会被原样展示<ul><li>格式：<code>&lt;![CDATA[ 数据 ]]&gt;</code></li></ul></li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li>规定xml文档的书写规则</li><li><p>作为框架的使用者</p><ol><li>能够在xml中引入约束文档</li><li>能够简单的读懂约束文档</li></ol></li><li><p>分类</p><ol><li>DTD:一种简单的约束技术</li><li>Schema:一种复杂的约束技术</li></ol></li></ul><ul><li><p>DTD</p><ul><li>引入dtd文档到xml文档中                    <ul><li>内部dtd：将约束规则定义在xml文档中</li><li>外部dtd：将约束的规则定义在外部的dtd文件中<ul><li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></li><li>网络：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></li></ul></li></ul></li></ul></li><li><p>Schema</p><ul><li>XML Schema语言也称作XML Schema定义（XML Schema Definition，XSD）</li><li><p>XML Namespace(xmlns)属性:</p><ul><li>格式：<code>xmlns:namespace-prefix=&quot;namespaceURI&quot;</code></li></ul></li><li><p>引入</p><ol><li>填写xml文档的根元素</li><li>引入xsi前缀。 <code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></li><li>引入xsd文件命名空间。 <code>xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;</code></li><li>为每一个xsd约束声明一个前缀，作为标识。 <code>xmlns=&quot;http://www.itcast.cn/xml&quot;</code></li></ol></li></ul></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>操作xml文档</p><ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化的存储</li></ol></li><li><p>解析xml的方式</p><ol><li><p>DOM：将标记语言文档一次性加载进内存，在内存中形成dom树</p><ul><li>优点：操作方便，可以对文档进行CRUD的所有操作</li><li>缺点：占内存</li></ul></li><li><p>SAX：逐行读取，基于事件驱动的。</p><ul><li>优点：不占内存。</li><li>缺点：只能读取，不能增删改   </li></ul></li></ol></li><li><p>xml常见解析器</p><ul><li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li><li>DOM4J：一款非常优秀的解析器</li><li>Jsoup：soup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li><li>PULL：Android操作系统内置的解析器，sax方式的。</li></ul></li></ul><h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><ul><li>步骤<ol><li>导入jar包 </li><li>获取Document对象</li><li>获取对应的标签Element对象</li><li>获取数据</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取Document对象*/</span></span><br><span class="line"><span class="comment">/*获取student.xml的path*/</span></span><br><span class="line">String path = JsoupDemo.class.getClassLoader().getResource(<span class="string">"student.xml"</span>).getPath();</span><br><span class="line"><span class="comment">// 解析xml文档，加载文档进内存，获取dom树</span></span><br><span class="line">Document document = Jsoup.parse(<span class="keyword">new</span> File(path),<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">// 获取元素对象 Element</span></span><br><span class="line">Elements elements = document.getElementsByTag(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//System.out.println(element.size());</span></span><br><span class="line"><span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">    System.out.println(element.text());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对象的使用</p><ul><li><p><code>Jsoup</code>：工具类，可以解析html或xml文档，返回Document</p><ul><li><code>parse</code>：解析html或xml文档，返回Document<ul><li><code>parse​(File in, String charsetName)</code>：解析xml或html文件的。</li><li><code>parse​(String html)</code>：解析xml或html字符串</li><li><code>parse​(URL url, int timeoutMillis)</code>：通过网络路径获取指定的html或xml的文档对象 </li></ul></li></ul></li><li><p><code>Document</code>：文档对象。代表内存中的dom树</p><ul><li>获取<code>Element</code>对象<ul><li><code>getElementById​(String id)</code>：根据id属性值获取唯一的element对象</li><li><code>getElementsByTag​(String tagName)</code>：根据标签名称获取元素对象集合</li><li><code>getElementsByAttribute​(String key)</code>：根据属性名称获取元素对象集合</li><li><code>getElementsByAttributeValue​(String key, String value)</code>：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul></li><li><p><code>Elements</code>：元素Element对象的集合。可以当做 <code>ArrayList&lt;Element&gt;</code>来使用</p></li><li><p><code>Element</code>：元素对象</p><ul><li><p>获取子元素对象</p><ul><li><code>getElementById​(String id)</code>：根据id属性值获取唯一的element对象</li><li><code>getElementsByTag​(String tagName)</code>：根据标签名称获取元素对象集合</li><li><code>getElementsByAttribute​(String key)</code>：根据属性名称获取元素对象集合</li><li><code>getElementsByAttributeValue​(String key, String value)</code>：根据对应的属性名和属性值获取元素对象集合</li></ul></li><li><p>获取属性值</p><ul><li><code>String attr(String key)</code>：根据属性名称获取属性值</li></ul></li><li><p>获取文本内容</p><ul><li><code>String text()</code>:获取所有子标签的纯文本内容</li><li><code>String html()</code>:获取标签体的所有内容(包括字标签的字符串内容)</li></ul></li></ul></li><li><p><code>Node</code>：节点对象，是Document和Element的父类</p></li></ul></li></ul><ul><li><p>快捷查询方式</p><ul><li><p><code>selector</code>：选择器</p><ul><li>使用的方法：<code>Elements    select​(String cssQuery)</code>    </li></ul></li><li><p><code>XPath</code>：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p><ul><li>使用Jsoup的Xpath需要额外导入jar包。</li><li>查询w3cshool参考手册，使用xpath的语法完成查询        </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;u
      
    
    </summary>
    
    
      <category term="XML" scheme="https://coderjeremy.github.io/tags/XML/"/>
    
      <category term="Jsoup" scheme="https://coderjeremy.github.io/tags/Jsoup/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap</title>
    <link href="https://coderjeremy.github.io/2020/02/21/Bootstrap/"/>
    <id>https://coderjeremy.github.io/2020/02/21/Bootstrap/</id>
    <published>2020-02-21T09:42:01.000Z</published>
    <updated>2020-02-21T09:46:01.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>一个前端开发的框架，Bootstrap，基于HTML、CSS、JavaScript。</li><li>框架：一个半成品软件，开发人员可以在框架基础上，再进行开发，简化编码。</li><li>优点：<ul><li>定义了很多的CSS样式和JS插件。我们开发人员直接可以使用这些样式和插件得到了丰富的页面效果。</li><li>响应式布局：同一套页面可以兼容不同分辨率的设备</li></ul></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li>下载Bootstrap</li><li>导入资源文件</li><li>创建html，引入相关资源文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 101 Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"../css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul><li>同一套页面可以兼容不同分辨率的设备</li><li>实现：依赖于栅格系统。将一行平均分为12个格子，可以指定元素占几格</li><li><p>步骤</p><ol><li><p>定义容器</p><ul><li><code>container</code>：固定宽度</li><li><code>container-fluid</code>：100% 宽度</li></ul></li><li><p>定义行</p><ul><li>row</li></ul></li><li><p>定义元素。指定该元素在不同的设备上，所占的格子数目。</p><ul><li><code>col-设备代号-格子数目</code><ul><li>设备代号：<ol><li>xs：超小屏幕 手机 (&lt;768px)：col-xs-12</li><li>sm：小屏幕 平板 (≥768px)</li><li>md：中等屏幕 桌面显示器 (≥992px)</li><li>lg：大屏幕 大桌面显示器 (≥1200px)</li></ol></li></ul></li></ul></li></ol></li><li><p>注意：</p><ul><li>一行中如果格子数目超过12，则超出部分自动换行。</li><li>栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</li><li>如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1. 定义容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2. 定义行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3. 定义元素。指定该元素在不同的设备上，所占的格子数目。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-1 col-sm-3"</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><ul><li><p>全局CSS样式</p><ul><li>按钮：<code>class=&quot;btn btn-default&quot;</code></li><li><p>图片：<code>class=&quot;img-responsive&quot;</code>，图片在任意尺寸都占100%</p><ul><li>方形： <code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;</code></li><li>圆形： <code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt;</code></li><li>相框： <code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt;</code></li></ul></li><li><p>表格</p><ul><li>table</li><li><code>class=&quot;table table-bordered&quot;</code>：带边框的表格</li><li><code>class=&quot;table table-hover&quot;</code>：鼠标悬停</li><li><code>class=&quot;table table-striped&quot;</code>：条纹状表格</li></ul></li><li><p>表单</p><ul><li><code>class=&quot;form-control&quot;</code></li></ul></li></ul></li><li><p>组件</p><ul><li>导航条</li><li>分页条</li></ul></li><li><p>插件</p><ul><li>轮播图:Carousel</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bootstrap&quot;&gt;&lt;a href=&quot;#Bootstrap&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap&quot;&gt;&lt;/a&gt;Bootstrap&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Bootstrap" scheme="https://coderjeremy.github.io/tags/Bootstrap/"/>
    
      <category term="前端框架" scheme="https://coderjeremy.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Web前端</title>
    <link href="https://coderjeremy.github.io/2020/02/20/Web%E5%89%8D%E7%AB%AF/"/>
    <id>https://coderjeremy.github.io/2020/02/20/Web前端/</id>
    <published>2020-02-20T12:37:49.000Z</published>
    <updated>2020-02-20T13:33:25.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h1><h2 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B/S架构"></a>B/S架构</h2><ul><li>静态资源<ul><li>使用静态网页开发技术发布的资源</li><li>特点：<ul><li>所有用户访问，得到的结果是一样的</li><li>如：文本、图片、音频、视频，HTML、CSS、Javascript</li><li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器，浏览器内置了静态资源的解析引擎，可以展示静态资源</li></ul></li></ul></li><li>动态资源<ul><li>使用动态网页即时发布的资源</li><li>特点：<ul><li>所有用户访问，得到的结果可能不一样</li><li>如：jsp/servlet、php、asp…</li><li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</li></ul></li></ul></li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>Hyper Text Markup Language 超文本标记语言<ul><li>超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织再一起的网状文本。</li><li>标记语言：由标签构成的语言，标记语言不是编程语言</li></ul></li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li>html文档后缀：<code>.html</code>或<code>.htm</code></li><li>标签分类<ul><li><strong>围堵标签</strong>：有开始标签和结束标签，如<code>&lt;html&gt;&lt;/html&gt;</code></li><li><strong>自闭合标签</strong>：开始标签和结束标签在一起，如<code>&lt;br/&gt;</code></li></ul></li><li>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号引起来（单引双引都可）</li><li>html的表情不区分大小写，建议使用小写。</li></ul><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><ul><li><p>文件标签</p><ul><li><code>&lt;html&gt;&lt;/html&gt;</code>：html文档的根标签</li><li><code>&lt;head&gt;&lt;/head&gt;</code>：头标签，用于指定html文档的一些属性。引入外部资源</li><li><code>&lt;title&gt;&lt;/title&gt;</code>：标题标签</li><li><code>&lt;body&gt;&lt;/body&gt;</code>：体标签</li><li><code>&lt;!DOCTYPE html&gt;</code>：定义文档类型，html5中定义该文档是html文档</li><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：指定字符集</li></ul></li><li><p>文本标签</p><ul><li>注释：<code>&lt;!-- 注释内容 --&gt;</code></li><li><code>&lt;h1&gt;to&lt;h6&gt;</code>：标题标签（h1~h6字体大小逐渐递减）</li><li><code>&lt;p&gt;&lt;/p&gt;</code>：段落标签</li><li><code>&lt;br/&gt;</code>：换行标签</li><li><p><code>&lt;hr&gt;</code>：展示一条水平线</p><ul><li>属性：<ul><li>color：颜色</li><li>width：宽度</li><li>size：高度</li><li>align：对齐方式（center/left/right）</li></ul></li></ul></li><li><p><code>&lt;b&gt;&lt;/b&gt;</code>：字体加粗</p></li><li><code>&lt;i&gt;&lt;/i&gt;</code>：字体斜体</li><li><code>&lt;font&gt;&lt;/font&gt;</code>：字体标签</li><li><p><code>&lt;center&gt;</code>：文本居中,相对于父元素</p><ul><li>属性：<ul><li>color：颜色</li><li>size：大小</li><li>face：字体</li></ul></li></ul></li><li><p>属性定义</p><ul><li><p>color：</p><ul><li>英文单词</li><li>rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)</li><li>#值1值2值3：值的范围：00~FF之间。如： #FF00FF</li></ul></li><li><p>width：</p><ul><li>数值，单位默认px像素</li><li>数值%：占比相对于父元素的比例</li></ul></li></ul></li></ul></li></ul><pre><code>&gt; 特殊字符表：空格：`&amp;nbsp;`</code></pre><ul><li><p>图片标签</p><ul><li><p><code>&lt;img/&gt;</code>：展示图片</p><ul><li>属性：<ul><li>src：指定图片的位置</li><li>alt：规定在图像无法显示时的替代文本</li></ul></li><li><code>&lt;img src=&quot;图片地址&quot; alt=&quot;图片名称&quot;&gt;</code></li></ul><blockquote><p>相对路径：以.开头的路径</p><ul><li>./：代表当前目录</li><li>../：代表上一级目录</li></ul></blockquote></li></ul></li><li><p>列表标签</p><ul><li>有序列表<ul><li><code>&lt;ol&gt;</code>:定义有序列表。</li><li><code>&lt;li&gt;</code>:定义列表的项目。</li></ul></li><li>无序列表<ul><li><code>&lt;ul&gt;</code>:定义无序列表。</li><li><code>&lt;li&gt;</code>:定义列表的项目。</li></ul></li></ul></li><li><p>链接标签</p><ul><li><code>&lt;a&gt;</code>:定义一个超链接<ul><li>属性：<ul><li>href:指定访问资源的url(统一资源定位符)</li><li>target:指定打开资源的方式<ul><li>_self:默认值，在当前页面打开</li><li>_blank:在空白页打开</li></ul></li></ul></li></ul></li></ul></li><li><p>样式/节</p><ul><li><code>&lt;div&gt;&lt;/div&gt;</code>:可以把文档分割为独立的、不同的部分。每一个div占满一整行。块级标签</li><li><code>&lt;span&gt;&lt;/span&gt;</code>:用来组合文档中的行内元素。文本信息在一行展示，行内标签 内联标签</li><li><code>&lt;header&gt;&lt;/header&gt;</code>:定义文档的页眉（介绍信息）。</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code>:定义文档或节的页脚。</li></ul></li><li><p>表格标签</p><ul><li><p><code>&lt;table&gt;&lt;/table&gt;</code></p><ul><li>width：宽度</li><li>border：边框</li><li>cellpadding：定义内容和单元格的距离</li><li>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条</li><li>bgcolor：背景色</li><li>align：对齐方式</li></ul></li><li><p><code>&lt;tr&gt;&lt;/tr&gt;</code>：定义行</p><ul><li>bgcolor：背景色</li><li>align：对齐方式</li></ul></li><li><p><code>&lt;td&gt;&lt;/td&gt;</code>：定义单元格</p><ul><li>colspan：合并列</li><li>rowspan：合并行</li></ul></li><li><p><code>&lt;th&gt;&lt;/th&gt;</code>：定义表头单元格</p></li><li><code>&lt;caption&gt;&lt;/caption&gt;</code>：表格标题</li><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：表示表格的头部分</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：表示表格的体部分</li><li><code>&lt;tfoot&gt;&lt;/tfoot&gt;</code>：表示表格的脚部分    </li></ul></li></ul><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><ul><li>概念：用于采集用户输入的数据。用于和服务器进行交互。</li><li><code>&lt;form&gt;</code>：用于定义表单，可以定义一个范围，范围内代表采集用户数据的范围</li><li><p>属性：</p><ul><li><code>action</code>；指定提交数据的URL</li><li><p><code>method</code>：指定提交方式（一共7种，常用2种）</p><blockquote><ul><li><code>get</code><ul><li>请求参数会在地址栏显示。数据被封装到<strong>请求行</strong>中</li><li>请求参数大小有限制</li><li>不太安全</li></ul></li><li><code>post</code><ul><li>请求参数不会显示在地址栏。数据被封装到<strong>请求体</strong>中</li><li>请求参数大小没有限制</li><li>比较安全</li></ul></li></ul></blockquote></li><li><p>表单项中的数据想要被提交，必须指定其<code>name</code>属性</p></li></ul></li><li><p>表单项标签</p><ul><li><p><code>input</code>：可以勇敢type属性值，改变元素展示的样式</p><ul><li><p><code>type</code>属性：</p><ul><li><p>text：文本输入框，默认值</p></li><li><p>password：密码输入框</p></li><li><p>radio：单选框 </p><ul><li>要想多个单选框实现单选的效果，则多个单选框的<code>name属性</code>必须一样</li><li>一般会给每一个单选框提供value属性，指定其被选中后提交的值</li><li>checked属性：可以指定默认值<code>cheecked=&quot;checked&quot;</code>，可以简写<code>checked</code></li></ul></li><li><p>checkbox：复选框</p><ul><li>一般会给每一个单选框提供value属性，指定其被选中后提交的值</li><li>checked属性：可以指定默认值</li></ul></li><li><p>file：文件选择框</p></li><li><p>hidden：隐藏域，用于提交一些信息</p></li><li><p>按钮：</p><ul><li>submit：提交按钮，可以提交表单</li><li>button：普通按钮</li><li>image：图片提交按钮（src属性指定图片的路径）</li></ul></li><li><p>date：定义 date 控件（包括年、月、日，不包括时间）。</p></li><li>email：定义用于 e-mail 地址的字段。</li><li>color：定义拾色器 </li><li>number：定义用于输入数字的字段。 </li></ul></li><li><p><code>placeholder</code>：指定输入框的提示信息，当输入框的内容发生改变，会自动清空提示信息</p></li></ul></li><li><p><code>select</code>：下拉列表</p><ul><li>子元素：<code>option</code>，指定列表项</li></ul></li><li><p><code>textarea</code>：文本域</p><ul><li>cols：指定列数，每一行有多少个字符</li><li>rows：默认多少行。</li></ul></li></ul></li></ul><pre><code>- `label`：指定输入项的文字描述信息    - label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。`&lt;label for=&quot;username&quot;&gt;&lt;/label&gt;`</code></pre><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>概念：Cascading Style Sheets 层叠样式表</p><ul><li>层叠：多个样式可以作用在同一个html的元素上，同时生效</li></ul></li><li><p>优点：</p><ul><li>功能强大</li><li>将内容展示和样式控制分离<ul><li>降低耦合度。解耦</li><li>让分工协作更容易</li><li>提高开发效率</li></ul></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>内联样式</p><ul><li>在标签内使用style属性指定css代码</li><li>如：<code>&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></li></ul></li><li><p>内部样式</p><ul><li>在head标签内，定义style标签，style标签的标签体内容就是css代码</li><li>如<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>外部样式</p><ul><li>定义css资源文件</li><li><p>在head标签内，定义link标签，引入外部的资源文件</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.css:</span></span><br><span class="line"><span class="comment">div&#123;</span></span><br><span class="line"><span class="comment">    color:green;</span></span><br><span class="line"><span class="comment">&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/a.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：</p><ul><li>三种方式，css作用域越来越大</li><li>3种格式可以写为：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    @<span class="keyword">import</span> <span class="string">"css/a.css"</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>格式：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">    属性名1:属性值1;</span><br><span class="line">    属性名2:属性值2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：每一对属性需要使用分号;隔开，最后一对属性可以不加</p></li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>选择器：筛选具有相似特征的元素</li><li><p>分类：</p><ol><li><p>基础选择器</p><ul><li><p>id选择器：选择具体的id属性值的元素，建议在一个html页面中id值唯一</p><ul><li>语法：<code>#id属性值{}</code></li></ul></li><li><p>元素选择器：选择具有相同标签名称的元素</p><ul><li>语法：<code>标签名称{}</code></li><li>注意：id选择器优先级高于元素选择器</li></ul></li><li><p>类选择器：选择具有相同class属性值的元素</p><ul><li>语法：<code>.class属性值{}</code></li><li>注意：类选择器优先级高于元素选择器</li></ul></li></ul></li><li><p>扩展选择器</p><ul><li><p>选择所有元素</p><ul><li>语法：<code>*{}</code></li></ul></li><li><p>并集选择器</p><ul><li>语法：<code>选择器1,选择器2{}</code></li></ul></li><li><p>子选择器：筛选选择器1元素下的选择器2元素</p><ul><li>语法：<code>选择器1 选择器2{}</code></li></ul></li><li><p>父选择器：筛选选择器2的父选择器1</p><ul><li>语法：<code>选择器1 &gt; 选择器2{}</code></li></ul></li><li><p>属性选择器：选择元素名称，属性名=属性值的元素</p><ul><li>语法：<code>元素名称[属性名=&quot;属性值&quot;]{}</code></li></ul></li><li><p>伪类选择器：选择一些元素具有的状态</p><ul><li>语法：<code>元素:状态{}</code></li><li>如： <code>&lt;a&gt;标签</code><ul><li>link：初始化的状态</li><li>visited：被访问过的状态</li><li>active：正在访问状态</li><li>hover：鼠标悬浮状态</li></ul></li></ul></li></ul></li></ol></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>字体</p><ul><li>font-size：字体大小</li><li>color：文本颜色</li><li>text-align：对其方式</li><li>line-height：行高 </li></ul></li><li><p>背景</p><ul><li>background:<code>background: url(&quot;图片地址&quot;) no-repeat right top;</code></li></ul></li><li><p>边框</p><ul><li>border：设置边框，符合属性</li></ul></li><li><p>尺寸</p><ul><li>width：宽度</li><li>height：高度</li></ul></li><li><p>盒子模型：控制布局</p><ul><li>margin：外边距</li><li><p>padding：内边距</p><ul><li>默认情况下内边距会影响整个盒子的大小</li><li>box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小</li></ul></li><li><p>float：浮动</p><ul><li>left</li><li>right</li></ul></li></ul></li></ul><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><ul><li><p>概念：客户端脚本语言</p><ul><li>运行再客户端浏览器中，每一个浏览器都有JavaScript的解析引擎</li><li>脚本语言：不需要编译，直接就可以被浏览器解析执行</li></ul></li><li><p>功能：可以增强用户和html页面的交互过程，可以来控制html元素，让页面增加动态效果，增强用户体验</p></li><li><p>JavaScript的发展史</p><ul><li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。</li><li>1995年，NetScape公司，开发了一门客户端脚本语言：LiveScript。后来SUN公司的专家，修改LiveScript，命名为JavaScript</li><li>1996年，微软模仿JavaScript开发出JScript语言</li><li>1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式</li><li>JavaScript = ECMAScript + JavaScript特有东西(DOM+BOM)</li></ul></li></ul><h3 id="ECMAScript：客户端脚本语言标准"><a href="#ECMAScript：客户端脚本语言标准" class="headerlink" title="ECMAScript：客户端脚本语言标准"></a>ECMAScript：客户端脚本语言标准</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li><p>与html结合方式</p><ol><li>内部JS：定义<code>&lt;script&gt;</code>，标签体内容就是js代码</li><li>外部JS：定义<code>&lt;script&gt;</code>，通过<code>src属性</code>引入外部的js文件</li></ol><ul><li>注意：<ul><li><code>&lt;script&gt;</code>可以定义在html页面的任何地方。但定义的位置会影响执行顺序</li><li><code>&lt;script&gt;</code>可以定义多个</li></ul></li></ul></li><li><p>注释</p><ol><li>单行注释：<code>//注释内容</code></li><li>多行注释：<code>/*注释内容*/</code></li></ol></li><li><p>数据类型</p><ol><li><p>基本数据类型</p><ul><li>number：数字。整数/小数/NaN（not a number一个不是数字的数字类型）</li><li>string：字符串。</li><li>boolean：true/false</li><li>null：一个对象为空的占位符</li><li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li></ul></li><li><p>引用数据类型</p><ul><li>对象</li></ul></li></ol></li><li><p>变量</p><ul><li>变量：一小块存储数据的内存空间</li><li><p>Java语言是强类型语言，而JavaScript是弱类型语言</p><ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据</li></ul></li><li><p>语法: <code>var 变量名 = 初始化值;</code></p></li><li><code>typeof运算符</code>：获取变量的类型。(null运算后得到Object类型)</li></ul></li><li><p>运算符</p><ol><li><p>一元运算符：只有一个运算数的运算符</p><ul><li><code>++，-- ， +(正号)</code></li><li>在JS中，如果运算数不是运算符所要求的类型，那么JS引擎会自动地将运算数进行类型转换。</li><li>String转number:按照字面值转换，如果字面值不是数字，则转为NaN</li></ul></li><li><p>算数运算符</p><ul><li><code>+ - * / % ...</code></li></ul></li><li><p>赋值运算符</p><ul><li><code>= += -+....</code></li></ul></li><li><p>比较运算符</p><ul><li><code>&gt; &lt; &gt;= &lt;= == ===(全等于)</code></li><li>比较方式<ul><li>类型相同：直接比较<ul><li>字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止</li></ul></li><li>类型不同：先进行类型转换，再比较(“123”==123)<ul><li><code>===全等于</code> 在比较之前，先判断类型，如果类型不一致，则直接会返回false</li></ul></li></ul></li></ul></li><li><p>逻辑运算符  </p><ul><li><code>&amp;&amp; || !</code></li><li>其他类型转boolean<ul><li>number：0或NaN为false，其他为true</li><li>string：除了空字符串，其他都是true</li><li>null/undefined：false</li><li>对象：所有对象都为true</li></ul></li></ul></li><li><p>三元运算符</p><ul><li><code>表达式? 值1:值2;</code></li><li>判断表达式的值，如果是true则取值1，如果是false则取值2</li></ul></li></ol></li><li><p>流程控制语句</p><ol><li>if…else…</li><li><p>switch</p><ul><li>在Java中，switch语句可以接受地数据类型：byte int shor char,枚举(jdk1.5) ,String(jdk1.7)</li><li>在JS中,switch语句可以接受任意的原始数据类型</li></ul></li><li><p>while</p></li><li>do…while</li><li>for</li></ol></li><li><p>JS特殊语法</p><ol><li>语句以分号<code>;</code>结尾，如果一行只有一条语句，分号可以省略</li><li>变量地定义使用<code>var</code>关键字，也可以不使用<ul><li>使用：定义的变量是局部变量</li><li>不使用：定义的变量是全局变量（不建议）</li></ul></li></ol></li></ul><h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4><ul><li><p>Function函数(方法)对象</p><ul><li><p>创建：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 方法名称(<span class="params">形参列表</span>)</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常用2</span></span><br><span class="line"><span class="keyword">var</span> 方法名 = <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性：</p><ul><li>length:返回形参的个数</li></ul></li><li><p>特点：</p><ul><li>方法定义是，形参的类型不用写，返回值类型也不用写</li><li>方法是一个对象，如果定义名称相同的方法，会覆盖</li><li>JS中，方法的调用只与方法的名称有关，和参数列表无关(无法重载，可以通过arguments.length进行模拟重载)</li><li>在方法声明中有一个隐藏的内置对象（数组），arguments封装所有的实际参数</li></ul></li><li><p>调用：方法名称(实际参数列表);</p></li></ul></li><li><p>Array数组对象</p><ul><li><p>创建</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(元素列表);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(默认长度);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> arr = [元素列表];</span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li>join(分隔符)：将数组中的元素按照指定的分隔符拼接为字符串</li><li>push()：项数组的末尾添加一个或更多元素，并返回新的长度</li></ul></li><li><p>属性</p><ul><li>length：数组的长度</li></ul></li><li><p>特点</p><ul><li>在JS中，数组元素的类型是可变的</li><li>在JS中，数组的长度是可变的</li></ul></li></ul></li><li><p>Boolean</p></li><li><p>Date日期对象</p><ul><li><p>创建：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></li><li><p>方法：</p><ul><li>toLocaleString()；返回当前date对象对应的时间本地字符串格式</li><li>getTime()：获取毫秒值。返回当前日期对象描述的时间到1970年1月1日0点的毫秒值差</li></ul></li></ul></li><li><p>Math对象</p><ul><li>创建：Math对象不用创建，直接使用。<code>Math.方法名();</code></li><li><p>方法</p><ul><li>random()：返回 0 ~ 1 之间的随机数。 含0不含1</li><li>ceil()：对数进行上舍入。</li><li>floor()：对数进行下舍入。</li><li>round()：把数四舍五入为最接近的整数。</li></ul></li><li><p>属性</p><ul><li>PI</li></ul></li></ul></li><li><p>Number</p></li><li>String</li><li><p>RegExp正则表达式对象</p><ul><li><p>正则表达式：定义字符串的组成规则</p><ul><li><p>单个字符：<code>[]</code></p><blockquote><p>如：<code>[a]</code> <code>[ab]</code> <code>[a-zA-Z0-9_]</code></p><ul><li>特殊符号代表特殊含义的单个字符:<ul><li><code>\d</code>:单个数字字符 [0-9]</li><li><code>\w</code>:单个单词字符[a-zA-Z0-9_]</li></ul></li></ul></blockquote></li><li><p>量词符号 </p><blockquote><ul><li><code>?</code>：表示出现0次或1次</li><li><code>*</code>：表示出现0次或多次</li><li><code>+</code>：出现1次或多次</li><li><code>{m,n}</code>:表示 m&lt;= 数量 &lt;= n<ul><li>m如果缺省： {,n}:最多n次</li><li>n如果缺省：{m,} 最少m次</li></ul></li></ul></blockquote></li><li><p>开始结束符号</p><blockquote><p><code>^</code>:开始<br><code>$</code>:结束</p></blockquote></li></ul></li><li><p>正则对象</p><ul><li><p>创建</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"正则表达式"</span>)<span class="comment">//引号里面的字符串需要转义符\</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>;</span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^\\w&#123;6,12&#125;$"</span>);</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li>test(参数)：验证指定的字符串是否符合正则定义的规范</li></ul></li></ul></li></ul></li></ul><ul><li><p>Global全局对象</p><ul><li>特点：Global中封装的方法不需要对象就可以直接调用。方法名();</li><li><p>方法：</p><ul><li><code>encodeURI()</code>：url编码</li><li><p><code>decodeURI()</code>：url解码</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"乃木坂"</span>;</span><br><span class="line"><span class="keyword">var</span> encode = <span class="built_in">encodeURI</span>(str1);<span class="comment">//编码</span></span><br><span class="line"><span class="built_in">document</span>.write(encode+<span class="string">'&lt;br&gt;'</span>);<span class="comment">//%E4%B9%83%E6%9C%A8%E5%9D%82</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="built_in">decodeURI</span>(encode)<span class="comment">//解码</span></span><br><span class="line"><span class="built_in">document</span>.write(str2+<span class="string">'&lt;br&gt;'</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>- `encodeURIComponent()`：url编码,编码的字符更多- `decodeURIComponent()`：url解码- `parseInt()`：将字符串转为数字    &gt; 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number- `isNaN()`：判断一个值是否是NaN    &gt; NaN六亲不认，连自己都不认。NaN参与的==比较全部问false- `eval()`：将JavaScript 字符串，并把它作为脚本代码来执行。</code></pre><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><ul><li>概念：Browser Object Model 浏览器对象模型。将浏览器的各个组成部分封装成对象</li><li><p>组成：</p><ul><li>Window：窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：显示器屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ul></li><li><p>Window窗口对象</p><ol><li>创建</li><li><p>方法</p><ul><li><p>与弹出框有关的方法</p><ul><li><code>alert()</code>：显示带有一段消息和一个确认按钮的警告框。</li><li><code>confirm()</code>：显示带有一段消息以及确认按钮和取消按钮的对话框。<ul><li>确定：返回true</li><li>取消：返回false</li></ul></li><li><code>prompt()</code>：显示可提示用户输入的对话框。<ul><li>返回值：获取用户输入的值</li></ul></li></ul></li><li><p>与打开关闭有关的方法</p><ul><li><code>close()</code>：关闭浏览器窗口。谁调用，谁被关闭</li><li><code>open()</code>：打开一个新的浏览器窗口。返回新的Window对象</li></ul></li><li><p>与定时器有关的方法</p><ul><li><code>setTimeout(方法对象,毫秒值)</code>：在指定的毫秒数后调用函数或计算表达式<ul><li>参数：js代码或者方法对象，毫秒值</li><li>返回值：唯一标识，用于取消定时器</li></ul></li><li><code>clearTimeout(id)</code>：取消由setTimeout()方法设置的timeout</li><li><code>setInterval(方法对象,毫秒值)</code>：按照指定的周期（以毫秒计）来调用函数或计算表达式。</li><li><code>clearInterval(id)</code>：取消由 setInterval() 设置的 timeout。</li></ul></li></ul></li><li><p>属性</p><ul><li><p>获取其他BOM对象</p><ul><li>history</li><li>location</li><li>Navigator</li><li>Screen </li></ul></li><li><p>获取DOM对象</p><ul><li>documet:<code>window.document</code>可简写<code>document</code></li></ul></li></ul></li><li><p>特点</p><ul><li>Window对象不需要创建可以直接使用。<code>window.方法名()</code></li><li>window引用可以省略。<code>方法名()</code></li></ul></li></ol></li><li><p>Location地址栏对象</p><ol><li><p>创建 </p><ul><li><code>window.location</code></li><li><code>location</code></li></ul></li><li><p>方法</p><ul><li><code>reload()</code>：重新加载当前文档。刷新</li></ul></li><li><p>属性</p><ul><li><code>href</code>：设置或返回完整的 URL。</li></ul></li></ol></li><li><p>History历史记录对象</p><ol><li>创建<ul><li>window.history</li><li>history</li></ul></li><li>方法<ul><li><code>back()</code>：加载 history 列表中的前一个 URL。</li><li><code>forward()</code>：加载 history 列表中的下一个 URL。</li><li><code>go(参数)</code>：加载 history 列表中的某个具体页面。<ul><li>正数：前进几个历史记录</li><li>负数：后退几个历史记录</li></ul></li></ul></li><li>属性<ul><li>length：返回当前窗口历史列表中的 URL 数量。</li></ul></li></ol></li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ul><li>概念：Document Object Model文档对象模型。将标记语言文档的各个组成部分，封装成对象，可以使用这些对象，对标记语言文档进行CRUD动态操作（文档-&gt;dom树）</li><li>功能：控制html文档的内容</li><li><p>W3C DOM标准被分为3个不同的部分</p><ul><li><p><strong>核心DOM</strong>：正对任何结构化文档的标准模型</p><ul><li>Document：文档对象</li><li>ElementL：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li><li>Node：节点对象，上述5个对象的父对象</li></ul></li><li><p><strong>XML DOM</strong>：针对XML文档的标准模型</p></li><li><strong>HTML DOM</strong>：针对HTML文档的标准模型</li></ul></li></ul><h4 id="核心DOM"><a href="#核心DOM" class="headerlink" title="核心DOM"></a>核心DOM</h4><ul><li><p>Document：文档对象</p><ol><li><p>创建(获取)：在html DOM模型中可以使用window对象来获取</p><ul><li>window.document</li><li>document</li></ul></li><li><p>方法</p><ul><li><p>获取Element对象</p><ul><li><code>getElementById()</code>：根据id属性值获取元素对象。id属性值一般唯一。</li><li><code>getElementsByTagName()</code>：根据元素名称获取元素对象们。返回值是一个数组</li><li><code>getElementsByClassName()</code>：根据class属性值获取元素对象们。返回值是一个数组。</li><li><code>getElementsByName()</code>：根据name属性值获取元素对象们。返回值是一个数组</li></ul></li><li><p>创建其他DOM对象</p><ul><li><code>createAttribute(name)</code></li><li><code>createComment()</code></li><li><code>createElement()</code></li><li><code>createTextNode()</code></li></ul></li></ul></li><li><p>属性</p></li></ol></li><li><p>Element：元素对象</p><ol><li><p>获取：通过document对象来获取</p><ul><li>window.document.getElementById()</li><li>document.getElementById()</li></ul></li><li><p>方法</p><ul><li>removeAttribute()：删除属性</li><li>setAttribute()：设置属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>点我进入百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">value</span>=<span class="string">"快点我一下"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn2"</span> <span class="attr">value</span>=<span class="string">"点我删除"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">/*设置Element对象属性*/</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">"btn1"</span>);</span></span><br><span class="line"><span class="actionscript">    btn1.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ele_a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">        ele_a.setAttribute(<span class="string">"href"</span>,<span class="string">"https://www.baidu.com"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">/*删除Element对象属性*/</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">"btn2"</span>);</span></span><br><span class="line"><span class="actionscript">    btn2.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ele_a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">        ele_a.removeAttribute(<span class="string">"href"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p>Node：节点对象，其他5个对象的父对象</p><ul><li>特点：所有DOM对象都可以被认为是一个节点</li><li><p>方法：</p><ul><li><p>CRUD DOM树</p><ul><li><code>appendChild()</code>：向节点的子节点列表的结尾添加新的子节点</li><li><code>removeChild()</code>：删除（并返回）当前节点的指定子节点</li><li><code>replaceChild()</code>：用新节点替换一个子节点</li></ul></li><li><p>属性</p><ul><li>parantNode：返回节点的父亲节点</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">/*删除子节点*/</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ele_a = <span class="built_in">document</span>.getElementById(<span class="string">"del"</span>);</span></span><br><span class="line"><span class="actionscript">ele_a.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span></span><br><span class="line"><span class="undefined">    div1.removeChild(div2);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="actionscript"><span class="comment">/*添加子节点*/</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> div3 = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="actionscript">div3.setAttribute(<span class="string">"id"</span>,<span class="string">"div3"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ele_b = <span class="built_in">document</span>.getElementById(<span class="string">"add"</span>);</span></span><br><span class="line"><span class="actionscript">ele_b.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span></span><br><span class="line"><span class="undefined">    div1.append(div3);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h4><ul><li>标签体的设置和获取：<code>innerHTML</code></li><li>使用html元素对象的属性</li><li><p>控制元素样式</p><ul><li><p>使用元素的<code>style属性</code>来设置</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改样式方式1</span></span><br><span class="line">div1.style.border = <span class="string">"1px solid red"</span>;</span><br><span class="line">div1.style.width = <span class="string">"200px"</span>;</span><br><span class="line"><span class="comment">//font-size--&gt; fontSize</span></span><br><span class="line">div1.style.fontSize = <span class="string">"20px"</span>;</span><br></pre></td></tr></table></figure></li><li><p>提前定义好<strong>类选择器</strong>的样式，通过元素的<code>className属性</code>来设置其class属性值</p></li></ul></li></ul><h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><ul><li><p>概念：某些组件被执行了某些操作后，会触发某些代码的执行</p><ul><li>事件：某些操作。如：单击、双击</li><li>事件源：组件。如：按钮、文本输入框</li><li>监听器：代码</li><li>注册监听：将事件、事件源、监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul></li><li><p>常见事件：</p><ul><li><p>点击事件</p><ul><li><code>onclick</code>：单击事件</li><li><code>ondbclick</code>：双击事件</li></ul></li><li><p>焦点事件</p><ul><li><code>onblur</code>：失去焦点</li><li><code>onfocus</code>：元素获得焦点</li></ul></li><li><p>加载事件</p><ul><li><code>onload</code>：一张页面或一幅图像完成加载</li></ul></li><li><p>鼠标事件</p><ul><li><code>onmousedown</code>：鼠标按键被按下</li><li><code>onmouseup</code>：鼠标按键被松开</li><li><code>onmousemove</code>：鼠标被移动</li><li><code>onmouseover</code>：鼠标移到某元素之上</li><li><code>onmouseout</code>：鼠标从某元素移开</li></ul></li><li><p>键盘事件</p><ul><li><code>onkeydown</code>：某个键盘按键被按下</li><li><code>onkeyup</code>：某个键盘按键被松开</li><li><code>onkeypress</code>：某个键盘按键被按下并松开</li></ul></li><li><p>选择和改变</p><ul><li><code>onchange</code>：域的内容被改变</li><li><code>onselect</code>：文本被选中</li></ul></li><li><p>表单事件</p><ul><li><code>onsubmit</code>：提交按钮被点击(可以阻止表单的提交。方法返回false则表单被阻止提交)</li><li><code>onreset</code>：重置按钮被点击</li></ul></li></ul></li><li><p>绑定事件：</p><ol><li><p>直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p><ul><li><code>onclick</code>：单击事件</li></ul></li><li><p>通过js获取元素对象，指定事件属性，设置一个函数</p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web前端&quot;&gt;&lt;a href=&quot;#Web前端&quot; class=&quot;headerlink&quot; title=&quot;Web前端&quot;&gt;&lt;/a&gt;Web前端&lt;/h1&gt;&lt;h2 id=&quot;B-S架构&quot;&gt;&lt;a href=&quot;#B-S架构&quot; class=&quot;headerlink&quot; title=&quot;B/S
      
    
    </summary>
    
    
      <category term="html" scheme="https://coderjeremy.github.io/tags/html/"/>
    
      <category term="css" scheme="https://coderjeremy.github.io/tags/css/"/>
    
      <category term="javascript" scheme="https://coderjeremy.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>HTML常用标签对应全称</title>
    <link href="https://coderjeremy.github.io/2020/02/15/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%AF%B9%E5%BA%94%E5%85%A8%E7%A7%B0/"/>
    <id>https://coderjeremy.github.io/2020/02/15/HTML常用标签对应全称/</id>
    <published>2020-02-15T14:48:49.000Z</published>
    <updated>2020-02-16T08:24:00.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用HTML标签的英文全称及简单描述"><a href="#常用HTML标签的英文全称及简单描述" class="headerlink" title="常用HTML标签的英文全称及简单描述"></a>常用HTML标签的英文全称及简单描述</h2><table><thead><tr><th>HTML标签</th><th>英文全称</th><th>中文释义</th></tr></thead><tbody><tr><td>a</td><td>Anchor</td><td>锚(定义超链接，用于从一张页面链接到另一张页面)</td></tr><tr><td>abbr</td><td>Abbreviation</td><td>缩写词</td></tr><tr><td>acronym</td><td>Acronym</td><td>取首字母的缩写词</td></tr><tr><td>address</td><td>Address</td><td>地址</td></tr><tr><td>alt</td><td>alter</td><td>替用(一般是图片显示不出的提示)</td></tr><tr><td>b</td><td>Bold</td><td>粗体（文本）</td></tr><tr><td>bdo</td><td>Direction of Text Display</td><td>文本显示方向</td></tr><tr><td>big</td><td>Big</td><td>变大（文本）</td></tr><tr><td>blockquote</td><td>Block Quotation</td><td>区块引用语</td></tr><tr><td>br</td><td>Break</td><td>换行</td></tr><tr><td>cell</td><td>cell</td><td>巢</td></tr><tr><td>cellpadding</td><td>cellpadding</td><td>巢补白</td></tr><tr><td>cellspacing</td><td>cellspacing</td><td>巢空间</td></tr><tr><td>center</td><td>Centered</td><td>居中（文本）</td></tr><tr><td>cite</td><td>Citation</td><td>引用</td></tr><tr><td>code</td><td>Code</td><td>源代码（文本）</td></tr><tr><td>dd</td><td>Definition Description</td><td>定义描述</td></tr><tr><td>del</td><td>Deleted</td><td>删除（的文本）</td></tr><tr><td>dfn</td><td>Defines a Definition Term</td><td>定义定义条目</td></tr><tr><td>div</td><td>Division</td><td>分隔</td></tr><tr><td>dl</td><td>Definition List</td><td>定义列表</td></tr><tr><td>dt</td><td>Definition Term</td><td>定义术语</td></tr><tr><td>em</td><td>Emphasized</td><td>加重（文本）</td></tr><tr><td>font</td><td>Font</td><td>字体</td></tr><tr><td>h1~h6</td><td>Header 1 to Header 6</td><td>标题1到标题6</td></tr><tr><td>hr</td><td>Horizontal Rule</td><td>水平尺</td></tr><tr><td>href</td><td>hypertext reference</td><td>超文本引用</td></tr><tr><td>i</td><td>Italic</td><td>斜体（文本）</td></tr><tr><td>iframe</td><td>Inline frame</td><td>定义内联框架</td></tr><tr><td>ins</td><td>Inserted</td><td>插入（的文本）</td></tr><tr><td>kbd</td><td>Keyboard</td><td>键盘（文本）</td></tr><tr><td>li</td><td>List Item</td><td>列表项目</td></tr><tr><td>nl</td><td>navigation lists</td><td>导航列表</td></tr><tr><td>ol</td><td>Ordered List</td><td>排序列表</td></tr><tr><td>optgroup</td><td>Option group</td><td>定义选项组</td></tr><tr><td>p</td><td>Paragraph</td><td>段落</td></tr><tr><td>pre</td><td>Preformatted</td><td>预定义格式（文本 ）</td></tr><tr><td>q</td><td>Quotation</td><td>引用语</td></tr><tr><td>rel</td><td>Reload</td><td>加载</td></tr><tr><td>radio</td><td>radiobox</td><td>单选框</td></tr><tr><td>s/</td><td>strike          Strikethrough</td><td>删除线</td></tr><tr><td>samp</td><td>Sample</td><td>示例（文本）</td></tr><tr><td>small</td><td>Small</td><td>变小（文本）</td></tr><tr><td>span</td><td>Span</td><td>范围</td></tr><tr><td>src</td><td>Source</td><td>源文件链接</td></tr><tr><td>strong</td><td>Strong</td><td>加重（文本）</td></tr><tr><td>sub</td><td>Subscripted</td><td>下标（文本）</td></tr><tr><td>sup</td><td>Superscripted</td><td>上标（文本）</td></tr><tr><td>td</td><td>table data cell</td><td>表格中的一个单元格</td></tr><tr><td>th</td><td>table header cell</td><td>表格中的表头</td></tr><tr><td>tr</td><td>table row</td><td>表格中的一行</td></tr><tr><td>tt</td><td>Teletype</td><td>打印机（文本）</td></tr><tr><td>u</td><td>Underlined</td><td>下划线（文本）</td></tr><tr><td>ul</td><td>Unordered List</td><td>不排序列表</td></tr><tr><td>var</td><td>Variable</td><td>变量（文本）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用HTML标签的英文全称及简单描述&quot;&gt;&lt;a href=&quot;#常用HTML标签的英文全称及简单描述&quot; class=&quot;headerlink&quot; title=&quot;常用HTML标签的英文全称及简单描述&quot;&gt;&lt;/a&gt;常用HTML标签的英文全称及简单描述&lt;/h2&gt;&lt;table&gt;
&lt;
      
    
    </summary>
    
    
      <category term="html" scheme="https://coderjeremy.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="https://coderjeremy.github.io/2020/02/15/JDBC/"/>
    <id>https://coderjeremy.github.io/2020/02/15/JDBC/</id>
    <published>2020-02-15T11:06:46.000Z</published>
    <updated>2020-02-15T14:49:26.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>Java DataBase Connectivity(Java数据库连接)：Java语言操作数据库</li><li>本质：其实是官方（SUN公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动和jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码时驱动jar包中的实现类。</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>导入驱动jar包<ul><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li>右键–&gt;Add As Library</li></ul></li><li>注册驱动 <code>DriverManager</code></li><li>获取数据库连接对象 <code>Connection</code></li><li>定义SQL</li><li>获取执行SQL语句的对象 <code>Statement</code></li><li>执行SQL，接收返回结果</li><li>处理结果</li><li>释放资源</li></ol><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>DriverManager：驱动管理对象</li><li>Connection：数据库连接对象</li><li>Statement：执行SQL的对象</li><li>ResultSet：结果集对象</li><li>PreparedStatement：执行SQL的对象</li></ul><h3 id="DriverManager驱动管理对象"><a href="#DriverManager驱动管理对象" class="headerlink" title="DriverManager驱动管理对象"></a>DriverManager驱动管理对象</h3><ul><li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar</p><ul><li>方法：<code>static void registerDriver(Driver driver)</code>:注册与给定的驱动程序<code>DriverManager</code></li><li><p>写代码时使用：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</p></li></ul></li><li><p>获取数据库连接（DriverManager）</p><ul><li>方法：<code>static Connection getConnection(String url,String user,String password)</code></li><li>参数：<ul><li>url：指定连接的路径</li><li>语法：<code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code><blockquote><p>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：<code>jdbc:mysql:///数据库名称</code></p></blockquote></li><li>user：用户名</li><li>password：密码</li></ul></li></ul></li></ul><h3 id="Connection数据库连接对象"><a href="#Connection数据库连接对象" class="headerlink" title="Connection数据库连接对象"></a>Connection数据库连接对象</h3><ul><li>功能：<ul><li>获取执行SQL的对象<ul><li><code>Statement createStatement()</code></li><li><code>PreparedStatement prepareStatement(String sql)</code></li></ul></li><li>管理事务<ul><li>开启事务：<code>void setAutoCommit(boolean autoCommit)</code>:调用改方法设置参数为false。即开启事务</li><li>提交事务：<code>void commit()</code></li><li>回滚事务：<code>void rollback()</code></li></ul></li></ul></li></ul><h3 id="Statement执行静态SQL的对象"><a href="#Statement执行静态SQL的对象" class="headerlink" title="Statement执行静态SQL的对象"></a>Statement执行静态SQL的对象</h3><ul><li>执行SQL<ul><li><code>boolean execute(String sql)</code>:可以执行任意的sql</li><li><code>int executeUpdate(String sql)</code>:执行DML(insert、update、delete)语句，DDL(create、alter、drop)语句<ul><li>返回值：影响的行数。可以通过这个影响的行数判断DML语句是否执行成功，返回值&gt;0则执行成功。</li></ul></li><li><code>ResultSet executeQuery(String sql)</code>:执行DQL(select)语句</li></ul></li><li>样例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 导入驱动</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement smt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 静态SQL语句</span></span><br><span class="line">            String s1 = <span class="string">"insert into emp values ()"</span>;</span><br><span class="line">            String s2 = <span class="string">"delete from emp where salary&gt;8000"</span>;</span><br><span class="line">            String s3 = <span class="string">"update emp set gender='女' where name='jdbc'"</span>;</span><br><span class="line">            <span class="comment">// 注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">// 获取数据库连接对象Connection</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/demo"</span>,</span><br><span class="line">                    <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            <span class="comment">// 获取Statement对象</span></span><br><span class="line">            smt = conn.createStatement();</span><br><span class="line">            <span class="comment">// 执行sql语句</span></span><br><span class="line">            <span class="keyword">int</span> r1 = smt.executeUpdate(s1);</span><br><span class="line">            <span class="keyword">int</span> r2 = smt.executeUpdate(s2);</span><br><span class="line">            <span class="keyword">int</span> r3 = smt.executeUpdate(s3);</span><br><span class="line">            System.out.println(r1);</span><br><span class="line">            System.out.println(r2);</span><br><span class="line">            System.out.println(r3);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            <span class="comment">// 避免空指针异常</span></span><br><span class="line">            <span class="keyword">if</span> (smt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    smt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ResultSet结果集对象"><a href="#ResultSet结果集对象" class="headerlink" title="ResultSet结果集对象"></a>ResultSet结果集对象</h3><ul><li>封装查询结果</li><li><code>boolean next()</code>：游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据）。如果是，则返回false，如果不是返回true；</li><li><code>XXX getXXX(参数)</code>：获取一列数据<ul><li>XXX：代表数据类型， 如：int getInt()</li><li>参数：<ul><li>int：代表列的编号，如： getString(1)</li><li>String：代表列名称，如： getString(“name”)</li></ul></li></ul></li><li>使用步骤：<ol><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResultSet resultSet = smt.executeQuery(s1);</span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">    System.out.println(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="PreparedStatement执行SQL语句的对象"><a href="#PreparedStatement执行SQL语句的对象" class="headerlink" title="PreparedStatement执行SQL语句的对象"></a>PreparedStatement执行SQL语句的对象</h3><ul><li><p>SQL注入问题：在拼接SQL时，有一些SQL的特殊关键字参与字符串的拼接，会造成安全性问题</p><blockquote><ol><li>输入用户随便，输入密码：a’ or ‘a’ = ‘a’</li><li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ </li></ol></blockquote></li><li><p>解决方案：使用<code>PreparedStatement</code>对象</p></li><li>预编译的SQL：参数使用<code>？</code>作为占位符</li><li>使用步骤：<ol><li>导入驱动jar包</li><li>注册驱动</li><li>获取数据库连接对象Connection</li><li>定义SQL<blockquote><p>sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</p></blockquote></li><li>获取执行SQL语句的对象PreparedStatement <ul><li><code>Connection.prepareStatement(String sql)</code></li></ul></li><li>给？赋值：<blockquote><p>方法：<code>setXXX(参数1，参数2)</code></p><ul><li>参数1：?的位置编号，从1开始</li><li>参数2：?的值</li></ul></blockquote></li><li>执行SQL：接受返回值结果，不需要传递SQL语句</li><li>处理结果</li><li>释放资源</li></ol></li><li>注意：使用PreparedStatement来完成增删改查的所有操作<ol><li>可以防止SQL注入</li><li>效率更高</li><li>语句中使用了占位符，规定了sql语句的结构。用户可以设置”?”的值，但是不能改变sql语句的结构，因此解决了SQL注入</li></ol></li></ul><h1 id="JDBC工具类：JDBCUtils"><a href="#JDBC工具类：JDBCUtils" class="headerlink" title="JDBC工具类：JDBCUtils"></a>JDBC工具类：JDBCUtils</h1><ul><li>目的：简化书写</li><li><p>分析：</p><ol><li>注册驱动抽取</li><li><p>抽取一个方法获取连接对象</p><ul><li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li><li>解决：配置文件<code>jdbc.properties</code>（文件的读取，只需要读取一次即可拿到这些值。使用静态代码块）  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=</span><br><span class="line"><span class="attr">user</span>=</span><br><span class="line"><span class="attr">password</span>=</span><br><span class="line"><span class="attr">driver</span>=</span><br></pre></td></tr></table></figure></li></ul></li><li><p>抽取一个方法释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nogizaka.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 读取资源文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 创建Properties类</span></span><br><span class="line">            Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取src路径下的文件的方式：ClassLoader 类加载器</span></span><br><span class="line">            ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">            URL res = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            <span class="comment">// 获取字符串路径</span></span><br><span class="line">            String path = res.getPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 加载文件</span></span><br><span class="line">            prop.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="comment">// 3 获取数据 赋值</span></span><br><span class="line">            url = prop.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = prop.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = prop.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = prop.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            <span class="comment">// 4 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet res, Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                res.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>注意：</p><ul><li>properties文件放在src目录下</li><li><strong>获取src路径下的文件的方式：ClassLoader 类加载器</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">URL res = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line"><span class="comment">// 获取字符串路径</span></span><br><span class="line">String path = res.getPath();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="JDBC事务控制"><a href="#JDBC事务控制" class="headerlink" title="JDBC事务控制"></a>JDBC事务控制</h1><ul><li>使用<code>Connection</code>对象来管理事务<ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<blockquote><p>在执行sql之前开启事务</p></blockquote></li><li>提交事务：commit() <blockquote><p>当所有sql都执行完提交事务</p></blockquote></li><li>回滚事务：rollback() <blockquote><p>在catch中回滚事务</p></blockquote></li></ul></li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul><li>概念：其实就是一个容器（集合），存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象当用户来访问数据库时，从容器中获取连接对象，用户访问完以后，会将连接对象归还给容器。</li><li>好处：节约资源，提供访问效率</li><li>实现：<ul><li>标准接口：<code>javax.sql.DataSource</code></li><li>方法：<ul><li>获取连接：<code>getConnection()</code></li><li>归还连接：<code>Connection.close()</code> 如果连接对象Connection是从连接池中获取的，那么调用<code>Connection.close()</code>方法，则不会再关闭连接，而是归还连接</li></ul></li><li>一般由数据库厂商实现<ul><li>C3P0:数据库连接池技术</li><li>Druid:数据库连接池实现技术（阿里）</li></ul></li></ul></li></ul><h2 id="C3P0-数据库连接池技术"><a href="#C3P0-数据库连接池技术" class="headerlink" title="C3P0 数据库连接池技术"></a>C3P0 数据库连接池技术</h2><ul><li>步骤：<ol><li>导入jar包<ul><li><code>c3p0-0.9.5.2.jar</code></li><li><code>mchange-commons-java-0.2.12.jar</code></li></ul></li><li>定义配置文件：<ul><li>名称：c3p0.properties 或者 c3p0-config.xml</li><li>路径：src目录下</li></ul></li><li>创建核心对象 数据率连接池对象 <code>new ComboPooledDataSource()</code></li><li>获取连接：<code>getConnection()</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据库连接池对象</span></span><br><span class="line">DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">// 获取连接对象,getConnection()可以传递配置名，不同配置效果不同，不传使用默认配置</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line"><span class="comment">// 归还连接</span></span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><ul><li>配置文件：c3p0-config.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--初始化申请的连接数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最大连接数量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--超时时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Druid-数据库连接池实现技术"><a href="#Druid-数据库连接池实现技术" class="headerlink" title="Druid 数据库连接池实现技术"></a>Druid 数据库连接池实现技术</h2><ul><li>步骤：<ol><li>导入jar包 <ul><li><code>druid-1.0.9.jar</code></li></ul></li><li>定义配置文件<ul><li>Properties</li><li>可以放在任意目录下</li></ul></li><li>加载配置文件</li><li>获取数据库连接池对象：通过工厂来获取 <code>DruidDataSourceFactory.createDataSource()</code></li><li>获取连接：<code>getConnection()</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义配置文件</span></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 将properties文件转换为字节输入流</span></span><br><span class="line">InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line"><span class="comment">// 读取属性列表(键和元素对)从输入字节流。</span></span><br><span class="line">prop.load(is);</span><br><span class="line"><span class="comment">// 获取连接池对象,通过工厂来获取，参数为配置文件</span></span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br></pre></td></tr></table></figure><ul><li>定义工具类<ol><li>定义一个类 JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法   </li></ol></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>));</span><br><span class="line">            <span class="comment">//2.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取连接</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 释放资源</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        close(<span class="keyword">null</span>,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取连接池方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-JDBC-JDBC-Template"><a href="#Spring-JDBC-JDBC-Template" class="headerlink" title="Spring JDBC:JDBC Template"></a>Spring JDBC:JDBC Template</h1><ul><li>Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发</li><li><p>步骤</p><ol><li><p>导入jar包</p><ul><li>commons-logging-1.2.jar</li><li>spring-beans-5.0.0.RELEASE.jar</li><li>spring-core-5.0.0.RELEASE.jar</li><li>spring-jdbc-5.0.0.RELEASE.jar</li><li>spring-tx-5.0.0.RELEASE.jar</li></ul></li><li><p>创建JdbcTemplate对象，依赖于数据源DataSource</p><ul><li><code>JdbcTemplate template = new JdbcTemplate(ds);</code></li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li><p><code>update()</code>：执行DML语句。增、删、改语句</p></li><li><p><code>queryForMap()</code>：查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p><blockquote><p>注意：这个方法查询的结果集长度只能是1</p></blockquote></li><li><p><code>queryForList()</code>：查询结果将结果集封装为list集合</p><blockquote><p>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p></blockquote></li><li><p><code>query()</code>：查询结果，将结果封装为JavaBean对象</p><blockquote><ul><li>query的参数：RowMapper</li><li>一般我们使用<code>BeanPropertyRowMapper</code>实现类。可以完成数据到JavaBean的<strong>自动封装</strong></li><li><code>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</code></li></ul></blockquote></li><li><p><code>queryForObject()</code>：查询结果，将结果封装为对象</p><blockquote><p> 一般用于聚合函数的查询</p></blockquote></li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 需求：</span></span><br><span class="line"><span class="comment">1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment">2. 添加一条记录</span></span><br><span class="line"><span class="comment">3. 删除刚才添加的记录</span></span><br><span class="line"><span class="comment">4. 查询id为1的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">7. 查询总记录数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Junit单元测试，可以让方法独立执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 定义sql</span></span><br><span class="line">        String sql = <span class="string">"update emp set salary = 10000 where id = 1001"</span>;</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 2. 添加一条记录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>, <span class="string">"郭靖"</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 3.删除刚才添加的记录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from emp where id = ?"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">        * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp where id = ? or id = ?"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">                <span class="keyword">int</span> job_id = rs.getInt(<span class="string">"job_id"</span>);</span><br><span class="line">                <span class="keyword">int</span> mgr = rs.getInt(<span class="string">"mgr"</span>);</span><br><span class="line">                Date joindate = rs.getDate(<span class="string">"joindate"</span>);</span><br><span class="line">                <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line">                <span class="keyword">double</span> bonus = rs.getDouble(<span class="string">"bonus"</span>);</span><br><span class="line">                <span class="keyword">int</span> dept_id = rs.getInt(<span class="string">"dept_id"</span>);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(id) from emp"</span>;</span><br><span class="line">        Long total = template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h
      
    
    </summary>
    
    
      <category term="java" scheme="https://coderjeremy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://coderjeremy.github.io/2020/02/13/MySQL/"/>
    <id>https://coderjeremy.github.io/2020/02/13/MySQL/</id>
    <published>2020-02-13T13:44:40.000Z</published>
    <updated>2020-02-13T13:50:50.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h2><ul><li>MySQL服务启动：<ol><li>手动</li><li>cmd–&gt; services.msc打开服务窗口</li><li>使用管理员打开cmd<ul><li>net start mysql：启动mysql服务</li><li>net stop mysql：关闭mysql服务</li></ul></li></ol></li></ul><h2 id="登录与退出"><a href="#登录与退出" class="headerlink" title="登录与退出"></a>登录与退出</h2><ul><li>MySQL登录<ul><li><code>mysql -u[user] -p[password]</code></li><li><code>mysql -h[ip] -u[user] -p[password]</code></li><li><code>mysql --host=[ip] --user=[user] --password=[password]</code></li></ul></li><li>MySQL退出<ul><li>exit</li><li>quit</li></ul></li><li>MySQL目录结构<ul><li>安装目录<ul><li>配置文件 my.ini</li></ul></li><li>数据目录<ul><li>数据库</li><li>表</li><li>数据</li></ul></li></ul></li></ul><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ul><li>结构化查询语言。定义了操作所有关系型数据库的规则</li></ul><h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h2><ul><li>SQL语句可以单行或者多行书写，以分号结尾</li><li></li><li>可以使用空格和缩进来增强语句的可读性</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</li><li>注释：<ul><li>单行注释：<code>-- 注释内容</code> 或<code># 注释内容</code>（MySQL特有）</li><li>多行注释： <code>/* 注释 */</code></li></ul></li></ul><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ul><li>DDL(Data Definition Language)数据定义语言<blockquote><p>用来定义数据库对象：数据库，表，列等。关键字：<code>create</code>, <code>drop</code>,<code>alter</code> 等</p></blockquote></li><li>DML(Data Manipulation Language)数据操作语言<blockquote><p>用来对数据库中表的数据进行增删改。关键字：<code>insert</code>, <code>delete</code>, <code>update</code> 等</p></blockquote></li><li>DQL(Data Query Language)数据查询语言<blockquote><p>用来查询数据库中表的记录(数据)。关键字：<code>select</code>, <code>where</code> 等</p></blockquote></li><li>DCL(Data Control Language)数据控制语言<blockquote><p>用来定义数据库的访问权限和安全级别，及创建用户。关键字：<code>GRANT</code>， <code>REVOKE</code> 等</p></blockquote></li></ul><h3 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h3><h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><ul><li>CRUD：增删改查</li></ul><h5 id="CREATE创建"><a href="#CREATE创建" class="headerlink" title="CREATE创建"></a>CREATE创建</h5><ul><li>创建数据库：<code>CREATE DATABASE 数据库名称;</code></li><li>创建数据库，判断不存在，再创建：<code>CREATE DATABASE IF NOT EXISTS 数据库名称;</code></li><li>创建数据库，并指定字符集：<code>CREATE DATABASE 数据库名称 CHARACTER SET 字符集名;</code></li></ul><h5 id="RETRIEVE查询"><a href="#RETRIEVE查询" class="headerlink" title="RETRIEVE查询"></a>RETRIEVE查询</h5><ul><li>查询所有数据库名称：<code>SHOW DATABASES;</code></li><li>查询某个数据库的字符集：<code>SHOW CREATE DATABASE 数据库名称;</code>（查询某个数据库的创建语句）</li></ul><h5 id="UPDATE修改"><a href="#UPDATE修改" class="headerlink" title="UPDATE修改"></a>UPDATE修改</h5><ul><li>修改数据库的字符集：<code>ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;</code></li></ul><h5 id="DELETE删除"><a href="#DELETE删除" class="headerlink" title="DELETE删除"></a>DELETE删除</h5><ul><li>删除数据库：<code>DROP DATABASE 数据库名称;</code></li><li>判断数据库存在，存在再删除：<code>DROP DATABASE IF EXISTS 数据库名称;</code></li></ul><h5 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h5><ul><li>查询当前正在使用的数据库名称：<code>SELECT DATABASE();</code></li><li>使用数据库：<code>USE 数据库名称;</code></li></ul><h4 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h4><h5 id="CREATE创建-1"><a href="#CREATE创建-1" class="headerlink" title="CREATE创建"></a>CREATE创建</h5><ul><li><p>格式</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    列名<span class="number">1</span> 数据类型<span class="number">1</span>,</span><br><span class="line">    列名<span class="number">2</span> 数据类型<span class="number">2</span>,</span><br><span class="line">    ....</span><br><span class="line">    列名n 数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>注意：最后一列，不需要加逗号</p></li><li>数据库类型<ul><li>int()：整数类型</li><li>double(,)：浮点数</li><li>date：日期，只包含年月日 yyyy-MM-dd</li><li>datetime：日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss</li><li>timestamp：时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss<blockquote><p>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</p></blockquote></li><li>varchar()：字符串</li></ul></li><li>复制表：<code>CREATE TABLE 表名 LIKE 被复制的表名</code></li></ul><h5 id="RETRIEVE查询-1"><a href="#RETRIEVE查询-1" class="headerlink" title="RETRIEVE查询"></a>RETRIEVE查询</h5><ul><li>查询某个数据库中所有的表名称：<code>SHOW TABLES;</code></li><li>查询表结构：<code>DESC 表名;</code></li></ul><h5 id="UPDATE修改-1"><a href="#UPDATE修改-1" class="headerlink" title="UPDATE修改"></a>UPDATE修改</h5><ul><li>修改表名：<code>ALTER TABLE 表名 RENAME TO 新表名</code></li><li>修改表的字符集：<code>ALTER TABLE 表名 CHARACTER SET 字符集名称</code></li><li>添加一列：<code>ALTER TABLE 表名 ADD 列名 数据类型</code></li><li>修改列名称、类型：<ul><li><code>ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型</code></li><li><code>ALTER TABLE 表名 MODIFY 列名 新数据类型</code></li></ul></li><li>删除列：<code>ALTER TABLE 表名 DROP 列名</code></li></ul><h5 id="DELETE删除-1"><a href="#DELETE删除-1" class="headerlink" title="DELETE删除"></a>DELETE删除</h5><ul><li>删除表：<ul><li><code>DROP TABLE 表名;</code></li><li><code>DROP TABLE IF EXISTS 表名;</code></li></ul></li></ul><h3 id="DML数据操纵语言"><a href="#DML数据操纵语言" class="headerlink" title="DML数据操纵语言"></a>DML数据操纵语言</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li>语法：<code>INSERT INTO 表名(列名1,列名2,...,列名n) VALUES(值1,值2,...值n);</code></li><li>注意：<ol><li>列名和值要一一对应</li><li>如果表名后，不定义列名，则默认给所有列添加值</li><li>除了数字类型，其他类型需要使用引号(单双都可以)引起来</li></ol></li></ul><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li>语法：<code>DELETE FROM 表名 [WHERE 条件];</code></li><li>注意：<ol><li>如果不加条件，则删除表中所有的记录</li><li>如果要删除所有记录<ul><li><code>DELETE FROM 表名;</code> 不推荐使用，有多少条记录就会执行多少次删除操作</li><li><code>TRUNCATE TABLE 表名;</code> 推荐使用，效率更高，先删除表，然后再创建一张一样的表</li></ul></li></ol></li></ul><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><ul><li>语法：<code>UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,...[WHERE 条件];</code></li><li>注意：如果不加任何条件，则会将表中所有记录全部修改</li></ul><h3 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h3><ul><li><code>SELECT * FROM 表名;</code></li><li>语法：<ul><li><code>SELECT</code>：字段列表</li><li><code>FROM</code>：表名列表</li><li><code>WHERE</code>：条件列表</li><li><code>GROUP BY</code>：分组字段</li><li><code>HAVING</code>：分组之后的条件</li><li><code>ORDER BY</code>：排序</li><li><code>LIMIT</code>：分页限定</li></ul></li></ul><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><ul><li>多个字段的查询<ul><li><code>SELECT 字段名1,字段名2,...FROM 表名;</code><blockquote><p>如果查询所有字段，可以使用*代替字段列表</p></blockquote></li></ul></li><li>去除重复<ul><li><code>DISTINCT</code></li></ul></li><li>计算列<ul><li>一般可以使用四则运算计算一些列的值</li><li><code>IFNUL(表达式1，表达式2)</code>：NULL参与的运算，计算结果都为NULL<blockquote><ul><li>表达式1：哪个字段需要判断是否为NULL</li><li>表达式2：如果表达式1的字段为NULL后进行替换的值</li></ul></blockquote></li></ul></li><li>起别名<ul><li><code>AS</code>：可以省略</li></ul></li></ul><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li>WHERE子句后跟条件</li><li><p>运算符</p><ul><li><code>&gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</code></li><li><code>BETWEEN...AND</code> </li><li><code>IN( 集合)</code></li><li><code>LIKE：模糊查询</code> <blockquote><p>占位符：</p><ul><li><code>_</code>:单个任意字符</li><li><code>%</code>：多个任意字符</li></ul></blockquote></li><li><code>IS NULL</code></li><li><code>AND  或 &amp;&amp;</code></li><li><code>OR 或 ||</code></li><li><p><code>NOT  或 !</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄大于20岁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt;= <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄不等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age != <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &lt;&gt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt;= <span class="number">20</span> &amp;&amp;  age &lt;=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt;= <span class="number">20</span> <span class="keyword">AND</span>  age &lt;=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age = <span class="number">22</span> <span class="keyword">OR</span> age = <span class="number">18</span> <span class="keyword">OR</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩为null</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english = <span class="literal">NULL</span>; <span class="comment">-- 不对的。null值不能使用 = （!=） 判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩不为null</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'马%'</span>;</span><br><span class="line"><span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"_化%"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'___'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'%德%'</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul><li>语法：<code>ORDER BY 子句</code><ul><li><code>ORDER BY 排序字段1 排序方式1,排序字段2 排序方式2...</code></li></ul></li><li>排序方式：<ul><li><code>ASC</code>：升序。（默认）</li><li><code>DESC</code>：降序</li></ul></li><li>注意：如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件<blockquote><p>eg：SELECT * FROM emp ORDER BY job_id ASC,id DESC;</p></blockquote></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li>将一列数据作为一个整体，进行纵向的计算。<ul><li>COUNT:计算个数，一般选择非空的列（主键）COUNT(*)<blockquote><p>SELECT COUNT(IFNULL(mgr,0)) FROM emp;</p></blockquote></li><li>MAX:计算最大值</li><li>MIN:计算最小值</li><li>SUM:求和</li><li>AVG:求平均值</li></ul></li><li>注意：聚合函数的计算，排除null值。<ul><li>解决方案；<ol><li>选择不包含非空的列进行计算</li><li><code>IFNULL</code>函数</li></ol></li></ul></li></ul><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><ul><li>语法：<code>GROUP BY 分组字段;</code></li><li>注意：<ul><li>分组之后查询的字段：分组字段、聚合函数</li><li>where 和 having 的区别<ul><li>where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li><li>where后不可以跟聚合函数，having可以进行聚合函数的判断</li></ul></li></ul></li></ul><blockquote></blockquote><pre><code>-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li>语法：LIMIT开始的索引，每页查询的条数；</li><li>公式：<code>开始的索引 = （当前的页码 - 1） * 每页显示的条数</code><blockquote></blockquote><pre><code>-- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页SELECT * FROM student LIMIT 3,3; -- 第2页SELECT * FROM student LIMIT 6,3; -- 第3页</code></pre></li><li>limit 是一个MySQL”方言”</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li>概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性</li><li>分类：<ul><li>主键约束：<code>PRIMARY KEY</code></li><li>非空约束：<code>NOT NULL</code></li><li>唯一约束：<code>UNIQUE</code></li><li>外键约束：<code>FOREIGN KEY</code></li></ul></li></ul><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul><li><code>PRIMARY KEY</code><ul><li>含义；非空且唯一</li><li>一张表只能有一个字段为主键</li><li>主键就是表总记录的唯一表示</li></ul></li><li><p>在创建表时，添加主键约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>, <span class="comment">-- 给id添加主键约束</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>创建表之后，添加主键约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu</span><br><span class="line"><span class="keyword">MODIFY</span></span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除主键</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误写法:ALTER TABLE stu MODIFY id INT;</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu</span><br><span class="line"><span class="keyword">DROP</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure></li><li><p>自动增长</p><ul><li>概念：如果某一列时数值类型的，使用<code>AUTO_INCREMENT</code>可以来完成值的自动增长</li><li><p>在创建表时，添加主键约束，并且完成主键自增</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT.</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>添加自动增长</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu </span><br><span class="line"><span class="keyword">MODIFY</span></span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure></li><li><p>删除自动增长</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu </span><br><span class="line"><span class="keyword">MODIFY</span></span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul><li><code>NOT NULL</code>，值不能为NULL类型</li><li><p>创建表时添加约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="comment">-- name为非空</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建表之后，添加非空约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu </span><br><span class="line"><span class="keyword">MODIFY</span> </span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除非空约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu </span><br><span class="line"><span class="keyword">MODIFY</span> </span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="唯一约束（索引）"><a href="#唯一约束（索引）" class="headerlink" title="唯一约束（索引）"></a>唯一约束（索引）</h4><ul><li><code>UNIQUE</code>:值不能重复</li><li><p>创建表时，添加唯一约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="comment">-- 添加了唯一约束</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在创建表之后，添加唯一约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu</span><br><span class="line"><span class="keyword">MODIFY</span></span><br><span class="line">    phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除唯一约束（索引）</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> </span><br><span class="line">    phone_number;</span><br></pre></td></tr></table></figure></li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul><li><code>FOREIGN KEY</code>：让表与表产生关系，从而保证数据的正确性</li><li><p>在创建表时，添加外键约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    lesson <span class="built_in">VARCHAR</span>(<span class="number">20</span>), </span><br><span class="line">    <span class="keyword">CONSTRAINT</span> 外键名称 FOREIGN <span class="keyword">KEY</span> (外键列名称)  </span><br><span class="line">    <span class="keyword">REFERENCES</span> 主表名称(主表列名称) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在创建表后，添加外键约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> </span><br><span class="line"><span class="keyword">CONSTRAINT</span> </span><br><span class="line">    外键名称 FOREIGN <span class="keyword">KEY</span> (外键字段名称) </span><br><span class="line"><span class="keyword">REFERENCES</span></span><br><span class="line">    主表名称(主表列名称);</span><br></pre></td></tr></table></figure></li><li><p>删除外键约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line"><span class="keyword">DROP</span> </span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> 外键名称;</span><br></pre></td></tr></table></figure></li><li><p>级联操作</p><ul><li><p>添加级联操作</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span>(外键字段名称)</span><br><span class="line">    <span class="keyword">REFERENCES</span> 主表名称(主表列名称)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure></li><li><p>分类：</p><ul><li>级联更新:<code>ON UPDATE CASCADE</code></li><li>级联删除:<code>ON DELETE CASCADE</code></li></ul></li></ul></li></ul><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h3><ul><li>分类：<ul><li>一对一：一对一关系实现，可以在任意一方添加唯一（UNIQUE）外键指向另一方的主键。</li><li>一对多：在多的一方建立外键，指向一的一方的主键。</li><li>多对多：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</li></ul></li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>概念；设计数据库时，需要遵循一些规范，要遵循后边的范式要求，必须先遵循前边所有范式要求。<br>  设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈，越高的范式数据库冗余越小<br>  明确关系数据库有六种范式：第一范式、第二范式、第三范式、BC范式、第四范式、第五范式(完美范式)</li><li><strong>第一范式(1NF)</strong>：每一列都是不可分割的原子数据项</li><li><strong>第二范式(2NF)</strong>：在1NF基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的<strong>部分函数依赖</strong>）<ul><li><code>函数依赖</code>：A-&gt;B，如果通过A属性(属性组)的值能唯一确定B属性的值，则称B依赖于A</li><li><code>完全函数依赖</code>：A-&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值，如：(学号,课程名称)-&gt;分数</li><li><code>部分函数依赖</code>：A-&gt;B,如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。如：(学号,课程名称)-&gt;姓名</li><li><code>传递函数依赖</code>：A-&gt;B,B-C.如果通过A属性(属性组)的值，可以唯一确定B属性(属性组)的值，再通过B属性的值可以确定唯一C属性的值，则称C传递函数依赖于A</li><li>码：如果再一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该码的表<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：非 码属性组中的属性</li></ul></li></ul></li><li><strong>第三范式(3NF)</strong>：在2NF的基础上，任何非主属性不依赖于其他非主属性(消除<strong>传递函数依赖</strong>)</li><li><strong>BC范式</strong>：在3NF的基础上消除主属性对于码的部分与传递函数依赖。</li></ul><h3 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h3><ul><li>备份：<code>mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</code></li><li>还原：登录数据库，创建数据库，使用数据库，执行<code>source 文件</code></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li><p>查询语法：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    列名列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积：AXB的所有组合</p></li></ul><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><ul><li>步骤：<ol><li>从哪些表中查询数据</li><li>条件是什么</li><li>查询哪些字段</li></ol></li><li><p>隐式内连接：使用WHERE条件消除无用数据</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">t1.name, <span class="comment">-- 员工表的姓名</span></span><br><span class="line">t1.gender,<span class="comment">-- 员工表的性别</span></span><br><span class="line">t2.name <span class="comment">-- 部门表的名称</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    emp t1,</span><br><span class="line">    dept t2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    t1.<span class="string">`dept_id`</span> = t2.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure></li><li><p>显式内连接：<code>SELECT 字段列表 FROM 表名1 [INNER] JOIN 表名2 ON 条件</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">JOIN</span> dept </span><br><span class="line"><span class="keyword">ON</span> emp.<span class="string">`dept_id`</span> = dept.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><ul><li><p>左外连接</p><ul><li>语法：<code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 OM 条件;</code></li><li>查询的是左表所有数据以及其交集部分</li></ul></li><li><p>右外连接</p><ul><li>语法：<code>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 OM 条件;</code></li><li>查询的是右表所有数据以及其交集部分</li></ul></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li>概念：查询中嵌套查询，称嵌套查询为子查询。</li><li>子查询不同情况<ul><li>结果是单行单列：子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</li><li>结果是多行单列：子查询可以作为条件，使用运算符<code>IN(条件)</code>来判断</li><li>结果是多行多列：子查询可以作为一张虚拟表参与查询</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败</li><li>操作：<ul><li>开启事务：<code>START TRANSACTION;</code></li><li>回滚：<code>ROLLBACK;</code></li><li>提交：<code>COMMIT;</code></li></ul></li><li>MySQL数据库中事务默认自动提交<ul><li>事务提交的两种范式：<ul><li>自动提交:一条DML（增删改）语句会自动提交一次事务</li><li>手动提交：需要先开启事务，在提交</li></ul></li><li>修改事务的默认提交范式：<ul><li>查看事务的默认提交方式：<code>SELECT @@autocommit;</code>1代表自动提交，0代表手动提交</li><li>修改默认提交方式：<code>SET @@autocommit=0;</code></li></ul></li></ul></li></ul><h3 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h3><ul><li>原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li><li>隔离性（Isolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li></ul><h3 id="事务隔离的问题"><a href="#事务隔离的问题" class="headerlink" title="事务隔离的问题"></a>事务隔离的问题</h3><ul><li>脏读：一个事务，读取到另一个事务中没有提交的数据</li><li>不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样</li><li>幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改</li></ul><h3 id="事务隔离的级别"><a href="#事务隔离的级别" class="headerlink" title="事务隔离的级别"></a>事务隔离的级别</h3><ul><li><code>read uncommitted</code>读取尚未提交的数据 ：脏读、不可重复读、幻读</li><li><code>read committed</code>读取已经提交的数据 ：可以解决脏读–oracle默认的</li><li><code>repeatable read</code>重读读取：可以解决脏读和不可重复读–mysql默认的</li><li><code>serializable</code>串行化：可以解决脏读不可重复读和幻读–相当于锁表</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>注意：隔离级别从小到大安全性越来越高，但是效率越来越低</li><li>数据库查询隔离级别：<code>select @@tx_isolation</code>;</li><li>数据库设置隔离级别：<code>set global transaction isolation level 级别字符串</code>;</li></ul><h2 id="DCL管理用户、授权"><a href="#DCL管理用户、授权" class="headerlink" title="DCL管理用户、授权"></a>DCL管理用户、授权</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ul><li>添加用户：<code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li><li>删除用户：<code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>修改用户密码：<ul><li><code>UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;</code></li><li><code>SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);</code><blockquote><p>mysql中忘记了root用户的密码？</p><ol><li>cmd – &gt; net stop mysql 停止mysql服务(需要管理员运行该cmd)</li><li>使用无验证方式启动mysql服务： mysqld –skip-grant-tables</li><li>打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</li><li>use mysql;</li><li>update user set password = password(‘你的新密码’) where user = ‘root’;</li><li>关闭两个窗口</li><li>打开任务管理器，手动结束mysqld.exe 的进程</li><li>启动mysql服务</li><li>使用新密码登录。</li></ol></blockquote></li></ul></li><li>查询用户：<ol><li>切换到mysql数据库：<code>USE mysql;</code></li><li>查询user表：<code>SELECT * FROM USER;</code></li></ol></li></ul><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul><li>查询权限：<code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>授予权限：<code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code><ul><li>授予所有权限：<code>GRANT ALL ON *.* TO &#39;用户名&#39;@&#39;主机名&#39;</code>;</li></ul></li><li>撤销权限：<code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;启动与关闭&quot;&gt;&lt;a href=&quot;#启动与关闭&quot; class=&quot;headerlink&quot; title=&quot;启动与
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://coderjeremy.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java测试、反射、注解</title>
    <link href="https://coderjeremy.github.io/2020/02/09/Java%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3/"/>
    <id>https://coderjeremy.github.io/2020/02/09/Java测试、反射、注解/</id>
    <published>2020-02-09T03:00:26.000Z</published>
    <updated>2020-02-09T03:01:04.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>测试分类；<ul><li>黑盒测试；不需要写代码，给输入值，看程序是否能够输出期望值</li><li>白盒测试；需要写代码。关注程序具体的执行流程。</li></ul></li><li><p>Junit使用；白盒测试</p><ul><li><p>步骤；</p><ol><li>定义一个测试类（测试用例）<ul><li>建议；<ul><li>测试类名；<code>被测试的类名Test</code></li><li>报名；<code>xxx.xx.xx.test</code></li></ul></li></ul></li><li>定义测试方法；可以独立运行<ul><li>建议；<ul><li>方法名；<code>test测试的方法名</code></li><li>返回值；<code>void</code></li><li>参数列表；空参</li></ul></li></ul></li><li>给方法加<code>@Test</code></li><li>导入junit依赖环境</li></ol></li><li><p>判断结果；</p><ul><li>红色；失败</li><li>绿色；成功</li><li>一般使用断言操作来处理结果；<code>Assert.assertEquals(期望,结果)</code></li></ul></li><li><p>补充；</p><ul><li><code>@Before</code>；修饰的方法会在测试方法之前被自动执行（一般用于资源申请）</li><li><code>@After</code>；修饰的方法会在测试方法执行之后自动被执行（一般用于资源释放）</li></ul></li></ul></li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>框架；半成品软件。可以再框架的基础上进行软件开发，简化编码</li><li><p>反射；将类的各个组成部分封装为其他对象，这就是反射机制</p><ul><li><p>优点；</p><ol><li>可以在程序运行过程中，操作这些对象</li><li>可以解耦，提高程序的可扩展性</li></ol></li><li><p>获取Class对象的方式；</p><ol><li><code>Class.forName(&quot;全类名&quot;)</code>；将字节码文件加载进内存，返回Class对象<blockquote><p>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p></blockquote></li><li><code>类名.class</code>；通过类名的属性class获取<blockquote><p>多用于参数的传递</p></blockquote></li><li><code>对象.getClass()</code>；getClass()方法在Object类中定义<blockquote><p>多用于对象的获取字节码的方式</p></blockquote></li></ol><ul><li>结论；同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个</li></ul></li><li><p>Class对象功能</p><ul><li><p>获取功能</p><ol><li><p>获取成员变量们</p><ul><li>Field[] getFields() ：获取所有public修饰的成员变量</li><li><p>Field getField(String name)   获取指定名称的 public修饰的成员变量</p></li><li><p>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</p></li><li>Field getDeclaredField(String name)  </li></ul></li><li><p>获取构造方法们</p><ul><li>Constructor&lt;?&gt;[] getConstructors()  </li><li><p>Constructor<t> getConstructor(类&lt;?&gt;… parameterTypes)  </t></p></li><li><p>Constructor<t> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </t></p></li><li>Constructor&lt;?&gt;[] getDeclaredConstructors()  </li></ul></li><li><p>获取成员方法们：</p><ul><li>Method[] getMethods()  </li><li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li><li><p>Method[] getDeclaredMethods()  </p></li><li>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)  </li></ul></li><li><p>获取全类名    </p><ul><li>String getName()  </li></ul></li></ol></li></ul></li><li><p>Field：成员变量</p><ul><li>操作：<ol><li>设置值；void set(Object obj, Object value)  </li><li>获取值；get(Object obj) </li><li>忽略访问权限修饰符的安全检查；setAccessible(true):暴力反射</li></ol></li></ul></li><li><p>Constructor:构造方法</p><ul><li>创建对象：<code>T newInstance(Object... initargs)</code>  <ul><li>如果使用空参数构造方法创建对象，操作可以简化：Class对象newInstance方法</li></ul></li></ul></li><li><p>Method：方法对象</p><ul><li><p>执行方法： Object invoke(Object obj, Object… args)  </p></li><li><p>获取方法名称： String getName:获取方法名</p></li></ul></li></ul></li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul><li>概念；说明程序的，给计算机看的</li><li>注释； 用文字描述程序的，给程序员看的</li><li>定义；注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</li><li><p>概念描述：</p><ul><li>JDK1.5之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li><li><p>作用分类；</p><ul><li>①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li><li>②代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li><li>③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】                                     </li></ul></li><li><p>JDK中预定义的一些注解</p><ul><li><code>@Override</code>：检测被该注解标注的方法是否是继承自父类(接口)的</li><li><code>@Deprecated</code>：该注解标注的内容，表示已过时</li><li><code>@SuppressWarnings</code>：压制警告<ul><li>一般传递参数all  <code>@SuppressWarnings(&quot;all&quot;)</code></li></ul></li></ul></li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li><p>格式；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p><blockquote><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li><li>反编译；cmd -&gt; <code>javap xxx.class</code></li></ul></blockquote></li><li><p>属性；接口中的抽象方法</p><ul><li>要求；<ol><li>属性的返回值类型有下列取值<ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li>定义了属性，在使用时需要给属性赋值<ul><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ul></li></ol></li></ul></li><li><p>元注解；用于描述注解的注解</p><ul><li><code>@Target</code>：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li><code>@Retention</code>：描述注解被保留的阶段<ul><li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li></ul></li><li><code>@Documented</code>：描述注解是否被抽取到api文档中</li><li><code>@Inherited</code>：描述注解是否被子类继承</li></ul></li><li><p>在程序使用(解析)注解：获取注解中定义的属性值</p><ol><li>获取注解定义的位置的对象  （Class，Method,Field）</li><li>获取指定的注解<ul><li>getAnnotation(Class)<blockquote><p>其实就是在内存中生成了一个该注解接口的子类实现对象</p></blockquote></li></ul></li><li>调用注解中的抽象方法获取配置的属性值</li></ol></li><li>注意；   <ol><li>以后大多数时候，使用注解，而不是自定义注解</li><li>注解给谁用？<ul><li>编译器</li><li>给解析程序用</li></ul></li><li>注解不是程序的一部分，可以理解为一个标签</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Junit&quot;&gt;&lt;a href=&quot;#Junit&quot; class=&quot;headerlink&quot; title=&quot;Junit&quot;&gt;&lt;/a&gt;Junit&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
    
      <category term="Java" scheme="https://coderjeremy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://coderjeremy.github.io/2020/02/09/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://coderjeremy.github.io/2020/02/09/Java8新特性/</id>
    <published>2020-02-09T02:58:50.000Z</published>
    <updated>2020-02-09T03:00:04.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>有且只有一个抽象方法的接口，称之为函数式接口</li><li>接口中可以包含其他的方法（默认，静态，私有），但是只能有一个抽象方法。</li><li><p><code>@FunctionalInterface</code>注解</p><ul><li>检测接口是否是一个函数式接口<ul><li>是；编译成功</li><li>否；编译失败（接口中没有抽象方法或抽象方法的个数大于1）</li></ul></li><li>格式；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用；一般可以作为方法的参数和返回值类型</p></li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="Lambda的延迟执行"><a href="#Lambda的延迟执行" class="headerlink" title="Lambda的延迟执行"></a>Lambda的延迟执行</h4><ul><li>Lambda特点；延迟执行</li><li>作用；提升性能</li></ul><h3 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h3><h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><ul><li><code>java.util.function.Supplier&lt;T&gt;</code>；接口仅包含一个无参的方法；<code>T get()</code>。用来获取一个泛型参数指定类型的对象数据。</li><li>生产型接口；指定接口的泛型是什么类型，那么接口中的get方法就会产生什么类型的数据</li></ul><h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><ul><li><code>java.util.function.Consumer&lt;T&gt;</code>；接口包含抽象方法<code>void accept(T t)</code>，意为消费一个指定泛型数据</li><li>消费型接口，泛型执行什么类型，就可以使用accept方法消费什么类型的数据，至于具体怎么消费，需要定义计算</li><li>默认方法；<code>addThen</code><ul><li>需要两个Consumer接口，可以把两个Consumer接口组合到一起，在对数据进行消费</li><li>源码；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;<span class="function">T <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span></span>&#123;</span><br><span class="line">    Objects.requirNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t)-&gt;&#123;accept(t);after.accept(t);&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><ul><li><code>java.util.function.Predicate&lt;T&gt;</code>接口；对某种数据类型的数据进行判断，结果返回一个Boolean值</li><li>抽象方法；<code>boolean test(T t)</code>；用来对指定数据类型数据进行判断的方法</li><li><p>默认方法；</p><ul><li><p><code>add</code>；与</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">Objects.requireNonNull(other);</span><br><span class="line"><span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>or</code>；或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">Objects.requireNonNull(other);</span><br><span class="line"><span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>negate</code>；非</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><ul><li><code>java.util.function.Function&lt;T,R&gt;</code>；接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件</li><li>抽象方法；<code>R apply(T t)</code>；根据类型T的参数获取类型R的的结果（一般用于类型转换）</li><li>默认方法；<ul><li><code>andThen</code></li></ul></li></ul><h2 id="Stream流式思想"><a href="#Stream流式思想" class="headerlink" title="Stream流式思想"></a>Stream流式思想</h2><ul><li>JDK1.8之后</li><li>关注做什么，不关注怎么做</li><li>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）</li><li>Stream（流）是一个来自数据源的元素队列<ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源流的来源。 可以是集合，数组等。</li></ul></li><li>Stream操作还有两个基础的特征：<ul><li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul></li><li>使用步骤<ol><li>获取数据源</li><li>数据转换</li><li>执行操作获取想要的结果</li></ol></li><li>注意；<ul><li>Stream流属于管道流，只能被消费一次，第一个Stream流调用完毕，就会关闭。<h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3></li></ul></li><li>两种方法<ol><li>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流</li><li><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流<blockquote><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java8新加入的最常用的流接口</p></blockquote><h4 id="根据COllection获取流"><a href="#根据COllection获取流" class="headerlink" title="根据COllection获取流"></a>根据COllection获取流</h4></li></ol></li><li><code>default Stream&lt;E&gt; stream()</code></li></ul><h4 id="根据Stream接口获取流"><a href="#根据Stream接口获取流" class="headerlink" title="根据Stream接口获取流"></a>根据Stream接口获取流</h4><ul><li><code>static &lt;T&gt; Stream&lt;T&gt; of(T...values)</code>；参数是一个可变参数，可以传递一个数组</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>延迟方法；返回值类型仍然是<code>Stream</code>接口自身类型的方法，因此支持链式调用。</li><li>终结方法；返回值类型不再是<code>Stream</code>接口自身类型的方法，因此不再支持类似<code>StringBuilder</code>那样的链式调用<h5 id="逐一处理；foreach"><a href="#逐一处理；foreach" class="headerlink" title="逐一处理；foreach"></a>逐一处理；foreach</h5></li><li><code>void forEach(Consumer&lt;? super T&gt; action)</code>；该方法接收一个<code>Consumer</code>接口函数，会将每一个流元素交给该函数进行处理</li><li>forEach方法，用来遍历流中的数据，是一个终结方法，遍历之后就不能继续调用Stream流中的其他方法<h5 id="过滤；filter"><a href="#过滤；filter" class="headerlink" title="过滤；filter"></a>过滤；filter</h5></li><li><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>；可以通过filter方法将一个流转换为另一个子集流<h5 id="映射；map"><a href="#映射；map" class="headerlink" title="映射；map"></a>映射；map</h5></li><li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code>；将流中的元素映射到另一个流中，可以使用map方法<h5 id="统计个数；count"><a href="#统计个数；count" class="headerlink" title="统计个数；count"></a>统计个数；count</h5></li><li><code>long count()</code>；用于统计Stream流中元素的个数</li><li>count方法是一个终结方法，返回值是一个long类型的整数，所有不能再继续调用Stream流中的其他方法<h5 id="取用前几个；limit"><a href="#取用前几个；limit" class="headerlink" title="取用前几个；limit"></a>取用前几个；limit</h5></li><li><code>Stream&lt;T&gt; limit(long maxSize);</code>；用于截取流中的元素</li><li>limit是一个延迟方法，只是对流中的元素进行截取，返回是一个新的流，所以可以继续调用Stream流中的其他方法<h5 id="跳过前几个；skip"><a href="#跳过前几个；skip" class="headerlink" title="跳过前几个；skip"></a>跳过前几个；skip</h5></li><li><code>Stream&lt;T&gt; skip(long n);</code>；用于跳过元素</li><li>如果流的当前长度大于n，则跳过前n个，否则会得到一个长度为0的空流<h5 id="组合；concat"><a href="#组合；concat" class="headerlink" title="组合；concat"></a>组合；concat</h5></li><li><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code>；将两个流合并为一个流</li><li>这是一个静态方法，与String中的concat方法不同</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ul><li>方法引用符：双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<code>方法引用</code>。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者</li><li>语义；<ul><li>Lambda表达式写法： <code>s -&gt; System.out.println(s)</code>；拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。</li><li>方法引用写法：<code>System.out::println</code>；直接让<code>System.out</code> 中的 <code>println</code> 方法来取代<code>Lambda</code>。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。<blockquote><p>注:Lambda中传递的参数一定是方法引用中的那个方法可以接收的类型,否则会抛出异常</p></blockquote></li></ul></li><li>通过对象名引用成员方法<ul><li>通过对象名引用成员方法，使用前提是对象名已经存在，成员方法也是已经存在的</li></ul></li><li>通过类名称引用静态方法</li><li>通过super引用成员方法</li><li>通过this引用成员方法、</li><li>类的构造器引用</li><li>数组的构造器引用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java8新特性&quot;&gt;&lt;a href=&quot;#Java8新特性&quot; class=&quot;headerlink&quot; title=&quot;Java8新特性&quot;&gt;&lt;/a&gt;Java8新特性&lt;/h1&gt;&lt;h2 id=&quot;函数式接口&quot;&gt;&lt;a href=&quot;#函数式接口&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Java" scheme="https://coderjeremy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="https://coderjeremy.github.io/2020/02/05/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://coderjeremy.github.io/2020/02/05/Java网络编程/</id>
    <published>2020-02-05T04:25:53.000Z</published>
    <updated>2020-02-05T04:28:18.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><ul><li>软件结构：<ul><li>C/S；Client/Server</li><li>B/S；Browser/Server</li></ul></li></ul><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ul><li>TCP/IP协议；传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)<ul><li>应用层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul></li><li>TCP；传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。<blockquote><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠<ul><li>第一次：客户端—&gt;服务器（发请求）</li><li>第二次：客户端&lt;—服务器（返回响应）</li><li>第三次：客户端—&gt;服务器（曲儿响应）</li></ul></li></ul></blockquote></li><li>UDP；用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3></li><li>IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。</li><li>IP分类：<ul><li>IPv4；是一个32位的二进制数，通常被分为4个字节，表示成 <code>a.b.c.d</code>的形式，例如<code>192.168.65.100</code> 。其中<code>a、b、c、d</code>都是0~255之间的十进制整数，那么最多可以表示42亿个是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code>的形式，例如 <code>192.168.65.100</code> 。其中<code>a、b、c、d</code>都是0~255之间的十进制整数，那么最多可以表示42亿个</li><li>IPv6；采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成 <code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code> </li></ul></li><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3></li><li>用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li><li>常用端口号；<ul><li>80；网络端口</li><li>3306；MySQL</li><li>1521；Oracle</li><li>8080：Tomcat</li></ul></li></ul><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><ul><li>客户端和服务器端进行一个数据交互，需要4个IO流对象</li><li>服务器端必须明确；<ol><li>多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互。在服务器端有个方法叫accept客户端获取到请求的客户端对象</li><li>多个客户端同时和服务器端进行交互，就需要使用多个IO流对象<ul><li>服务器是没有IO流的，服务器可以获取到请求的客户端对象Socket。使用每个客户端Socket中提供的IO流和客户端进行交互（服务器使用客户端的流和客户端交互）</li></ul></li></ol></li><li>TCP通信的客户端；向服务器发送连接请求，给服务i去发送数据，读取服务器回写的数据<h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h3></li><li>表示客户端的类；<code>java.net.Socket</code>；此类实现客户端套接字，套接字是两台机器之间通信的端点。套接字包含了IP地址和端口号的网络单位</li><li>构造方法：<ul><li><code>Socket(String host,int port)</code>；创建一个流套接字并将其连接到指定主机上的指定端口号。<ul><li>String host；服务器主机的名称/服务器的IP地址</li><li>int port；服务器的端口号</li></ul></li></ul></li><li>成员方法；<ul><li><code>OutputStream getOutputStream()</code>；返回此套接字的输出流</li><li><code>InputStream getInputStream()</code>；返回此套接字的输入流</li><li><code>void close()</code>；关闭此套接字</li></ul></li><li>实现步骤；<ol><li>创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号</li><li>使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</li><li>使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</li><li>使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</li><li>使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</li><li>释放资源（Socket）</li></ol></li><li>注意；<ol><li>客户端和服务器端进行交互，必须使用Socket中提供网络流，不能使用自己创建的流对象</li><li>当我们创建客户端对象Socket时，就会去请求服务器和服务器经过3次握手建立连接通路。如果服务器没有启动，则抛出异常，如果服务器启动，则进行交互</li></ol></li></ul><h3 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h3><ul><li>表示服务器的类；<code>java.net.ServerSocket</code>；此类实现服务器套接字</li><li>构造方法；<ul><li><code>ServerSocket(int port)</code>；创建绑定到特定端口的服务器套接字</li></ul></li><li>服务器端必须明确是哪个客户端请求的服务器，所以可以使用accpet方法获取到请求的客户端对象Socket</li><li>成员方法；<ul><li><code>Socket accept()</code>；侦听并接收到此套接字的连接</li></ul></li><li>实现步骤；<ol><li>创建服务器ServerSocket对象和系统要指定的端口号</li><li>使用ServerSocket对象中的方法accpept获取到请求的客户端对象Socket</li><li>使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</li><li>使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</li><li>使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</li><li>使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据</li><li>释放资源(Socket、ServerSocket)</li></ol></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>上传完文件，给服务器写一个结束标记<ul><li><code>void shutdownOutput()</code>；禁用次套接字的输出流。对于TCP套接字，任何以前写入的数据都将发送，并且后跟TCP的正常连接终止序列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java网络编程&quot;&gt;&lt;a href=&quot;#Java网络编程&quot; class=&quot;headerlink&quot; title=&quot;Java网络编程&quot;&gt;&lt;/a&gt;Java网络编程&lt;/h1&gt;&lt;h2 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="https://coderjeremy.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
