<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s Blog</title>
  
  <subtitle>艰险我奋进，困乏我多情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coderjeremy.github.io/"/>
  <updated>2019-01-14T12:56:32.303Z</updated>
  <id>https://coderjeremy.github.io/</id>
  
  <author>
    <name>吴健伟_Jeremy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习笔记</title>
    <link href="https://coderjeremy.github.io/2019/01/14/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://coderjeremy.github.io/2019/01/14/Python学习笔记/</id>
    <published>2019-01-14T08:55:26.000Z</published>
    <updated>2019-01-14T12:56:32.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><blockquote><p>产生列表的子集<br>字符串、列表、元组都支持切片操作<br>切片的语法：[起始 ： 结束 ：步长]<br>左闭右开 步长表示选取的间隔 默认是 1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串切片</span><br><span class="line">name = <span class="string">"abcdefghijk"</span></span><br><span class="line">print(name[<span class="number">4</span>:<span class="number">6</span>]) <span class="comment"># 取下表4-6，也就是name[4],name[5]</span></span><br><span class="line">print(name[<span class="number">2</span>:]) <span class="comment"># 结束缺省，表示取下标为2开始到最后的字符</span></span><br><span class="line">print(name[:<span class="number">3</span>]) <span class="comment"># 开始缺省，表示取开始到下标为3之前的字符</span></span><br><span class="line">print(name[<span class="number">1</span>:<span class="number">-1</span>]) <span class="comment"># 负数索引返回离列表末尾相应距离的元素</span></span><br><span class="line">print(name[::<span class="number">-1</span>]) <span class="comment"># 步长为负， 表示从后往前切片</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">列表切片</span><br><span class="line">cars = [<span class="string">'Audi'</span>, <span class="string">'BMW'</span>, <span class="string">'BenZi'</span>, <span class="string">'Toyota'</span>]</span><br><span class="line">print(cars[::<span class="number">-1</span>]) <span class="comment"># 逆序输出列表,实际结构没有发生改变</span></span><br><span class="line">print(cars[<span class="number">1</span>:<span class="number">3</span>]) <span class="comment"># 产生列表的子集，切片始于'BMW',终于‘Benzi’</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">切片的应用</span><br><span class="line"><span class="comment"># 实现 [1，2，3，4....100]变成[[1,2,3],[4,5,6],...]</span></span><br><span class="line">a = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)]</span><br><span class="line">print(a)</span><br><span class="line">b = [a[x:x+<span class="number">3</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, len(a), <span class="number">3</span>)] <span class="comment"># 产生列表的子集</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h1 id="可变的类型-：-列表List-字典Dict-集合Set"><a href="#可变的类型-：-列表List-字典Dict-集合Set" class="headerlink" title="可变的类型 ： 列表List 字典Dict 集合Set"></a>可变的类型 ： 列表List 字典Dict 集合Set</h1><h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line">nameList = [<span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>, <span class="number">1234</span>]</span><br><span class="line"><span class="comment"># 打印列表</span></span><br><span class="line">print(nameList)</span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">print(nameList[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> nameList:</span><br><span class="line">    print(name)</span><br><span class="line"><span class="comment"># while循环遍历</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(nameList):</span><br><span class="line">    print(nameList[i])</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表的相关操作</span></span><br><span class="line"><span class="comment"># 1. 添加元素</span></span><br><span class="line"><span class="comment"># append()</span></span><br><span class="line">A = [<span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>, <span class="number">1234</span>]</span><br><span class="line">temp = input(<span class="string">"请输入学生姓名:"</span>)</span><br><span class="line">A.append(temp)</span><br><span class="line">print(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># extend()可以将另一个元素逐一追加到列表中,append是整体添加</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.append(b)</span><br><span class="line">print(a)</span><br><span class="line">a.extend(b)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert() 在指定位置插入元素(位置，元素)</span></span><br><span class="line">c = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">c.insert(<span class="number">1</span>, <span class="string">'3'</span>)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改操作</span></span><br><span class="line">A = [<span class="string">'xiaoming'</span>, <span class="string">'xiaohong'</span>, <span class="number">1234</span>]</span><br><span class="line">A[<span class="number">1</span>] = <span class="string">'小红'</span></span><br><span class="line">print(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查询</span></span><br><span class="line"><span class="comment"># in / not in / index / count</span></span><br><span class="line"><span class="comment"># in</span></span><br><span class="line">nameList = [<span class="string">'xiaoming'</span>, <span class="string">'xiaohong'</span>, <span class="number">1234</span>]</span><br><span class="line">findName = input(<span class="string">"请输入要查找的姓名"</span>)</span><br><span class="line"><span class="keyword">if</span> findName <span class="keyword">in</span> nameList:</span><br><span class="line">    print(<span class="string">"你要找的人在列表中"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没找到"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#index 返回第一次出现的序号</span></span><br><span class="line"><span class="comment">#count 返回出现的次数</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">index = a.index(<span class="string">'a'</span>)</span><br><span class="line">print(index)</span><br><span class="line">count = a.count(<span class="string">'a'</span>)</span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.删除</span></span><br><span class="line">nameList = [<span class="string">'xiaoming'</span>, <span class="string">'xiaohong'</span>, <span class="number">1234</span>]</span><br><span class="line"><span class="comment"># del  根据下表删除</span></span><br><span class="line"><span class="keyword">del</span> nameList[<span class="number">2</span>]</span><br><span class="line">print(nameList)</span><br><span class="line"><span class="comment"># pop</span></span><br><span class="line">print(nameList)</span><br><span class="line">nameList.pop()</span><br><span class="line">print(nameList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove 根据元素的值进行删除</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">print(a)</span><br><span class="line">a.remove(<span class="string">'a'</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># sort()正序</span></span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment">#a.reverse(sort=True)</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># reverse() 逆序  也可以写作sort(reverse=True)，反过来不可以</span></span><br><span class="line">b.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#b.reverse()</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个学校，有三个办公室，8位老师等待分配工位，完成随机分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 定义一个列表来保存3个办公室</span></span><br><span class="line">offices = [[], [], []]</span><br><span class="line"><span class="comment"># 定义一个列表来保存8个教师姓名</span></span><br><span class="line">names = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    names.append(string.ascii_uppercase[i])</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    index = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    offices[index].append(name)</span><br><span class="line"><span class="comment"># print(offices)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历展示</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> tempNames <span class="keyword">in</span> offices:</span><br><span class="line">    print(<span class="string">"办公室%d的人数为 %d : "</span> % (i, len(tempNames)), end=<span class="string">''</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> tempNames:</span><br><span class="line">        print(<span class="string">"%s"</span> % name, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">'-'</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure><h2 id="字典Dict"><a href="#字典Dict" class="headerlink" title="字典Dict"></a>字典Dict</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典 &#123;key1: value1, key2: value2&#125;</span></span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'马云'</span>, id: <span class="number">100</span>, <span class="string">'sex'</span>: <span class="string">'m'</span>, <span class="string">'address'</span>: <span class="string">'杭州'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据键 进行访问</span></span><br><span class="line"><span class="comment"># key: value</span></span><br><span class="line">print(info[id])</span><br><span class="line"><span class="comment"># 访问不存在的键会报错</span></span><br><span class="line"><span class="comment">#print(info['age']) #keyError: 'age‘</span></span><br><span class="line"><span class="comment"># 面向对象的访问, 若不存在，返回默认值</span></span><br><span class="line">age = info.get(<span class="string">'age'</span>, <span class="number">18</span>)</span><br><span class="line">print(age)</span><br><span class="line">print(type(age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见操作</span></span><br><span class="line"><span class="comment"># 1. 查看</span></span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'西卡'</span>, <span class="string">'age'</span>: <span class="number">26</span>&#125;</span><br><span class="line">print(info[<span class="string">'age'</span>])</span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">age = input(<span class="string">"请输入年龄:"</span>)</span><br><span class="line">info[<span class="string">'age'</span>] = age</span><br><span class="line">print(info)</span><br><span class="line"><span class="comment"># 添加 键不存在，就会新增这个元素</span></span><br><span class="line">add = input(<span class="string">"请输入户籍所在地:"</span>)</span><br><span class="line">info[<span class="string">'address'</span>] = add</span><br><span class="line">print(info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 del删除字典某个元素 clear()清空字典</span></span><br><span class="line"><span class="comment"># del info['address']</span></span><br><span class="line"><span class="comment"># print(info)</span></span><br><span class="line"><span class="comment"># info.clear()</span></span><br><span class="line"><span class="comment"># print(info)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典方法</span></span><br><span class="line"><span class="comment"># len() 键值对个数 以列表方式储存</span></span><br><span class="line">print(len(info))</span><br><span class="line"><span class="comment"># keys()返回所有键 values() 返回所有值 以列表方式储存</span></span><br><span class="line">print(info.keys())</span><br><span class="line">print(info.values())</span><br><span class="line"><span class="comment"># items 返回键值对列表 以列表方式储存</span></span><br><span class="line">print(info.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典的遍历</span></span><br><span class="line"><span class="comment"># key()</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info.keys():</span><br><span class="line">    print(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> info.values():</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项 (元素)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info.items():</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> info.items():</span><br><span class="line">    print(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 循环迭代</span></span><br><span class="line"><span class="comment"># chars = ['a', 'b', 'c', 'd']</span></span><br><span class="line"><span class="comment"># for i, chr in enumerate(chars):</span></span><br><span class="line"><span class="comment">#     print(i, chr)</span></span><br></pre></td></tr></table></figure><h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集合</span></span><br><span class="line"><span class="comment"># 无序 元素唯一 一般用于元组或列表的元素去重</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment"># 添加元素 add()</span></span><br><span class="line">set1.add(<span class="number">9</span>)</span><br><span class="line">print(set1)</span><br><span class="line"><span class="comment"># 修改元素 update()</span></span><br><span class="line">set1.update(<span class="string">'abcd'</span>)</span><br><span class="line">print(set1)</span><br><span class="line"><span class="comment"># 删除元素 remove()不存在会报错</span></span><br><span class="line">set1.remove(<span class="number">1</span>)</span><br><span class="line">print(set1)</span><br><span class="line"><span class="comment"># pop 随机删除集合中某个元素</span></span><br><span class="line">set1.pop()</span><br><span class="line">print(set1)</span><br><span class="line"><span class="comment"># discard 丢弃，放弃，不会报错</span></span><br><span class="line">set1.discard(<span class="number">123</span>)</span><br><span class="line">print(set1)</span><br></pre></td></tr></table></figure><h1 id="不可变的类型-：数字Num-字符串Str-元组Tuple"><a href="#不可变的类型-：数字Num-字符串Str-元组Tuple" class="headerlink" title="不可变的类型 ：数字Num 字符串Str 元组Tuple"></a>不可变的类型 ：数字Num 字符串Str 元组Tuple</h1><h2 id="数字Num"><a href="#数字Num" class="headerlink" title="数字Num"></a>数字Num</h2><p>Python Number 数据类型用于存储数值。<br>数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。</p><h2 id="字符串Str"><a href="#字符串Str" class="headerlink" title="字符串Str"></a>字符串Str</h2><p>Python不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。<br>Python访问子字符串，可以使用方括号来截取字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'today is Sunday'</span></span><br><span class="line">print(str[<span class="number">4</span>])</span><br><span class="line">print(len(str))</span><br><span class="line">print(type(str))</span><br></pre></td></tr></table></figure></p><h2 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组 tuple</span></span><br><span class="line"><span class="comment"># python 中的元组和列表类似，元组的元素是无法进行修改的</span></span><br><span class="line"><span class="comment"># 元组() 列表[]</span></span><br><span class="line"><span class="comment"># return a, b, c</span></span><br><span class="line">aTuple = (<span class="string">'et'</span>, <span class="number">77</span> , <span class="number">3.14</span>)</span><br><span class="line">print(aTuple)</span><br><span class="line">print(type(aTuple))</span><br><span class="line"><span class="comment"># 元组中只有一个元素，需要逗号结尾，否则会引起歧异</span></span><br><span class="line">bTuple = (<span class="number">12</span>,)</span><br><span class="line">print(type(bTuple))</span><br><span class="line"><span class="comment"># 访问元组</span></span><br><span class="line">print(aTuple[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 修改元组 不支持修改</span></span><br><span class="line"><span class="comment"># aTuple[0] = 123</span></span><br><span class="line"><span class="comment"># count index</span></span><br><span class="line">a = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</span><br><span class="line">print(a.index(<span class="string">'a'</span>, <span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line">print(a.count(<span class="string">'b'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;产生列表的子集&lt;br&gt;字符串、列表、元组都支持切片操作&lt;br&gt;切片的语法：[起始 ： 结束 ：步长]&lt;br&gt;左闭右
      
    
    </summary>
    
    
      <category term="python" scheme="https://coderjeremy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Shell读取文件并批量添加用户</title>
    <link href="https://coderjeremy.github.io/2018/11/06/Shell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/"/>
    <id>https://coderjeremy.github.io/2018/11/06/Shell读取文件并批量添加用户/</id>
    <published>2018-11-06T06:29:15.000Z</published>
    <updated>2018-11-06T08:01:10.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在linux中要求从一个文件中读取用户名和密码，并批量添加账户</p></blockquote><p>文件格式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jeremy]# cat users.list </span><br><span class="line">apple 12345</span><br><span class="line">banana 123456</span><br><span class="line">orange 123123</span><br><span class="line">pear 123123</span><br></pre></td></tr></table></figure></p><h1 id="第一步：读取用户名和密码"><a href="#第一步：读取用户名和密码" class="headerlink" title="第一步：读取用户名和密码"></a>第一步：读取用户名和密码</h1><ol><li>创建 <code>user.sh</code>文件</li><li>按行读取用户信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jeremy]# vim user.sh</span><br><span class="line">[root@localhost jeremy]# cat user.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cat users.list | while read line</span><br><span class="line">do </span><br><span class="line"> echo $line</span><br><span class="line">done</span><br><span class="line">[root@localhost jeremy]# ./user.sh </span><br><span class="line">apple 12345</span><br><span class="line">banana 123456</span><br><span class="line">orange 123123</span><br><span class="line">pear 123123</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>读取每一行内容并输出有多种方式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 第一种 <span class="keyword">while</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">while</span> <span class="built_in">read</span> line</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  <span class="built_in">echo</span> <span class="variable">$line</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">done</span> &lt; filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 第二种 <span class="keyword">while</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat filename | <span class="keyword">while</span> <span class="built_in">read</span> line</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  <span class="built_in">echo</span> <span class="variable">$line</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 第三种 <span class="keyword">for</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> line <span class="keyword">in</span> `cat filename`</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">do</span> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  <span class="built_in">echo</span> <span class="variable">$line</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span>循环在读取文件时，任何空白字符都可以作为其读取的分隔符.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">while</span>使用是换行符作为标记</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ex: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> line <span class="keyword">in</span> $(&lt;users.list) 结果如下</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> apple</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 12345</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> banana</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 123456</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> orange</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 123123</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> pear</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 123123</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="第二步：分割用户名和密码"><a href="#第二步：分割用户名和密码" class="headerlink" title="第二步：分割用户名和密码"></a>第二步：分割用户名和密码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jeremy]# cat user.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cat users.list | while read line</span><br><span class="line">do </span><br><span class="line"> username=`echo $line | cut -f1 -d' '`</span><br><span class="line"> password=`echo $line | cut -f2 -d' '`</span><br><span class="line"> echo -n "USERNAME:$username PASSWORD:$password"</span><br><span class="line"> echo</span><br><span class="line">done </span><br><span class="line">[root@localhost jeremy]# ./user.sh </span><br><span class="line">USERNAME:apple PASSWORD:12345</span><br><span class="line">USERNAME:banana PASSWORD:123456</span><br><span class="line">USERNAME:orange PASSWORD:123123</span><br><span class="line">USERNAME:pear PASSWORD:123123</span><br></pre></td></tr></table></figure><h1 id="第三步：批量添加用户"><a href="#第三步：批量添加用户" class="headerlink" title="第三步：批量添加用户"></a>第三步：批量添加用户</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jeremy]# cat user.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cat users.list | while read line</span><br><span class="line">do </span><br><span class="line"> username=`echo $line | cut -f1 -d' '`</span><br><span class="line"> password=`echo $line | cut -f2 -d' '`</span><br><span class="line"> useradd $username</span><br><span class="line"> echo $password | passwd --stdin $username</span><br><span class="line">done </span><br><span class="line">[root@localhost jeremy]# ./user.sh </span><br><span class="line">更改用户 apple 的密码 。</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line">更改用户 banana 的密码 。</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line">更改用户 orange 的密码 。</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line">更改用户 pear 的密码 。</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure><h1 id="第四步：完善脚本"><a href="#第四步：完善脚本" class="headerlink" title="第四步：完善脚本"></a>第四步：完善脚本</h1><p>以上脚本再运行一便，会发现新增用户不行了。但会修改了密码.应该增加一个用户是否存在的判断.另外所有非Shell内建命令都建议使用全路径，以避免由于环境变量的问题造成command not found。最后，脚本主体要尽量少使用变量，所以需要在脚本开头定义变量.如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line">USER_INFO=/home/jeremy/users.list</span><br><span class="line">USERADD=/usr/sbin/useradd</span><br><span class="line">PASSWD=/usr/bin/passwd</span><br><span class="line">CUT=/bin/cut</span><br><span class="line">while read LINES</span><br><span class="line">do</span><br><span class="line">    USERNAME=`echo $LINES | $CUT -f1 -d' '`</span><br><span class="line">    USERPASS=`echo $LINES | $CUT -f2 -d' '`</span><br><span class="line">    $USERADD $USERNAME</span><br><span class="line">    if [ $? -ne 0 ];then</span><br><span class="line">        echo "$USERNAME exists,skip set password"</span><br><span class="line">    else</span><br><span class="line">        echo $USERPASS | $PASSWD --stdin $USERNAME</span><br><span class="line">    fi</span><br><span class="line">done &lt; $USER_INFO</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在linux中要求从一个文件中读取用户名和密码，并批量添加账户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件格式：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="Language" scheme="https://coderjeremy.github.io/categories/Language/"/>
    
    
      <category term="编程语言" scheme="https://coderjeremy.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="脚本" scheme="https://coderjeremy.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="https://coderjeremy.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本编程</title>
    <link href="https://coderjeremy.github.io/2018/11/06/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    <id>https://coderjeremy.github.io/2018/11/06/Shell脚本编程/</id>
    <published>2018-11-06T01:18:01.000Z</published>
    <updated>2018-11-06T05:53:27.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>Shell 是一个用C语言编写的程序，它既是一种命令语言，又是一种程序设计语言。</p><h1 id="Shell-Script"><a href="#Shell-Script" class="headerlink" title="Shell Script"></a>Shell Script</h1><p>Shell脚本，用shell编写的脚本程序</p><h1 id="First-Shell"><a href="#First-Shell" class="headerlink" title="First Shell"></a>First Shell</h1><ol><li>创建一个<code>.sh</code>为文件后缀的文件，<code>hello.sh</code></li><li>内容如下<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注释</span></span><br><span class="line"><span class="meta">#</span><span class="bash">author : jeremy</span></span><br><span class="line">echo "Hello Shell !"</span><br></pre></td></tr></table></figure></li></ol><p>保存退出</p><ol start="3"><li><p>先赋予执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod a+x hello.sh</span></span><br></pre></td></tr></table></figure></li><li><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./hello.sh</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable_name=variable_value</span><br><span class="line">等号左右无空格</span><br><span class="line"></span><br><span class="line">ex:</span><br><span class="line">User="Jeremy"</span><br><span class="line">Pwd="123456"</span><br></pre></td></tr></table></figure><h2 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h2><p>使用美元符号<code>$</code>访问变量,可以给变量加上<code>{ }</code>花括号，帮助解释器识别变量的边界<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/bin/sh</span></span><br><span class="line"></span><br><span class="line">User="Jeremy"</span><br><span class="line">Pwd=“123456”</span><br><span class="line">echo $User</span><br><span class="line">echo $&#123;Pwd&#125;</span><br></pre></td></tr></table></figure></p><p>打印 <code>User</code> 和 <code>Pwd</code> 的值</p><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用<code>readonly</code>可以将变量定义为只读变量，只读变量的值不能改变<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/bin/sh</span></span><br><span class="line"></span><br><span class="line">User="Jeremy"</span><br><span class="line">readonly User</span><br></pre></td></tr></table></figure></p><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用<code>unset</code>命令可以删除变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/bin/sh</span></span><br><span class="line"></span><br><span class="line">User="Jeremy"</span><br><span class="line">unset User</span><br></pre></td></tr></table></figure></p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量在脚本或命令中定义，仅在当前shell实例中有效</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证正常运行，shell脚本也可以定义环境变量</p><h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><p>shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">0当前脚本的文件名</span></span><br><span class="line"><span class="meta">$</span><span class="bash">n传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是<span class="variable">$1</span>，第二个参数是<span class="variable">$2</span>。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#传递给脚本或函数的参数个数。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">*传递给脚本或函数的所有参数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">@传递给脚本或函数的所有参数。被双引号(<span class="string">" "</span>)包含时，与 $* 稍有不同，下面将会讲到。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">?上个命令的退出状态，或函数的返回值。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">$当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</span></span><br></pre></td></tr></table></figure><h1 id="数组Arrays"><a href="#数组Arrays" class="headerlink" title="数组Arrays"></a>数组Arrays</h1><p>Bash Shell只支持一维数组，初始化时不需要定义数组大小<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">array_name</span>=(value1...valueN)</span><br></pre></td></tr></table></figure></p><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_name[index]=value</span><br><span class="line"></span><br><span class="line">ex:</span><br><span class="line">User[0]="apple"</span><br><span class="line">User[1]="banana"</span><br><span class="line">User[2]="orange"</span><br></pre></td></tr></table></figure><h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>和访问变量格式相同<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[index]&#125;</span></span><br><span class="line">ex:</span><br><span class="line">User[0]="apple"</span><br><span class="line">User[1]="banana"</span><br><span class="line">User[2]="orange"</span><br><span class="line">echo $&#123;User[0]&#125;</span><br><span class="line">echo $&#123;User[@]&#125;</span><br><span class="line"></span><br><span class="line">以下两种方式可以访问数组中的所有项目</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[*]&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><p>Bourne shell没有任何机制来执行简单的算术，它使用外部程序awk或expr</p><ul><li>运算符和表达式之间必须有空格</li><li>`  `  倒逗号之间包含完整的表达式 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo $val</span><br></pre></td></tr></table></figure><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>a=10<br>b=20</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加法</td><td style="text-align:center">` expr $a + $b ` 结果为 30。</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减法</td><td style="text-align:center">` expr $a - $b ` 结果为 -10。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘法</td><td style="text-align:center">` expr $a * $b ` 结果为  200。</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除法</td><td style="text-align:center">` expr $b / $a ` 结果为 2。</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余</td><td style="text-align:center">` expr $b % $a ` 结果为 0。</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">赋值</td><td style="text-align:center">a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">相等</td><td style="text-align:center">[$a==$b] 返回 false。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不相等</td><td style="text-align:center">[$a!=$b] 返回 true。</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">-eq</td><td style="text-align:center">检测两个数是否相等，相等返回 true。</td><td style="text-align:center">[ $a -eq $b ] 返回 false。</td></tr><tr><td style="text-align:center">-ne</td><td style="text-align:center">检测两个数是否不相等，不相等返回 true。</td><td style="text-align:center">[ $a -ne $b ] 返回 true。</td></tr><tr><td style="text-align:center">-gt</td><td style="text-align:center">检测左边的数是否大于右边的，如果是，则返回 true。</td><td style="text-align:center">[ $a -gt $b ] 返回 false。</td></tr><tr><td style="text-align:center">-lt</td><td style="text-align:center">检测左边的数是否小于右边的，如果是，则返回 true。</td><td style="text-align:center">[ $a -lt $b ] 返回 true。</td></tr><tr><td style="text-align:center">-ge</td><td style="text-align:center">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td style="text-align:center">[ $a -ge $b ] 返回 false。</td></tr><tr><td style="text-align:center">-le</td><td style="text-align:center">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style="text-align:center">[ $a -le $b ] 返回 true。</td></tr></tbody></table><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">!</td><td style="text-align:center">非运算，表达式为 true 则返回 false，否则返回 true。</td><td style="text-align:center">[ ! false ] 返回 true。</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">或运算，有一个表达式为 true 则返回 true。</td><td style="text-align:center">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td style="text-align:center">-a</td><td style="text-align:center">与运算，两个表达式都为 true 才返回 true。</td><td style="text-align:center">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">检测两个字符串是否相等，相等返回 true。</td><td style="text-align:center">[ $a = $b ] 返回 false。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">检测两个字符串是否相等，不相等返回 true。</td><td style="text-align:center">[ $a != $b ] 返回 true。</td></tr><tr><td style="text-align:center">-z</td><td style="text-align:center">检测字符串长度是否为0，为0返回 true。</td><td style="text-align:center">[ -z $a ] 返回 false。</td></tr><tr><td style="text-align:center">-n</td><td style="text-align:center">检测字符串长度是否为0，不为0返回 true。</td><td style="text-align:center">[ -n “$a” ] 返回 true。</td></tr><tr><td style="text-align:center">str</td><td style="text-align:center">检测字符串是否为空，不为空返回 true。</td><td style="text-align:center">[ $a ] 返回 true。</td></tr></tbody></table><h1 id="Shell条件语句"><a href="#Shell条件语句" class="headerlink" title="Shell条件语句"></a>Shell条件语句</h1><h2 id="if-…-fi"><a href="#if-…-fi" class="headerlink" title="if … fi"></a>if … fi</h2><p>shell expression求值，结果是true，statement被执行，否则不执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if[ expression ]</span><br><span class="line">then</span><br><span class="line">Statement(s) to be executed if expression is true</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h2 id="if-…-else-…-fi"><a href="#if-…-else-…-fi" class="headerlink" title="if … else … fi"></a>if … else … fi</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if[ expression ]</span><br><span class="line">then</span><br><span class="line">Statement(s) to be executed if expression is true</span><br><span class="line">else</span><br><span class="line">Statement(s) to be executed if expression is not true</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="if-…-elif-…-fi"><a href="#if-…-elif-…-fi" class="headerlink" title="if … elif … fi"></a>if … elif … fi</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if [ expression 1 ]</span><br><span class="line">then</span><br><span class="line">Statement(s) to be executed if expression 1 is true</span><br><span class="line">elif [ expression 2 ]</span><br><span class="line">then</span><br><span class="line">Statement(s) to be executed if expression 2 is true</span><br><span class="line">elif [ expression 3 ]</span><br><span class="line">then</span><br><span class="line">Statement(s) to be executed if expression 3 is true</span><br><span class="line">else</span><br><span class="line">Statement(s) to be executed if no expression is true</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="case-esac"><a href="#case-esac" class="headerlink" title="case .. esac"></a>case .. esac</h2><p>这里的字符串字每个模式进行比较，直到找到一个匹配。执行语句匹配模式。如果没有找到匹配，声明退出的情况下不执行任何动作。<br>没有最大数量的模式，但最小是一个。<br>当语句部分执行，命令<code>;;</code> 表明程序流程跳转到结束整个 case 语句。和C编程语言的 break 类似。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case word in</span><br><span class="line">  pattern1)</span><br><span class="line">     Statement(s) to be executed if pattern1 matches</span><br><span class="line">     ;;</span><br><span class="line">  pattern2)</span><br><span class="line">     Statement(s) to be executed if pattern2 matches</span><br><span class="line">     ;;</span><br><span class="line">  pattern3)</span><br><span class="line">     Statement(s) to be executed if pattern3 matches</span><br><span class="line">     ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><h1 id="Shell循环类型"><a href="#Shell循环类型" class="headerlink" title="Shell循环类型"></a>Shell循环类型</h1><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>这里Shell命令进行计算。如果结果值是 true，给定语句被执行。如果命令为 false，那么没有语句将不执行，程序将跳转到done语句后的下一行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while command</span><br><span class="line">do</span><br><span class="line">Statement(s) to be executed if command is true</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>var是一个变量，word1 到 wordN 是由空格分隔的字符（字）序列的名称。每次for 循环的执行，变量var的值被设置为下一个单词的列表中的字，word1 到 wordN 。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in word1 word2 ... wordN</span><br><span class="line">do</span><br><span class="line">Statement(s) to be executed if command is true</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p>这里Shell命令进行评估计算。如果结果值是false，给定语句（s）被执行。如果命令没有语句为true，那么将不执行，程序会跳转到下一行done语句后。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until command</span><br><span class="line">do</span><br><span class="line">   Statement(s) to be executed until command is true</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="select-循环"><a href="#select-循环" class="headerlink" title="select 循环"></a>select 循环</h2><p>var是一个变量，word1 到 wordN是由空格分隔的字符（字）序列的名称。每次for循环的执行，变量var的值被设置为下一个单词的列表中的字，由 word1 到wordN。</p><p>对于每一个选择的一组命令将被执行，在循环中。这个循环在ksh，并已被改编成的bash。这不是在sh。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select var in word1 word2 ... wordN</span><br><span class="line">do</span><br><span class="line">   Statement(s) to be executed for every word.</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shell&quot;&gt;&lt;a href=&quot;#Shell&quot; class=&quot;headerlink&quot; title=&quot;Shell&quot;&gt;&lt;/a&gt;Shell&lt;/h1&gt;&lt;p&gt;Shell 是一个用C语言编写的程序，它既是一种命令语言，又是一种程序设计语言。&lt;/p&gt;
&lt;h1 id=&quot;Shell
      
    
    </summary>
    
      <category term="Language" scheme="https://coderjeremy.github.io/categories/Language/"/>
    
    
      <category term="编程语言" scheme="https://coderjeremy.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="脚本" scheme="https://coderjeremy.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="https://coderjeremy.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux磁盘管理</title>
    <link href="https://coderjeremy.github.io/2018/10/31/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>https://coderjeremy.github.io/2018/10/31/Linux磁盘管理/</id>
    <published>2018-10-31T05:45:17.000Z</published>
    <updated>2018-10-31T06:01:37.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列出磁盘使用量df"><a href="#列出磁盘使用量df" class="headerlink" title="列出磁盘使用量df"></a>列出磁盘使用量df</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> df [‐ahikHTm] 目录或文件名</span></span><br></pre></td></tr></table></figure><blockquote><p>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；<br>-k ：以 KBytes 的容量显示各文件系统；<br>-m ：以 MBytes 的容量显示各文件系统；<br>-h ：以人们较易阅读的 GBytes，MBytes，KBytes 等格式显示；<br>-H ：以 M=1000K 取代 M=1024K 的进位方式；<br>-T ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；<br>-i ：不用硬盘容量，而以 inode 的数量来</p></blockquote><h1 id="检查磁盘空间使用量du"><a href="#检查磁盘空间使用量du" class="headerlink" title="检查磁盘空间使用量du"></a>检查磁盘空间使用量du</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> du [‐ahskm] 文件或目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-a ：递归列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。<br>-h ：以人们较易读的容量格式 (G/M) 显示；<br>-s ：列出总量而已，而不列出每个各别的目录占用容量；<br>-S ：不包括子目录下的总计，与 ­s 有点差别。<br>-k ：以 KBytes 列出容量显示；<br>-m ：以 MBytes 列出容量显</p></blockquote><h1 id="磁盘分区fdisk"><a href="#磁盘分区fdisk" class="headerlink" title="磁盘分区fdisk"></a>磁盘分区fdisk</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> fdisk [‐l] 装置名称（或者叫分区名称，下同）</span></span><br></pre></td></tr></table></figure><blockquote><p>-l ：输出后面参数指定装置所有的分区内容。若仅有<code>fdisk -l</code>时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来</p></blockquote><h1 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkfs [-t 文件系统格式] 装置名称（系统分区名称）</span></span><br></pre></td></tr></table></figure><blockquote><p>-t ：可以指令文件系统格式，例如 xfs，ext4，ext3，ext2, vfat 等(系统有支持才会生</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将分区 <span class="regexp">/dev/</span>hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：</span><br><span class="line"><span class="comment"># mkfs ‐t ext3 /dev/hdc6</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果一个分区已经格式化，则需要再次格式化时，可以加参数 -f 表示强制再次格式化。<br>注意：如果一个分区已经挂载到一个目录之下，则不能在挂载的情况下进行再次格式化操作</p></blockquote><h1 id="磁盘检验"><a href="#磁盘检验" class="headerlink" title="磁盘检验"></a>磁盘检验</h1><p>fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck 命令对文件系统进行检查</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># fsck <span class="string">[‐t 文件系统]</span> <span class="string">[‐ACay]</span> 装置名称</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>-t ： 给定文件系统的格式，若在 /etc/fstab 中已有定义或 kernel 本身已支持的则<br>需加上此参数<br>-s ：依序一个一个地执行 fsck 的指令来检查<br>-A ：对/etc/fstab 中所有列出来的 分区（partition）做检查<br>-C ：显示完整的检查进度<br>-d ：打印出 e2fsck 的 debug 结果<br>-p ：同时有 -A 条件时，同时有多个 fsck 的检查一起执行<br>-R ：同时有 -A 条件时，省略 / 不检查<br>-V ：详细显示模式<br>-a ：如果检查有错则自动修复<br>-r ：如果检查有错则由使用者回答是否修复<br>-y ：选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可<br>以执行 # fsck -y 全部检查修复</p><h1 id="磁盘挂载与卸载"><a href="#磁盘挂载与卸载" class="headerlink" title="磁盘挂载与卸载"></a>磁盘挂载与卸载</h1><p>Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">挂载</span><br><span class="line"><span class="comment"># mount [‐t 文件系统] [‐L Label名] [‐o 额外选项] [‐n] 装置文件名（也叫分区名称） 挂载点（也叫目录名）</span></span><br><span class="line"></span><br><span class="line">将刚刚创建的 <span class="string">/dev/hdc6</span> 分区挂载到 <span class="string">/mnt/hdc6</span> 上面</span><br><span class="line"><span class="comment"># mkdir /mnt/hdc6</span></span><br><span class="line"><span class="comment"># mount /dev/hdc6 /mnt/hdc6</span></span><br><span class="line"><span class="comment"># df</span></span><br><span class="line">Filesystem 1K‐blocks Used Available Use% Mounted on</span><br><span class="line"><span class="string">.....</span>中间省略<span class="string">.....</span></span><br><span class="line"><span class="string">/dev/hdc6</span> 1976312 42072 1833836 3% <span class="string">/mnt/hd6</span></span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line"><span class="comment"># umount /dev/hdc6</span></span><br><span class="line">-f ：强制卸除！可用在类似网络文件系统 <span class="params">(NFS)</span> 无法读取到的情况下；</span><br><span class="line">-n ：不升级 <span class="string">/etc/mtab</span> 情况卸除</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列出磁盘使用量df&quot;&gt;&lt;a href=&quot;#列出磁盘使用量df&quot; class=&quot;headerlink&quot; title=&quot;列出磁盘使用量df&quot;&gt;&lt;/a&gt;列出磁盘使用量df&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户管理</title>
    <link href="https://coderjeremy.github.io/2018/10/31/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://coderjeremy.github.io/2018/10/31/Linux用户管理/</id>
    <published>2018-10-31T04:24:19.000Z</published>
    <updated>2018-10-31T05:42:11.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统用户账号的管理"><a href="#系统用户账号的管理" class="headerlink" title="系统用户账号的管理"></a>系统用户账号的管理</h1><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> useradd &lt;选项&gt; 用户名  <span class="comment">#添加新的用户账号</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-c comment 指定一段用户注释性描述。<br>-d 目录，指定用户主目录，如果此目录不存在，则同时配合使用<br>-m 选项，可以自动创建主目录。<br>-g 用户组，指定用户所属的用户组（主组）。<br>-G 用户组，指定用户所属的附加组（可指定多个，当然并不建议太多个）。<br>-s Shell 文件，指定用户的登录 Shell。默认是 /bin/bash，注意 /bin/bash 不等于是 /bin/sh。<br>-u 用户号，指定用户的用户号，如果同时有<br>-o 选项，则可以重复使用其它用户的标识</p></blockquote><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> userdel 用户名<span class="comment">#删除用户</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> userdel -r 用户名 <span class="comment">#把用户的主目录一起删除</span></span></span><br></pre></td></tr></table></figure><h2 id="修改账号"><a href="#修改账号" class="headerlink" title="修改账号"></a>修改账号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> usermod &lt;选项&gt; 用户名 <span class="comment">#修改已有用户的信息</span></span></span><br></pre></td></tr></table></figure><h2 id="修改用户口令"><a href="#修改用户口令" class="headerlink" title="修改用户口令"></a>修改用户口令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># passwd <span class="meta-string">&lt;选项&gt; 用户名</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-l 锁定口令，即禁用账号。<br>-u 口令解锁。<br>-d 使账号无口令，即清除密码（设置空密码）<br>-f 强迫用户下次登录时修改口令</p></blockquote><h1 id="系统用户组的管理"><a href="#系统用户组的管理" class="headerlink" title="系统用户组的管理"></a>系统用户组的管理</h1><h2 id="增加用户组"><a href="#增加用户组" class="headerlink" title="增加用户组"></a>增加用户组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># groupadd <span class="meta-string">&lt;选项&gt; 用户组</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-g GID 指定新用户组的组标识号（GID）。<br>-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID相同。</p></blockquote><h2 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> groupdel 用户组</span></span><br></pre></td></tr></table></figure><h2 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># groupmod <span class="meta-string">&lt;选项&gt; 用户组</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-g GID 为用户组指定新的组标识号。<br>-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。<br>-n 新用户组，将用户组的名字改为新名字</p></blockquote><h2 id="切换用户组"><a href="#切换用户组" class="headerlink" title="切换用户组"></a>切换用户组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> newgrp 用户组</span></span><br></pre></td></tr></table></figure><h1 id="与用户账号有关的系统文件"><a href="#与用户账号有关的系统文件" class="headerlink" title="与用户账号有关的系统文件"></a>与用户账号有关的系统文件</h1><h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd</span></span><br><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 <span class="keyword">Shell</span><span class="bash"></span></span><br></pre></td></tr></table></figure><h2 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h2><p>/etc/shadow 中的记录行与 /etc/passwd 中的一一对应，它由 pwconv 命令根据/etc/passwd 中的数据自动产生。它的文件格式与 /etc/passwd 类似，由若干个字段组成，字段之间用”:”隔开。这些字<br>段是：<br><strong>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</strong></p><blockquote><p>“登录名”是与<code>/etc/passwd</code>文件中的登录名相一致的用户账号<br>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 <code>{ ./0-9A-Za-z }</code>中的字符，则对应的用户不能登录。<br>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。<br>“最小时间间隔”指的是两次修改口令之间所需的最小天数。<br>“最大时间间隔”指的是口令保持有效的最大天数。<br>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。<br>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。<br>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了</p></blockquote><h2 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h2><p>用户组的所有信息都存放在 /etc/group 文件中。此文件的格式也类似于 /etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：<br><strong> 组名:口令:组标识号:组内用户列表</strong></p><blockquote><p>“组名”是用户组的名称，由字母或数字构成。与 /etc/passwd 中的登录名一样，组名不应重复。<br>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。”组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。<br>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统用户账号的管理&quot;&gt;&lt;a href=&quot;#系统用户账号的管理&quot; class=&quot;headerlink&quot; title=&quot;系统用户账号的管理&quot;&gt;&lt;/a&gt;系统用户账号的管理&lt;/h1&gt;&lt;h2 id=&quot;添加用户&quot;&gt;&lt;a href=&quot;#添加用户&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件基本属性及权限设置</title>
    <link href="https://coderjeremy.github.io/2018/10/31/Linux%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"/>
    <id>https://coderjeremy.github.io/2018/10/31/Linux文件基本属性及权限设置/</id>
    <published>2018-10-31T02:29:56.000Z</published>
    <updated>2018-10-31T03:32:49.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h1><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[jeremy@localhost ~]$ ll</span><br><span class="line">total 0</span><br><span class="line">drwxrwxr-x.<span class="number"> 2 </span>jeremy jeremy<span class="number"> 110 </span>Oct<span class="number"> 17 </span>20:11 aaa</span><br><span class="line">drwxrwxr-x.<span class="number"> 3 </span>jeremy jeremy <span class="number"> 30 </span>Oct <span class="number"> 6 </span>20:43 bbb</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Desktop</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Documents</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Downloads</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Music</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Pictures</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Public</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Templates</span><br><span class="line">drwxr-xr-x.<span class="number"> 2 </span>jeremy jeremy  <span class="number"> 6 </span>Oct<span class="number"> 17 </span>16:27 Videos</span><br></pre></td></tr></table></figure><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p><blockquote><p>当为[ d ]则是目录<br>当为[ - ]则是文件；<br>若是[ l ]则表示为链接文件(link file)；<br>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置</p></blockquote><p>接下来的字符中，以三个为一组，且均为 “rwx” 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br><img src="/2018/10/31/Linux文件基本属性及权限设置/01.png"></p><blockquote><p>从左至右用 0-9 这些数字来表示。<br>第 0 位确定文件类型，<br>第 1-3 位确定文件属主（该文件的所有者）拥有该文件的权限。<br>第 4-6 位确定文件属组（所有者的同组用户）拥有该文件的权限，<br>第 7-9 位确定其他用户拥有该文件的权限。<br>其中，第 1、4、7 位表示读权限，如果用 “r” 字符表示，则有读权限，如果用 “-“ 字符表示，则没有读权限；<br>第 2、5、8 位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；<br>第 3、6、9 位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权</p></blockquote><h1 id="文件属主和属组"><a href="#文件属主和属组" class="headerlink" title="文件属主和属组"></a>文件属主和属组</h1><ul><li>属主 ：该文件具有所有权的用户，通常时文件的所有者是指创建此文件的用户，或者手动指定的拥有者</li><li>属组 ：Linux中，用户时按组分类的，一个用户可以属于一个或者多个组。文件所有者以外的用户，又可以分为文件所有者的同组用户和其它用户。root是顶级用户，可以无视权限，进行任何操作。</li></ul><h1 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h1><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chgrp [-R] 属组名 文件名  <span class="comment">#更改文件属组，前提是组已经存在</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-R : 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改</p></blockquote><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chown [-R] 属主名 文件名 <span class="comment">#更改文件属主</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown [-R] 属主名：属组名 文件名 <span class="comment">#更改文件属主，同时修改文件属组</span></span></span><br></pre></td></tr></table></figure><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>Linux 文件属性有两种设置方法，一种是数字，一种是符号。</p><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己read/write/execute 权限<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">r:</span><span class="number">4</span></span><br><span class="line"><span class="symbol">w:</span><span class="number">2</span></span><br><span class="line"><span class="symbol">x:</span><span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>每种身份（owner/group/others）<br>各自的三个权限（r/w/x）分数是需要累加的，</p><blockquote><p>例如当权限为： [-rwxrwx—] 分数则是：<br>owner = rwx = 4+2+1 = 7<br>group = rwx = 4+2+1 = 7<br>others= — = 0+0+0 = 0</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod [-R] xyz 文件或目录<span class="comment">#修改文件的9个属性</span></span></span><br></pre></td></tr></table></figure><blockquote><p>xyz ：为rwx属性数值的相加</p><ul><li>R ：进行递归recursive的持续变更，即连同次目录下的所有文件都会变更</li></ul></blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls ‐al .bashrc</span></span><br><span class="line">‐rw‐r‐‐r‐‐<span class="number"> 1 </span>root root<span class="number"> 395 </span>Jul<span class="number"> 4 </span>11:45 .bashrc</span><br><span class="line"><span class="comment"># chmod 777 .bashrc</span></span><br><span class="line"><span class="comment"># ls ‐al .bashrc</span></span><br><span class="line">‐rwxrwxrwx<span class="number"> 1 </span>root root<span class="number"> 395 </span>Jul<span class="number"> 4 </span>11:45 .bashrc</span><br></pre></td></tr></table></figure><h3 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h3><p>基本上就九个权限分别是(1)user (2)group (3)others三种身份，那么我们就可以藉由u，g，o来代表三种身份的权限。此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r，w，x。也就是可以使用底下的方式<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod [ugoa] +/-/= [rwx] 文件或目录</span></span><br><span class="line">+（加入）-(除去) =（设定）</span><br><span class="line">将文件权限设置为 -rwxr-xr-- </span><br><span class="line">可以使用 chmod <span class="attribute">u</span>=rwx,g=rx,o=r 文件名</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件基本属性&quot;&gt;&lt;a href=&quot;#文件基本属性&quot; class=&quot;headerlink&quot; title=&quot;文件基本属性&quot;&gt;&lt;/a&gt;文件基本属性&lt;/h1&gt;&lt;figure class=&quot;highlight tap&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件管理及操作</title>
    <link href="https://coderjeremy.github.io/2018/10/30/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
    <id>https://coderjeremy.github.io/2018/10/30/Linux文件管理及操作/</id>
    <published>2018-10-30T13:57:42.000Z</published>
    <updated>2018-10-30T15:09:13.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/bin：</span><br><span class="line">bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。实际上是链接到/usr/bin。</span><br><span class="line">/boot：</span><br><span class="line">这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">/dev ：</span><br><span class="line">dev 是 Device(设备)的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">/etc：</span><br><span class="line">这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">/home：</span><br><span class="line">用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">/lib：</span><br><span class="line">这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的DLL文件，几乎所有的应用程序都需要用到这些共享库。64 位系统还有一个</span><br><span class="line">lib64，这两个目录连接到 /usr下对应的lib目录。</span><br><span class="line">/lost+found：</span><br><span class="line">这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</span><br><span class="line">/media：</span><br><span class="line">linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</span><br><span class="line">/mnt：</span><br><span class="line">系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</span><br><span class="line">/opt：</span><br><span class="line">这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</span><br><span class="line">/proc：</span><br><span class="line">这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的<span class="built_in"> ping </span>命令，使别人无法<span class="built_in"> ping </span>你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">/root：</span><br><span class="line">该目录为系统管理员，也称作超级权限者的用户主目录（相当于普通用户的家目录）。</span><br><span class="line">/sbin：</span><br><span class="line">s 就是 Super<span class="built_in"> User </span>的意思，这里存放的是系统管理员使用的系统管理程序。实际上连接到 /usr/sbin</span><br><span class="line">/selinux：</span><br><span class="line">这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</span><br><span class="line">/srv：</span><br><span class="line">该目录存放一些服务启动之后需要提取的数据。</span><br><span class="line">/sys：</span><br><span class="line">这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</span><br><span class="line">/tmp：</span><br><span class="line">这个目录是用来存放一些临时文件的。</span><br><span class="line">/usr：</span><br><span class="line">这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</span><br><span class="line">/usr/bin：</span><br><span class="line">系统用户使用的应用程序。</span><br><span class="line">/usr/sbin：</span><br><span class="line">超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">/usr/src：</span><br><span class="line">内核源代码默认的放置目录。</span><br><span class="line">/var：</span><br><span class="line">这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br></pre></td></tr></table></figure><img src="/2018/10/30/Linux文件管理及操作/01.png"><p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <code>.</code> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点<code>..</code> 来表示。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. ：代表当前的目录，也可以使用 <span class="string">./</span> 来表示；</span><br><span class="line"><span class="string">..</span> ：代表上一层目录，也可以 <span class="string">../</span> 来代表。</span><br></pre></td></tr></table></figure></p><h1 id="文件、目录常用命令"><a href="#文件、目录常用命令" class="headerlink" title="文件、目录常用命令"></a>文件、目录常用命令</h1><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>路径的写法，由根目录<code>/</code>写起，例如：<code>/usr/share/doc</code>这个目录。</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>路径的写法，不是由<code>/</code>写起，例如由 <code>/usr/share/doc</code>要到<code>/usr/share/man</code>底下时，可以写成：<code>cd ../man</code>这就是相对路径的写法</p><h2 id="显示当前工作目录pwd"><a href="#显示当前工作目录pwd" class="headerlink" title="显示当前工作目录pwd"></a>显示当前工作目录pwd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span> <span class="comment">#Print Working Directory 显示当前所在目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span> -P <span class="comment">#显示出确实的路径，而非使用连接路径</span></span></span><br></pre></td></tr></table></figure><h2 id="列出目录ls"><a href="#列出目录ls" class="headerlink" title="列出目录ls"></a>列出目录ls</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls [‐aAdfFhilnrRSt] 目录名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls [‐‐color=&#123;never,auto,always&#125;] 目录名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls [‐‐full‐time] 目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来（常用）<br>-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）<br>-l ：以长格式列出，包含文件的属性与权限等等数据；(常用)<br>-i ：在第 1 列显示文件的 inode 节点号</p></blockquote><h2 id="切换目录cd"><a href="#切换目录cd" class="headerlink" title="切换目录cd"></a>切换目录cd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用 mkdir 命令创建 runoob 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir runoob</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用绝对路径切换到 runoob 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /root/runoob/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用相对路径切换到 runoob 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ./runoob/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure><h2 id="创建新目录mkdir"><a href="#创建新目录mkdir" class="headerlink" title="创建新目录mkdir"></a>创建新目录mkdir</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir [-mp] 目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色。<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来</p></blockquote><h2 id="删除空目录rmdir"><a href="#删除空目录rmdir" class="headerlink" title="删除空目录rmdir"></a>删除空目录rmdir</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rmdir [-p] 目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-p ：连同上一级的“空的”目录也一起删除</p></blockquote><h2 id="移除文件或目录rm"><a href="#移除文件或目录rm" class="headerlink" title="移除文件或目录rm"></a>移除文件或目录rm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm [-fir] 文件或目录</span></span><br></pre></td></tr></table></figure><blockquote><p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除，最常用的目录删除！这是非常危险的选项</p></blockquote><h2 id="复制文件或目录cp"><a href="#复制文件或目录cp" class="headerlink" title="复制文件或目录cp"></a>复制文件或目录cp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cp [‐adfilprsu] 来源档(<span class="built_in">source</span>) 目标档(destination)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure><blockquote><p>-a：相当于 ­pdr 的意思，至于 pdr 请参考下列说明；(常用)<br>-d：若来源文件为连接文件的属性(link file)，则复制连接文件而非文件本身；<br>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br>-l：进行硬连接(hard link)的文件创建，而非复制文件本身；<br>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br>-r：递归持续复制，用于目录的复制行为；(常用)<br>-s：复制成为符号连接 (symbolic link)，亦即『连接』文件；<br>-u：若 destination 比 source 旧才升级 destination</p></blockquote><h2 id="移动文件与目录，或修改名称mv"><a href="#移动文件与目录，或修改名称mv" class="headerlink" title="移动文件与目录，或修改名称mv"></a>移动文件与目录，或修改名称mv</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mv [‐fiu] <span class="built_in">source</span> destination</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure><blockquote><p>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</p></blockquote><h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat [-AbEnTv]  <span class="comment">#由第一行开始显示文件内容</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-A ：相当於 ­vET 的整合选项，可显示出一些特殊字符（如空白字符）；<br>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！<br>-E ：将结尾的断行字节 $ 显示出来；<br>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；<br>-T ：将 [tab] 按键以 ^I 显示出来；<br>-v ：列出一些看不出来的特殊字符</p></blockquote><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac 与 cat 命令刚好相反，文件内容从最后一行开始向前逐行显示，可以看出 tac 是cat 的倒写</p><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nl [-bnw] 文件 <span class="comment">#显示行号</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；<br>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；<br>-w ：行号栏位的占用的位数</p></blockquote><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页页翻动</p><blockquote><p>空白键 (space)：代表向下翻一页；<br>Enter ：代表向下翻『一行』<br>/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；<br>:f ：立刻显示出档名以及目前显示的行数；<br>q ：代表立刻离开 more ，不再显示该文件内容<br>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用</p></blockquote><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动</p><blockquote><p>空白键 ：向下翻动一页；<br>[pagedown]：向下翻动一页；<br>[pageup] ：向上翻动一页；<br>/字串 ：向下搜寻『字串』的功能；<br>?字串 ：向上搜寻『字串』的功能；<br>n ：重复前一个搜寻 (与 / 或 ? 有关！)<br>N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)<br>q ：离开 less 这个程序；</p></blockquote><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面的几行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> head [-n number] 文件</span></span><br></pre></td></tr></table></figure></p><blockquote><p>-n ：后面接数字，代表显示几行的意思</p></blockquote><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tail [-nf number] 文件</span></span><br></pre></td></tr></table></figure></p><blockquote><p>-n ：后面接数字，代表显示几行的意思<br>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-系统目录结构&quot;&gt;&lt;a href=&quot;#Linux-系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统目录结构&quot;&gt;&lt;/a&gt;Linux 系统目录结构&lt;/h1&gt;&lt;figure class=&quot;highlight routeros
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://coderjeremy.github.io/2018/10/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://coderjeremy.github.io/2018/10/30/Linux常用命令/</id>
    <published>2018-10-30T12:54:13.000Z</published>
    <updated>2018-10-30T13:51:14.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> clear<span class="comment">#清空当前终端命令历史记录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span><span class="comment">#退出终端</span></span></span><br></pre></td></tr></table></figure><h1 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> reboot<span class="comment">#重启</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown -r now<span class="comment">#重启。等同reboot</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown -h now<span class="comment">#关机，慎用，通常情况远程服务器关机后，物理机无法重启</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> halt<span class="comment">#关机，慎用</span></span></span><br></pre></td></tr></table></figure><h1 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> &lt;directory&gt;<span class="comment">#切换到指定目录下，参数可使用通配符，按下 tab 键可自动补足，连按两下 tab 键，则会将所有相关文件列出。directory 既可是绝对路径，也可是相对路径，./ 表示当前路径，../ 表示上一级路径，下同。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls &lt;directory&gt;<span class="comment">#列出指定目录下所有文件，如无参数，则列出当前目录下所有文件。directory 既可是绝对路径，也可是相对路径。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -l<span class="comment">#以长格式形式列出所有文件，可简写为 ll。长格式规则：第1列：1位文件类型，9位权限标志。第2列：文件索引节点编号，第3列：文件所有者名称，第4列：文件属主所在组名称，第5列：文件大小，第6列：文件最后修改日期，第7列：文件名称。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -a <span class="comment">#列出所有文件，包括隐藏文件。在 Linux 中，隐藏文件的文件名以 “.”开头。另外，命令参数若有多个可以合写，如ls ‐la。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp &lt;<span class="built_in">source</span>&gt; &lt;target&gt;<span class="comment">#将 source 文件复制到 target 位置。source和 target 既可是绝对路径，也可是相对路径，支持通配符，下同。第二个参数是目录的话，表示将文件复制到指定目录下，第二个参数如果是文件名称的话，表示将源文件复制成参数2指定的新文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp -r &lt;<span class="built_in">source</span>&gt; &lt;target&gt; <span class="comment">#递归复制，‐f 参数表示静默操作，无提示。有时 ‐f 可能会失效，详细原因见最后附录部分。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv &lt;<span class="built_in">source</span>&gt; &lt;target&gt;<span class="comment">#移动 source 文件到 target 位置，相当于剪切，重命名也是使用此命令。‐f 参数表示静默操作，无警告提示。mv 没有 ‐r参数。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm &lt;<span class="built_in">source</span>&gt;<span class="comment">#删除文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm -r &lt;<span class="built_in">source</span>&gt;<span class="comment">#递归删除，-f 参数表示静默操作，无警告提示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir &lt;directory&gt; <span class="comment">#创建目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p &lt;directory&gt;<span class="comment">#递归操作</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rmdir<span class="comment">#删除空目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> man  &lt;命令&gt; <span class="comment">#查看命令帮助文档或使用说明，按q 退出说明</span></span></span><br></pre></td></tr></table></figure><h1 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ll /etc/centos* <span class="comment"># ll 命令等同于ls ‐l</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ll /etc/centos‐release <span class="comment">#按 tab 键可自动补足</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/centos‐release <span class="comment">#cat 命令是直接在终端中显示</span></span></span><br></pre></td></tr></table></figure><h1 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname ‐r <span class="comment">#显示内核版本</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uname ‐m <span class="comment">#查看系统位数</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uname ‐a <span class="comment">#显示更全面的信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> arch <span class="comment">#与 uname ‐m 命令非常类似。如果输出 x86_64 则表示为 64 位系统，如果输出i686 或 i386 则表示为 32 位系统</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> getconf LONG_BIT<span class="comment">#查看系统位数</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$LANG</span> <span class="comment">#查看语言与本地化</span></span></span><br></pre></td></tr></table></figure><h1 id="查看网络及网卡状态"><a href="#查看网络及网卡状态" class="headerlink" title="查看网络及网卡状态"></a>查看网络及网卡状态</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig<span class="comment">#查看网络及网卡状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli dev show <span class="comment">#检查网卡状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli device show <span class="comment">#与之上命令效果等同</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli <span class="comment">#以简单模式显示网卡状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli con up ens33 <span class="comment">#最后一个参数是网卡名称，执行此命令后，将会激活连接此网卡</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli con down ens33 <span class="comment">#表示断开此网卡</span></span></span><br></pre></td></tr></table></figure><h1 id="查看当前系统用户"><a href="#查看当前系统用户" class="headerlink" title="查看当前系统用户"></a>查看当前系统用户</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> whoami <span class="comment">#查看当前系统操作用户身份，本指令等同于执行 id -un 指令 </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> id -un<span class="comment">#查看当前系统操作用户的身份</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> who am i <span class="comment">#查看当前系统登录用户，注意：是登录 id</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> who ‐m <span class="comment">#等同于 who am i</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> who <span class="comment">#显示系统当前登录的所有用户</span></span></span><br></pre></td></tr></table></figure><h1 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> su snow <span class="comment">#切换到普通snow 账户</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> su root <span class="comment">#切换到 root 账户，切换后相对路径与当前路径一致</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> su <span class="comment">#等同于上一条</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> su ‐ <span class="comment">#切换到 root 账户，切换后相对路径为 ~ ，即家目录。同时会显示最后一次登录时间。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span> <span class="comment">#退出当前的临时切换账户状态</span></span></span><br></pre></td></tr></table></figure><h1 id="CentOS-7-5-系统配置国内-yum-源和-epel"><a href="#CentOS-7-5-系统配置国内-yum-源和-epel" class="headerlink" title="CentOS 7.5 系统配置国内 yum 源和 epel"></a>CentOS 7.5 系统配置国内 yum 源和 epel</h1><ol><li>首先进入 <code>/etc/yum.repos.d/</code>目录下，新建一个 <code>repo_bak.d</code>目录，用于保存<br>系统中原来的 repo 文件 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /etc/yum.repos.d/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir repo_bak.d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv *.repo repo_bak.d/</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 CentOS 中配置使用网易和阿里的开源镜像<br>点击右上角的网络管理器，连接网络。因为 CentOS 默认是不自动连接网络的。首选使用 su ‐ 命令切换到 root 用户。否则某些操作是无法完成的，需要 root 权限到网易和阿里开源镜像站点下载系统对应版本的 repo</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> yum.repos.d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.aliyun.com/repo/Centos‐7.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.163.com/.<span class="built_in">help</span>/CentOS7‐Base‐163.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">Centos‐7.repo CentOS‐Base‐163.repo repo.bak</span><br></pre></td></tr></table></figure><p>或者手动下载 repo 文件并上传到<code>/etc/yum.repos.d/</code></p><ol start="3"><li>清除系统 yum 缓存并生成新的 yum </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum clean all</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum update <span class="comment">#更新软件</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>安装 epel 源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum ‐y install epel‐release</span></span><br></pre></td></tr></table></figure><h1 id="安装压缩、解压缩工具"><a href="#安装压缩、解压缩工具" class="headerlink" title="安装压缩、解压缩工具"></a>安装压缩、解压缩工具</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install zip unzip gzip p7zip <span class="comment">#安装压缩与解压缩工具</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum remove zip unzip gzip p7zip <span class="comment">#卸载压缩与解压缩工具</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum unzip -0 cp936 xxx.zip<span class="comment">#解决使用unzip命令时中文乱码的问题</span></span></span><br></pre></td></tr></table></figure><h1 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install ibus ibus-<span class="keyword">table</span>-wubi*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;终端&quot;&gt;&lt;a href=&quot;#终端&quot; class=&quot;headerlink&quot; title=&quot;终端&quot;&gt;&lt;/a&gt;终端&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux修改密码</title>
    <link href="https://coderjeremy.github.io/2018/10/30/Linux%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <id>https://coderjeremy.github.io/2018/10/30/Linux修改密码/</id>
    <published>2018-10-30T12:26:52.000Z</published>
    <updated>2018-10-30T12:33:27.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改-重置普通用户密码"><a href="#修改-重置普通用户密码" class="headerlink" title="修改/重置普通用户密码"></a>修改/重置普通用户密码</h1><ol><li><code>passwd</code> #用于当前操作用户自行修改密码。注意：修改密码时，需要输入当前操作用户的当前密码。root 用户也可使用此命令修改自行修改密码。</li><li><code>passwd &lt;用户名&gt;</code> #此命令只能由 root 用户执行，当前用户是 root时，可更改任意其它用户的密码</li></ol><h1 id="修改-重置-root-用户密码"><a href="#修改-重置-root-用户密码" class="headerlink" title="修改/重置 root 用户密码"></a>修改/重置 root 用户密码</h1><h2 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h2><p>如果 root 用户密码忘记，需要重置 root 密码的话。可按如下步骤操作（前提，有条可以操作物理机开机重启）：</p><h3 id="第一种方法-："><a href="#第一种方法-：" class="headerlink" title="第一种方法 ："></a>第一种方法 ：</h3><ul><li>开机，随意按一个键，进入开机项选择状态，否则 5 秒钟后系统默认选择第一项自动启动。按方向键选中第一项，按 e 进入编辑状态。事实上，选择其它项也可以，只不过，第一项是默认开机项，一般是最新的内核启动</li></ul><img src="/2018/10/30/Linux修改密码/01.png"><ul><li>进入编辑模式后。注意，显示的内容有可能并不是全部的内容，可以按方向键上下来查看更多内容</li></ul><img src="/2018/10/30/Linux修改密码/02.png"><ul><li>按方向键下，一直到内容的尾部。找到 linux16 这一行，将 ro 更改成<code>rw init=/sysroot/bin/sh</code>，按 ctrl + x 启动。注意：修改属临时修改，仅本次生效，重启电脑，又会恢复到原来的内容</li></ul><img src="/2018/10/30/Linux修改密码/03.png"><ul><li>启动后，进入单用户纯文本命令模式，注意：命令提示符是<code>:/#</code></li><li>使用指令<code>chroot /sysroot</code>切换根目录。经测试，此句之前无须执行挂载指令<code>mount ‐o remount,rw /sysroot</code></li><li>使用指令 <code>passwd root</code> ，来重置 root 用户的密码。由于本机安装了中文语言包，而当前文本命令模式不支持中文，所以修改密码时的提示，全部显示成了方块。如果未安装中文语言包的话，提示应该是英文的。不过操作很简单，就是输入两次密码，正确输入即可。<br>注意1：不要输入过于简单的密码。注意2：更改<code>LANG=en_US.UTF-8</code>，依然是中文提示，且中文仍然会显示成方块。</li><li>使用<code>touch /.autorelabel</code>命令，会在 / 目录下创建一个 .autorelabel 文件，有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling。</li><li>使用命令 exit 退出 chroot 状态，使用命令 reboot 重启，使用 root 新密码登录。如果使用 reboot 不能重启，可以加入 -f 参数， <code>reboot ‐f</code> 强制重启。</li></ul><img src="/2018/10/30/Linux修改密码/04.png"><ul><li>重启后，进入以下状态</li></ul><img src="/2018/10/30/Linux修改密码/05.png"><ul><li>等待一会，系统会再次重启。正常进入系统。</li></ul><h3 id="第二种方法-："><a href="#第二种方法-：" class="headerlink" title="第二种方法 ："></a>第二种方法 ：</h3><ul><li>同样是开机时，按 e 进入编辑状态。将 ro 更改为 rw ，将 LANG=zh_CN.UTF-8 更改为 LANG=en_US.UTF-8，并在末尾追加空格，init=/bin/sh，注意：一定是在末尾添加。</li></ul><img src="/2018/10/30/Linux修改密码/06.png"><ul><li>按 Ctrl + x 启动。启动后如下</li></ul><img src="/2018/10/30/Linux修改密码/07.png"><ul><li><p>执行如下指令，修改密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> passwd root</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /.autorelabel <span class="comment">#注意文件名称</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> /sbin/init <span class="comment">#重启即可</span></span></span><br></pre></td></tr></table></figure></li><li><p>注意：此种方式，修改 LANG=en_US.UTF-8，是可以显示英文的。注意：本方法命令行前缀是<code>sh‐4.2#</code></p></li></ul><img src="/2018/10/30/Linux修改密码/08.png"><ul><li>启动后进入以下状态</li></ul><img src="/2018/10/30/Linux修改密码/09.png"><h3 id="第三种方法："><a href="#第三种方法：" class="headerlink" title="第三种方法："></a>第三种方法：</h3><ul><li>按 e 编辑，添加<code>rd.break</code></li></ul><img src="/2018/10/30/Linux修改密码/10.png"><ul><li>启动后，如下状态：注意命令前缀<code>switch_root</code>，这是固定不变（不因不同的机器而变）的</li></ul><ul><li>依次输入以下指令，与第一种方法相同。注意指令前缀的变化<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount ‐o remount,rw /sysroot <span class="comment">#如果不加这一句，是没有效果的。但第一种方法经测试，无须加此句。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chroot /sysroot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> passwd root</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /.autorelabel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot <span class="comment">#重启</span></span></span><br></pre></td></tr></table></figure></li></ul><img src="/2018/10/30/Linux修改密码/12.png"><ul><li>两次重启后就会生效。注意：CentOS 6.x 版本和 7.x 版本，重置 root 密码的方法是不一样的。具体方法可查询网络。重置 root 用户密码是 Redhat RHCE 认证考试必须先完成的第一步操作，很明显，意味着这是最简单的必备技能。第二种方法相对简单一些。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修改-重置普通用户密码&quot;&gt;&lt;a href=&quot;#修改-重置普通用户密码&quot; class=&quot;headerlink&quot; title=&quot;修改/重置普通用户密码&quot;&gt;&lt;/a&gt;修改/重置普通用户密码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;passwd&lt;/code&gt; #用于当前操作用
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="Linxu" scheme="https://coderjeremy.github.io/tags/Linxu/"/>
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
  </entry>
  
  <entry>
    <title>说点心情</title>
    <link href="https://coderjeremy.github.io/2018/10/24/1024%E8%AF%B4%E7%82%B9/"/>
    <id>https://coderjeremy.github.io/2018/10/24/1024说点/</id>
    <published>2018-10-24T06:09:43.000Z</published>
    <updated>2018-10-24T06:29:00.411Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>还有人知道今天给我过节<br><br>很开心有人记得我<br><br><img src="/2018/10/24/1024说点/1024.jpg"><br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;还有人知道今天给我过节&lt;br&gt;&lt;br&gt;很开心有人记得我&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/2018/10/24/1024说点/1024.jpg&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="闲聊" scheme="https://coderjeremy.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="心情" scheme="https://coderjeremy.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Quicksort快速排序算法</title>
    <link href="https://coderjeremy.github.io/2018/10/09/Quicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://coderjeremy.github.io/2018/10/09/Quicksort快速排序算法/</id>
    <published>2018-10-09T12:04:05.000Z</published>
    <updated>2018-10-09T13:44:07.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><p>思想：二分法，分治法，递归</p><p>排序实例<br>6    1    2    7    9    3    4    5    10    8<br>6为基准，也就是temp<br>先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。</p><blockquote><p>如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它</p></blockquote><p>找到7 和 5<br>6     1    2    <strong>7</strong>    9    3    4    <strong>5</strong>    10    8</p><hr><p>交换后得到<br>6    1    2    <strong>5</strong>    9    3    4    <strong>7</strong>    10    8</p><hr><p>依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下<br>6    1    2    5    4    <strong>3</strong>    9    7    10    8</p><hr><p>此时交换基准数与<strong>3</strong><br><strong>3</strong>    1    2    5    4    <strong>6</strong>    9    7    10    8</p><hr><p>这样就保证了基准数6左边都比他小，右边都比他大<br>这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序<br>也就是进行递归排序算法，最终就得到排序结果<br>1    2    3    4    5    6    7    8    9    10</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">int</span> temp = a[left];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= temp)<span class="comment">//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp</span></span><br><span class="line">j--;<span class="comment">//从右向左找第一个小于x的数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= temp)<span class="comment">//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp</span></span><br><span class="line">i++;<span class="comment">//从左向右找第一个大于x的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将基准数归位</span></span><br><span class="line">a[left] = a[i];</span><br><span class="line">a[i] = temp;</span><br><span class="line">QuickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">QuickSort(a, i + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试用例：</p><p>Input:<br>11<br>3 4 5 1 34 61 22 41 111 2 87</p><p>Output:<br>1 2 3 4 5 22 34 41 61 87 111</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序算法&quot;&gt;&lt;a href=&quot;#快速排序算法&quot; class=&quot;headerlink&quot; title=&quot;快速排序算法&quot;&gt;&lt;/a&gt;快速排序算法&lt;/h1&gt;&lt;p&gt;思想：二分法，分治法，递归&lt;/p&gt;
&lt;p&gt;排序实例&lt;br&gt;6    1    2    7    9    
      
    
    </summary>
    
      <category term="算法" scheme="https://coderjeremy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://coderjeremy.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="QuickSort" scheme="https://coderjeremy.github.io/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络物理层</title>
    <link href="https://coderjeremy.github.io/2018/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://coderjeremy.github.io/2018/09/25/计算机网络物理层/</id>
    <published>2018-09-25T07:56:16.000Z</published>
    <updated>2018-10-23T12:53:59.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h1><p>确定与传输媒体的接口有关的一些特性：</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><p>传输方式的转换</p><ul><li>数据在计算机中多采用<strong><em> 并行传输 </em></strong> 方式</li><li>数据在通信线路上的传输方式一般是<strong><em> 串行传输 </em></strong></li></ul><h1 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h1><h2 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h2><img src="/2018/09/25/计算机网络物理层/数据通信系统的模型.png" title="数据通信系统的模型"><h2 id="数据通信基本概念"><a href="#数据通信基本概念" class="headerlink" title="数据通信基本概念"></a>数据通信基本概念</h2><ul><li>模拟信号（连续信号） ：一般是正弦或余弦波形</li><li><p>数字信号（离散信号）：脉冲信号</p><blockquote><p>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote></li><li><p>模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声</p></li><li>数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积<h2 id="信道及其极限容量"><a href="#信道及其极限容量" class="headerlink" title="信道及其极限容量"></a>信道及其极限容量</h2></li><li>信道：数据传输的通道<ul><li>单向通信：单工，单向传输</li><li>双向交替通信：半双工，一方发，一方收，不能同时</li><li>双向同时通信：全双工，同时发送和接收信息，需要两条信道</li></ul></li><li>信道参数<ul><li>数据传输速率 = 带宽</li><li>载波频率：信道对应的频率</li><li>采样频率：模拟信号转化为数字信号时采样的速率</li><li>量化：对采样信号的数字化</li><li>噪声、信噪比：<strong> 信噪比（dB）= 10log<sub>10</sub>(S/N)（dB）</strong></li></ul></li></ul><blockquote><p><strong><em>Nyquist定理</em></strong>——计算机通信的基本定理<br>比特率 = log<sub>2</sub>V波特率<br>在无噪信道中，当带宽为H Hz，信号电平为V级：<br><strong> 数据传输速率 = 2Hlog<sub>2</sub>V (b/s) </strong><br>V：信号电平的级数，在二进制中，仅为0、1两级<br>采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复</p><blockquote><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题<br>如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰</p></blockquote></blockquote><blockquote><p><strong><em>香农（Shannon)定理：</em></strong><br>在噪声信道中，当带宽为H Hz，信噪比为 S/N ：<br><strong>最大数据传输速率（b/s）= Hlog<sub>2</sub>（1+S/N）</strong></p><blockquote><p>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高<br>只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输<br>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法<strong>让每一个码元携带更多比特的信息量</strong></p></blockquote></blockquote><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>基带传输：<br>​    - 基带信号：信号源产生的原始电信号，也叫基本频带信号<br>​    - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制<br>宽带传输<br>​    - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输<br>​    - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段<br>​    - 宽带传输：多个频带的带通信号在同一个物理媒体上传输<br>​    </p><ul><li><p><strong>数字数据在模拟信道上传输：数字信号——&gt;模拟信号</strong></p><ul><li>将数字数据调制成模拟信号进行传输，把0、1用波形表示</li><li>通常有三种基本的调制方式<ul><li>调幅ASK：用载波的两种不同的振幅来表示两个二进制</li><li>调频FSK：用载波附近的两种不同的频率来表示两个二级制</li><li>调相PSK：用载波的相位移动来表示两个二进制</li></ul></li><li>正交调相QPSK</li><li>正交调幅QAM</li></ul></li><li><p><strong>数字数据的数字信号传输</strong></p><ul><li>数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题</li><li>常用的数字信号编码方式：<ul><li>不归零编码NRZ</li><li>曼切斯特编码——自同步编码方式</li><li>差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1</li></ul></li><li>编码方式的比较：<ul><li>不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟</li><li>曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟</li><li>差分曼切斯特编码与曼切斯特编码基本相同</li></ul></li></ul></li><li><p><strong>模拟数据在数字信道上传输</strong></p><ul><li>模拟数据变成数字数据在数字信道上传递</li><li>采用脉冲编码调制（PCM–Pulse Code Modulation）技术</li><li>关键点：在接收端还原成模拟数据</li><li>PCM以Nyquist采样定理为基础<blockquote><p>采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息</p></blockquote></li></ul></li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><p>Frequency Division Multiplexing<br>前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和<br>频分复用的所有用户再同样的时间占用不同的带宽资源</p><h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><p>Time Division Multiplexing<br>每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输<br>​    - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。<br>​    - 每一个用户所占用的时隙是周期性地出现<br>​    - TDM信号也称为等时信号<br>​    - 时分复用地所有用户是在不同的时间占用同样的频带宽度</p><img src="/2018/09/25/计算机网络物理层/时分复用.png" title="时分复用"><p>TDM的同步和异步：<br>​    - 同步TDM:<br>​        - 时间片与输入装置一一对应，同步<br>​        - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲<br>​        - 传输介质的传输速率不能低于各个输入信号的数据速率之和<br>​        - 同步TDM可能会造成线路资源的浪费<br><img src="/2018/09/25/计算机网络物理层/同步TDM.png" title="同步TDM"><br>​    - 异步TDM<br>​        - 时间片是按需动态分配的<br>​        - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号<br>​        - 在传输的数据单元中必须包含地址信息，以便寻址目的节点<br>​        - 传输介质的传输速率只要不低于各个输入信号的平均速率即可<br>​        - 异步TDM又称<strong>统计TDM(STDM)</strong></p><img src="/2018/09/25/计算机网络物理层/异步TDM.png" title="异步TDM"><h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><p>Wavelength Division Multiplexing<br>光的频分复用</p><h3 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h3><p>Code Division Multiplexing</p><h4 id="码分多址（Code-Division-Multiple-Access）"><a href="#码分多址（Code-Division-Multiple-Access）" class="headerlink" title="码分多址（Code Division Multiple Access）"></a>码分多址（Code Division Multiple Access）</h4><ul><li>每个用户可以CDMA在同样的时间使用同样的频带进行通信</li><li>抗干扰强，频谱类似白噪声，不易被发现</li><li>采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等</li></ul><h4 id="码片序列（chip-sequence）"><a href="#码片序列（chip-sequence）" class="headerlink" title="码片序列（chip sequence）"></a>码片序列（chip sequence）</h4><ul><li>每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。<br>  通常m取值为64或128（在后面的原理性说明中，取为8）</li><li>每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。<br>  如发送比特 1，则发送自己的 m bit 码片序列。<br>  如发送比特 0，则发送该码片序列的二进制反码。<br>  例如，S 站的 8 bit 码片序列是 00011011。<br>  发送比特 1 时，就发送序列 00011011，<br>  发送比特 0 时，就发送序列 11100100。<br>  为了方便，将码片0写为–1 ，将1写为+1<br>  S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</li><li>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。<br>在实用的系统中是使用伪随机码序列。</li></ul><h4 id="码片序列的正交关系"><a href="#码片序列的正交关系" class="headerlink" title="码片序列的正交关系"></a>码片序列的正交关系</h4><ul><li>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 </li><li>两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0<img src="/2018/09/25/计算机网络物理层/码片正交.png" title="码片正交"></li></ul><img src="/2018/09/25/计算机网络物理层/码片规格化.png" title="码片规格化"><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>物理媒体中间设备传递数据的技术</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接</li><li>一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址<ul><li>服务质量好</li><li>线路的利用率较低</li><li>建立连接时间长，因连接建立时冲突概率高 </li></ul></li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul><li>无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站</li><li>数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制<ul><li>线路的利用率较高</li><li>由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞</li><li>每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时）</li></ul></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li>与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文<br>  可以为分组在内存预留空间</li><li>每个分组中必须包含目的地址，并采用存储-转发机制<ul><li>线路的利用率较高</li><li>由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计</li><li>每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置<br>存储转发的速度较报文交换高</li><li>接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文</li></ul></li></ul><h3 id="虚电路交换"><a href="#虚电路交换" class="headerlink" title="虚电路交换"></a>虚电路交换</h3><ul><li>将电路交换的概念引入到分组交换<ul><li>信息传递依然采用分组（定义最大分组长度）</li><li>引入电路交换的连接建立过程</li><li>找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点</li><li>发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;物理层的主要任务&quot;&gt;&lt;a href=&quot;#物理层的主要任务&quot; class=&quot;headerlink&quot; title=&quot;物理层的主要任务&quot;&gt;&lt;/a&gt;物理层的主要任务&lt;/h1&gt;&lt;p&gt;确定与传输媒体的接口有关的一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机械特性&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://coderjeremy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="https://coderjeremy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="物理层" scheme="https://coderjeremy.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://coderjeremy.github.io/2018/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://coderjeremy.github.io/2018/09/18/计算机网络概述/</id>
    <published>2018-09-18T13:30:01.000Z</published>
    <updated>2018-09-25T08:07:50.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><h3 id="第一阶段：从单个网络ARPANET向互联网发展的过程"><a href="#第一阶段：从单个网络ARPANET向互联网发展的过程" class="headerlink" title="第一阶段：从单个网络ARPANET向互联网发展的过程"></a>第一阶段：从单个网络ARPANET向互联网发展的过程</h3><p>ARPANET：</p><ul><li>1969年美国国防部创建的第一个分组交换网</li><li>1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生</li><li>1990年关闭<h3 id="第二阶段：三级结构的因特网"><a href="#第二阶段：三级结构的因特网" class="headerlink" title="第二阶段：三级结构的因特网"></a>第二阶段：三级结构的因特网</h3>1985年美国国家科学基金会：NSFNET<br>三级计算机网络：</li></ul><ul><li>主干网</li><li>地区网</li><li>校园网（或企业网）<h3 id="第三阶段：多层次ISP结构因特网"><a href="#第三阶段：多层次ISP结构因特网" class="headerlink" title="第三阶段：多层次ISP结构因特网"></a>第三阶段：多层次ISP结构因特网</h3></li><li>第一层：服务面积最大(一般是国家范围)，拥有高速主干网</li><li>NAP </li><li>第二层：第一层ISP的用户</li><li>第三层：又称本地ISP，拥有本地范围的网络<blockquote><p>ISP: (Internet Service Provider) 互联网服务提供者（商）<br>NAP:网络接入点<strong>NAP</strong> (Network Access Point)：分散主干网流量，又称对等点（peering point）<br>IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组</p></blockquote></li></ul><h2 id="英特网的组成"><a href="#英特网的组成" class="headerlink" title="英特网的组成"></a>英特网的组成</h2><p>因特网的<strong>边缘部分</strong>：由所有连接在因特网上的<strong>主机</strong>组成（通信和资源共享）<br>因特网的<strong>核心部分</strong>：由大量网络和连接这些网络的<strong>路由器（router）</strong>组成，为边缘部分提供服务（连通性和交换）</p><blockquote><p>另一种分法：资源子网，通信子网</p></blockquote><hr><h3 id="边缘部分通信方式："><a href="#边缘部分通信方式：" class="headerlink" title="边缘部分通信方式："></a>边缘部分通信方式：</h3><ol><li>客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程</li></ol><ul><li>客户程序特点：<ul><li>客户程序必须知道服务器程序的地址</li><li>不需要特殊的硬件和复杂的操作系统</li></ul></li><li>服务程序特点：<ul><li>可同时处理多个远地或本地客户的请求</li><li>系统启动后自动调用并一直不断的运行着</li><li>一般需要强大的硬件和高级的操作系统支持</li></ul></li></ul><ol start="2"><li>对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器</li></ol><h3 id="核心部分三种交换方式："><a href="#核心部分三种交换方式：" class="headerlink" title="核心部分三种交换方式："></a>核心部分三种交换方式：</h3><blockquote><p>路由器：实现分组交换的关键构建，转发收到的分组<br>交换（switching）按照某种方式动态地分配传输线路的资源</p><ol><li>电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放<br> 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源<ul><li>通话前先拨号建立连接（经过一个或多个交换机）</li><li>通话过程中，通信双方一直占用所建立的连接</li><li>通话结束后，挂机释放连接</li></ul></li></ol></blockquote><ol start="2"><li><p>报文交换</p></li><li><p>分组交换</p><ul><li>在发送端，先把较长的报文划分成较短的固定长度的数据端</li><li>每一个数据段前面添加上首部构成分组</li><li>依次把各分组发送到接收端</li><li><p>接收端剥去首部，抽出数据部分，还原成报文</p><blockquote><p>每一个分组的首部都含有地址等控制信息<br>结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机</p></blockquote><p>路由器处理分组的过程：</p></li><li>把收到的分组先放入缓存；</li><li>查找转发表，找出到某个目的地址应从哪个端口转发；</li><li><p>把分组送到适当的端口转发出去</p><p>优点：</p></li><li>高效    动态分配传输带宽，对通信链路是逐段占用。 </li><li>灵活    以分组为传送单位和查找路由。</li><li>迅速    不必先建立连接就能向其他主机发送分组。</li><li><p>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。   </p><p>缺点：</p></li><li>分组在各结点存储转发时需要排队，这就会造成一定的时延。</li><li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</li></ul></li></ol><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>1.按照网络的作用分类：<br>​    - 广域网WAN（Wide Area Network）<br>​    - 城域网MAN (Metropolitan Area Network)<br>​    - 局域网LAN (Local Area Network)<br>​    - 个人区域网PAN (Personal Area Network)<br>2.按照网络的使用者分类：<br>​    - 公用网（public network）<br>​    - 专用网 (private network)<br>3.原来把用户接入到互联网的网络：接入网 AN(Access Network)</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol><li>速率<br> 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒）</li><li>带宽<ul><li>某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ</li><li>计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s</li></ul></li><li>吞吐量<br> 表示在单位时间内通过某个网络（或信道、接口）的实际数据量</li><li><p>时延</p><ul><li><p>发送时延<br>主机或路由器发送数据帧所需要的时间<br>​    发送时延 = 数据帧长度 / 发送速率</p></li><li><p>传播时延<br>电磁波在信道中传播一定的距离需要花费的时间<br>​    传播时延  = 信道长度  /  电磁波在信道上的传播速率</p></li><li><p>处理时延<br>主机或路由器在收到分组时需要花费时间处理</p></li><li><p>排队时延<br>分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理</p><blockquote><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></blockquote></li></ul></li><li><p>时延带宽积<br> 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度）</p></li><li>往返时间RTT（Round-Trip Time）<br> 发送时长 = 数据长度 / 发送速率<br> 有效数据率 = 数据长度 / （发送时间 + RTT）</li><li>利用率<br> 信道利用率和网络利用率，过高会产生非常大的时延</li></ol><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h3><ol><li>实体：<ul><li>表示任何可发送或接收信息的硬件或软件进程</li><li>对等实体peer entity</li></ul></li><li>协议（protocol）：<ul><li>控制两个对等实体进行通信的规则、标准或约定的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</li><li>网络协议的组成要素<ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul></li></ul></li><li><p>协议与服务：</p><ul><li>本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的</li><li>协议是”水平的“，协议是控制对等实体之间通信的规则</li><li>服务是”垂直的“，服务是由下层向上层通过层间接口提供的<blockquote><p>并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务<br>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语</p></blockquote></li></ul></li><li><p>服务访问点 SAP（Service Access Point）：</p><ul><li>同一系统相邻两层实体进行交互的地方称为SAP</li><li>服务数据单元SDU(Service Data Unit)</li></ul></li></ol><h3 id="OSI-RM体系结构"><a href="#OSI-RM体系结构" class="headerlink" title="OSI/RM体系结构"></a>OSI/RM体系结构</h3><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">第七层</td><td style="text-align:center">应用层(applicationg layer)</td><td style="text-align:left">约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致</td></tr><tr><td style="text-align:center">第六层</td><td style="text-align:center">表示层(presentation layer)</td><td style="text-align:left">表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义</td></tr><tr><td style="text-align:center">第五层</td><td style="text-align:center">会话层(session layer)</td><td style="text-align:left">建立有关会话的机制，是双向的还是单向对话或重新建立会话</td></tr><tr><td style="text-align:center">第四层</td><td style="text-align:center">传输层(transport layer)</td><td style="text-align:left">提供端到端的通路，应用到应用的通路</td></tr><tr><td style="text-align:center">第三层</td><td style="text-align:center">网络层(network layer)</td><td style="text-align:left">提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括<br>- 选择路由<br>- 拥塞控制<br>- 协议的转换<br>- 分段和重组<br>- 对用户的分组、字符等统计</td></tr><tr><td style="text-align:center">第二层</td><td style="text-align:center">数据连路层(data link layer)</td><td style="text-align:left">提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收<br>- 识别帧的标志<br>- 帧的发送和接收，需校验、确认<br>- 发送方在超时或收到否定性确认后，要重发<br>- 重复帧要丢弃<br>在共享网络中，需解决信道共享问题等——mac层</td></tr><tr><td style="text-align:center">第一层</td><td style="text-align:center">物理层(physical layer)</td><td style="text-align:left">与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换</td></tr></tbody></table><blockquote><p>会话层及以下关心的是信息的传输<br>表示层及以上关心的是信息的理解</p></blockquote><h3 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a>TCP/IP的体系结构</h3><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">第五层</td><td style="text-align:center">应用层</td><td style="text-align:left">通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等</td></tr><tr><td style="text-align:center">第四层</td><td style="text-align:center">传输层</td><td style="text-align:left">负责向两台主机中进程之间的通信提供通用的数据传输服务<br>TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付<br>UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付</td></tr><tr><td style="text-align:center">第三层</td><td style="text-align:center">网络层</td><td style="text-align:left">为分组交换网上的不同主机提供通信服务<br>把传输层产生的报文段或用户数据报封装成分组或包进行传送<br>选择合适路由<br>网际协议IP和多路由选择协议</td></tr><tr><td style="text-align:center">第二层</td><td style="text-align:center">数据链路层</td><td style="text-align:left">将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息</td></tr><tr><td style="text-align:center">第一层</td><td style="text-align:center">物理层</td><td style="text-align:left">透明的传送比特流</td></tr></tbody></table><blockquote><p>传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层</p></blockquote><h3 id="数据传递过程"><a href="#数据传递过程" class="headerlink" title="数据传递过程"></a>数据传递过程</h3><blockquote><p>PDU(Protocol Data Unit)：对等层次间传送的数据单位</p></blockquote><p>主机1</p><ol start="5"><li>应用进程数据先传送到应用层,加上应用层首部，称为PDU</li><li>应用层PDU再传送到传输层，加上传输层首部，成为传输层报文</li><li>传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组</li><li>IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧</li><li>数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体</li></ol><p>电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层</p><ol><li>物理层接收到比特流，上交给数据链路层</li><li>数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层</li><li>网络层剥去首部，取出数据部分上交给传输层</li><li>传输层剥去首部，取出数据部分上交给应用层</li><li>应用层剥去首部，取出应用程序数据上交给应用进程<br>主机2</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;因特网发展的三个阶段&quot;&gt;&lt;a href=&quot;#因特网发展的三个阶段&quot; class=&quot;headerlink&quot; title=&quot;因特网发展的三个阶段&quot;&gt;&lt;/a&gt;因特网发展的三个阶段&lt;/h2&gt;&lt;h3 id=&quot;第一阶段：从单个网络ARPANET向互联网发展的过程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://coderjeremy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="https://coderjeremy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>NexT 6 添加字数和阅读时间统计</title>
    <link href="https://coderjeremy.github.io/2018/09/14/NexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1/"/>
    <id>https://coderjeremy.github.io/2018/09/14/NexT 6 添加字数和阅读时间统计/</id>
    <published>2018-09-14T14:04:25.000Z</published>
    <updated>2018-09-14T14:13:07.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开hexo目录，运行git-bush，安装插件"><a href="#打开hexo目录，运行git-bush，安装插件" class="headerlink" title="打开hexo目录，运行git bush，安装插件"></a>打开hexo目录，运行git bush，安装插件</h2><p><code>$ npm install hexo-symbols-count-time --save</code></p><h2 id="修改博客配置文件，添加以下代码"><a href="#修改博客配置文件，添加以下代码" class="headerlink" title="修改博客配置文件，添加以下代码"></a>修改博客配置文件，添加以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码"><a href="#修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码" class="headerlink" title="修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码"></a>修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;打开hexo目录，运行git-bush，安装插件&quot;&gt;&lt;a href=&quot;#打开hexo目录，运行git-bush，安装插件&quot; class=&quot;headerlink&quot; title=&quot;打开hexo目录，运行git bush，安装插件&quot;&gt;&lt;/a&gt;打开hexo目录，运行git
      
    
    </summary>
    
      <category term="Hexo搭建" scheme="https://coderjeremy.github.io/categories/Hexo%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://coderjeremy.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://coderjeremy.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>如何给Hexo正确添加RSS订阅</title>
    <link href="https://coderjeremy.github.io/2018/09/09/hexo-rss/"/>
    <id>https://coderjeremy.github.io/2018/09/09/hexo-rss/</id>
    <published>2018-09-09T13:36:23.000Z</published>
    <updated>2018-09-14T14:01:03.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装feed插件"><a href="#安装feed插件" class="headerlink" title="安装feed插件"></a>安装feed插件</h1><ol><li>本地hexo目录下运行<code>git bash here</code></li><li>输入指令<code>npm install hexo-generator-feed</code></li><li>等待安装完成</li></ol><h1 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h1><ol><li><p>打开hexo目录下配置文件_config.yml，末尾添加以下配置</p><blockquote><pre><code># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20</code></pre></blockquote></li><li><p>打开主题配置文件_config.yml,搜索rss，添加配置</p></li></ol><p><code>rss: /atom.xml</code></p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p><code>hexo s</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装feed插件&quot;&gt;&lt;a href=&quot;#安装feed插件&quot; class=&quot;headerlink&quot; title=&quot;安装feed插件&quot;&gt;&lt;/a&gt;安装feed插件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本地hexo目录下运行&lt;code&gt;git bash here&lt;/code&gt;&lt;/l
      
    
    </summary>
    
      <category term="Hexo搭建" scheme="https://coderjeremy.github.io/categories/Hexo%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://coderjeremy.github.io/tags/Hexo/"/>
    
      <category term="rss" scheme="https://coderjeremy.github.io/tags/rss/"/>
    
  </entry>
  
</feed>
