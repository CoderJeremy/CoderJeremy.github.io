<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s Blog</title>
  
  <subtitle>艰险我奋进，困乏我多情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coderjeremy.github.io/"/>
  <updated>2018-10-30T15:09:13.554Z</updated>
  <id>https://coderjeremy.github.io/</id>
  
  <author>
    <name>吴健伟_Jeremy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件管理及操作</title>
    <link href="https://coderjeremy.github.io/2018/10/30/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
    <id>https://coderjeremy.github.io/2018/10/30/Linux文件管理及操作/</id>
    <published>2018-10-30T13:57:42.000Z</published>
    <updated>2018-10-30T15:09:13.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/bin：</span><br><span class="line">bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。实际上是链接到/usr/bin。</span><br><span class="line">/boot：</span><br><span class="line">这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">/dev ：</span><br><span class="line">dev 是 Device(设备)的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">/etc：</span><br><span class="line">这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">/home：</span><br><span class="line">用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">/lib：</span><br><span class="line">这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的DLL文件，几乎所有的应用程序都需要用到这些共享库。64 位系统还有一个</span><br><span class="line">lib64，这两个目录连接到 /usr下对应的lib目录。</span><br><span class="line">/lost+found：</span><br><span class="line">这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</span><br><span class="line">/media：</span><br><span class="line">linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</span><br><span class="line">/mnt：</span><br><span class="line">系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</span><br><span class="line">/opt：</span><br><span class="line">这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</span><br><span class="line">/proc：</span><br><span class="line">这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的<span class="built_in"> ping </span>命令，使别人无法<span class="built_in"> ping </span>你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">/root：</span><br><span class="line">该目录为系统管理员，也称作超级权限者的用户主目录（相当于普通用户的家目录）。</span><br><span class="line">/sbin：</span><br><span class="line">s 就是 Super<span class="built_in"> User </span>的意思，这里存放的是系统管理员使用的系统管理程序。实际上连接到 /usr/sbin</span><br><span class="line">/selinux：</span><br><span class="line">这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</span><br><span class="line">/srv：</span><br><span class="line">该目录存放一些服务启动之后需要提取的数据。</span><br><span class="line">/sys：</span><br><span class="line">这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</span><br><span class="line">/tmp：</span><br><span class="line">这个目录是用来存放一些临时文件的。</span><br><span class="line">/usr：</span><br><span class="line">这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</span><br><span class="line">/usr/bin：</span><br><span class="line">系统用户使用的应用程序。</span><br><span class="line">/usr/sbin：</span><br><span class="line">超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">/usr/src：</span><br><span class="line">内核源代码默认的放置目录。</span><br><span class="line">/var：</span><br><span class="line">这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br></pre></td></tr></table></figure><img src="/2018/10/30/Linux文件管理及操作/01.png"><p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <code>.</code> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点<code>..</code> 来表示。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. ：代表当前的目录，也可以使用 <span class="string">./</span> 来表示；</span><br><span class="line"><span class="string">..</span> ：代表上一层目录，也可以 <span class="string">../</span> 来代表。</span><br></pre></td></tr></table></figure></p><h1 id="文件、目录常用命令"><a href="#文件、目录常用命令" class="headerlink" title="文件、目录常用命令"></a>文件、目录常用命令</h1><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>路径的写法，由根目录<code>/</code>写起，例如：<code>/usr/share/doc</code>这个目录。</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>路径的写法，不是由<code>/</code>写起，例如由 <code>/usr/share/doc</code>要到<code>/usr/share/man</code>底下时，可以写成：<code>cd ../man</code>这就是相对路径的写法</p><h2 id="显示当前工作目录pwd"><a href="#显示当前工作目录pwd" class="headerlink" title="显示当前工作目录pwd"></a>显示当前工作目录pwd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span> <span class="comment">#Print Working Directory 显示当前所在目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span> -P <span class="comment">#显示出确实的路径，而非使用连接路径</span></span></span><br></pre></td></tr></table></figure><h2 id="列出目录ls"><a href="#列出目录ls" class="headerlink" title="列出目录ls"></a>列出目录ls</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls [‐aAdfFhilnrRSt] 目录名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls [‐‐color=&#123;never,auto,always&#125;] 目录名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls [‐‐full‐time] 目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来（常用）<br>-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）<br>-l ：以长格式列出，包含文件的属性与权限等等数据；(常用)<br>-i ：在第 1 列显示文件的 inode 节点号</p></blockquote><h2 id="切换目录cd"><a href="#切换目录cd" class="headerlink" title="切换目录cd"></a>切换目录cd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用 mkdir 命令创建 runoob 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir runoob</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用绝对路径切换到 runoob 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /root/runoob/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用相对路径切换到 runoob 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ./runoob/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure><h2 id="创建新目录mkdir"><a href="#创建新目录mkdir" class="headerlink" title="创建新目录mkdir"></a>创建新目录mkdir</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir [-mp] 目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色。<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来</p></blockquote><h2 id="删除空目录rmdir"><a href="#删除空目录rmdir" class="headerlink" title="删除空目录rmdir"></a>删除空目录rmdir</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rmdir [-p] 目录名称</span></span><br></pre></td></tr></table></figure><blockquote><p>-p ：连同上一级的“空的”目录也一起删除</p></blockquote><h2 id="移除文件或目录rm"><a href="#移除文件或目录rm" class="headerlink" title="移除文件或目录rm"></a>移除文件或目录rm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm [-fir] 文件或目录</span></span><br></pre></td></tr></table></figure><blockquote><p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除，最常用的目录删除！这是非常危险的选项</p></blockquote><h2 id="复制文件或目录cp"><a href="#复制文件或目录cp" class="headerlink" title="复制文件或目录cp"></a>复制文件或目录cp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cp [‐adfilprsu] 来源档(<span class="built_in">source</span>) 目标档(destination)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure><blockquote><p>-a：相当于 ­pdr 的意思，至于 pdr 请参考下列说明；(常用)<br>-d：若来源文件为连接文件的属性(link file)，则复制连接文件而非文件本身；<br>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br>-l：进行硬连接(hard link)的文件创建，而非复制文件本身；<br>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br>-r：递归持续复制，用于目录的复制行为；(常用)<br>-s：复制成为符号连接 (symbolic link)，亦即『连接』文件；<br>-u：若 destination 比 source 旧才升级 destination</p></blockquote><h2 id="移动文件与目录，或修改名称mv"><a href="#移动文件与目录，或修改名称mv" class="headerlink" title="移动文件与目录，或修改名称mv"></a>移动文件与目录，或修改名称mv</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mv [‐fiu] <span class="built_in">source</span> destination</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure><blockquote><p>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</p></blockquote><h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat [-AbEnTv]  <span class="comment">#由第一行开始显示文件内容</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-A ：相当於 ­vET 的整合选项，可显示出一些特殊字符（如空白字符）；<br>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！<br>-E ：将结尾的断行字节 $ 显示出来；<br>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；<br>-T ：将 [tab] 按键以 ^I 显示出来；<br>-v ：列出一些看不出来的特殊字符</p></blockquote><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac 与 cat 命令刚好相反，文件内容从最后一行开始向前逐行显示，可以看出 tac 是cat 的倒写</p><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nl [-bnw] 文件 <span class="comment">#显示行号</span></span></span><br></pre></td></tr></table></figure><blockquote><p>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；<br>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；<br>-w ：行号栏位的占用的位数</p></blockquote><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页页翻动</p><blockquote><p>空白键 (space)：代表向下翻一页；<br>Enter ：代表向下翻『一行』<br>/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；<br>:f ：立刻显示出档名以及目前显示的行数；<br>q ：代表立刻离开 more ，不再显示该文件内容<br>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用</p></blockquote><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动</p><blockquote><p>空白键 ：向下翻动一页；<br>[pagedown]：向下翻动一页；<br>[pageup] ：向上翻动一页；<br>/字串 ：向下搜寻『字串』的功能；<br>?字串 ：向上搜寻『字串』的功能；<br>n ：重复前一个搜寻 (与 / 或 ? 有关！)<br>N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)<br>q ：离开 less 这个程序；</p></blockquote><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面的几行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> head [-n number] 文件</span></span><br></pre></td></tr></table></figure></p><blockquote><p>-n ：后面接数字，代表显示几行的意思</p></blockquote><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tail [-nf number] 文件</span></span><br></pre></td></tr></table></figure></p><blockquote><p>-n ：后面接数字，代表显示几行的意思<br>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-系统目录结构&quot;&gt;&lt;a href=&quot;#Linux-系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统目录结构&quot;&gt;&lt;/a&gt;Linux 系统目录结构&lt;/h1&gt;&lt;figure class=&quot;highlight routeros
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://coderjeremy.github.io/2018/10/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://coderjeremy.github.io/2018/10/30/Linux常用命令/</id>
    <published>2018-10-30T12:54:13.000Z</published>
    <updated>2018-10-30T13:51:14.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> clear<span class="comment">#清空当前终端命令历史记录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span><span class="comment">#退出终端</span></span></span><br></pre></td></tr></table></figure><h1 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> reboot<span class="comment">#重启</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown -r now<span class="comment">#重启。等同reboot</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown -h now<span class="comment">#关机，慎用，通常情况远程服务器关机后，物理机无法重启</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> halt<span class="comment">#关机，慎用</span></span></span><br></pre></td></tr></table></figure><h1 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> &lt;directory&gt;<span class="comment">#切换到指定目录下，参数可使用通配符，按下 tab 键可自动补足，连按两下 tab 键，则会将所有相关文件列出。directory 既可是绝对路径，也可是相对路径，./ 表示当前路径，../ 表示上一级路径，下同。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls &lt;directory&gt;<span class="comment">#列出指定目录下所有文件，如无参数，则列出当前目录下所有文件。directory 既可是绝对路径，也可是相对路径。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -l<span class="comment">#以长格式形式列出所有文件，可简写为 ll。长格式规则：第1列：1位文件类型，9位权限标志。第2列：文件索引节点编号，第3列：文件所有者名称，第4列：文件属主所在组名称，第5列：文件大小，第6列：文件最后修改日期，第7列：文件名称。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -a <span class="comment">#列出所有文件，包括隐藏文件。在 Linux 中，隐藏文件的文件名以 “.”开头。另外，命令参数若有多个可以合写，如ls ‐la。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp &lt;<span class="built_in">source</span>&gt; &lt;target&gt;<span class="comment">#将 source 文件复制到 target 位置。source和 target 既可是绝对路径，也可是相对路径，支持通配符，下同。第二个参数是目录的话，表示将文件复制到指定目录下，第二个参数如果是文件名称的话，表示将源文件复制成参数2指定的新文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp -r &lt;<span class="built_in">source</span>&gt; &lt;target&gt; <span class="comment">#递归复制，‐f 参数表示静默操作，无提示。有时 ‐f 可能会失效，详细原因见最后附录部分。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv &lt;<span class="built_in">source</span>&gt; &lt;target&gt;<span class="comment">#移动 source 文件到 target 位置，相当于剪切，重命名也是使用此命令。‐f 参数表示静默操作，无警告提示。mv 没有 ‐r参数。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm &lt;<span class="built_in">source</span>&gt;<span class="comment">#删除文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm -r &lt;<span class="built_in">source</span>&gt;<span class="comment">#递归删除，-f 参数表示静默操作，无警告提示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir &lt;directory&gt; <span class="comment">#创建目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p &lt;directory&gt;<span class="comment">#递归操作</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rmdir<span class="comment">#删除空目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> man  &lt;命令&gt; <span class="comment">#查看命令帮助文档或使用说明，按q 退出说明</span></span></span><br></pre></td></tr></table></figure><h1 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ll /etc/centos* <span class="comment"># ll 命令等同于ls ‐l</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ll /etc/centos‐release <span class="comment">#按 tab 键可自动补足</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/centos‐release <span class="comment">#cat 命令是直接在终端中显示</span></span></span><br></pre></td></tr></table></figure><h1 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname ‐r <span class="comment">#显示内核版本</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uname ‐m <span class="comment">#查看系统位数</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uname ‐a <span class="comment">#显示更全面的信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> arch <span class="comment">#与 uname ‐m 命令非常类似。如果输出 x86_64 则表示为 64 位系统，如果输出i686 或 i386 则表示为 32 位系统</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> getconf LONG_BIT<span class="comment">#查看系统位数</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$LANG</span> <span class="comment">#查看语言与本地化</span></span></span><br></pre></td></tr></table></figure><h1 id="查看网络及网卡状态"><a href="#查看网络及网卡状态" class="headerlink" title="查看网络及网卡状态"></a>查看网络及网卡状态</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig<span class="comment">#查看网络及网卡状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli dev show <span class="comment">#检查网卡状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli device show <span class="comment">#与之上命令效果等同</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli <span class="comment">#以简单模式显示网卡状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli con up ens33 <span class="comment">#最后一个参数是网卡名称，执行此命令后，将会激活连接此网卡</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli con down ens33 <span class="comment">#表示断开此网卡</span></span></span><br></pre></td></tr></table></figure><h1 id="查看当前系统用户"><a href="#查看当前系统用户" class="headerlink" title="查看当前系统用户"></a>查看当前系统用户</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> whoami <span class="comment">#查看当前系统操作用户身份，本指令等同于执行 id -un 指令 </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> id -un<span class="comment">#查看当前系统操作用户的身份</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> who am i <span class="comment">#查看当前系统登录用户，注意：是登录 id</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> who ‐m <span class="comment">#等同于 who am i</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> who <span class="comment">#显示系统当前登录的所有用户</span></span></span><br></pre></td></tr></table></figure><h1 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> su snow <span class="comment">#切换到普通snow 账户</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> su root <span class="comment">#切换到 root 账户，切换后相对路径与当前路径一致</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> su <span class="comment">#等同于上一条</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> su ‐ <span class="comment">#切换到 root 账户，切换后相对路径为 ~ ，即家目录。同时会显示最后一次登录时间。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span> <span class="comment">#退出当前的临时切换账户状态</span></span></span><br></pre></td></tr></table></figure><h1 id="CentOS-7-5-系统配置国内-yum-源和-epel"><a href="#CentOS-7-5-系统配置国内-yum-源和-epel" class="headerlink" title="CentOS 7.5 系统配置国内 yum 源和 epel"></a>CentOS 7.5 系统配置国内 yum 源和 epel</h1><ol><li>首先进入 <code>/etc/yum.repos.d/</code>目录下，新建一个 <code>repo_bak.d</code>目录，用于保存<br>系统中原来的 repo 文件 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /etc/yum.repos.d/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir repo_bak.d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv *.repo repo_bak.d/</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 CentOS 中配置使用网易和阿里的开源镜像<br>点击右上角的网络管理器，连接网络。因为 CentOS 默认是不自动连接网络的。首选使用 su ‐ 命令切换到 root 用户。否则某些操作是无法完成的，需要 root 权限到网易和阿里开源镜像站点下载系统对应版本的 repo</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> yum.repos.d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.aliyun.com/repo/Centos‐7.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.163.com/.<span class="built_in">help</span>/CentOS7‐Base‐163.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">Centos‐7.repo CentOS‐Base‐163.repo repo.bak</span><br></pre></td></tr></table></figure><p>或者手动下载 repo 文件并上传到<code>/etc/yum.repos.d/</code></p><ol start="3"><li>清除系统 yum 缓存并生成新的 yum </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum clean all</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum update <span class="comment">#更新软件</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>安装 epel 源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum ‐y install epel‐release</span></span><br></pre></td></tr></table></figure><h1 id="安装压缩、解压缩工具"><a href="#安装压缩、解压缩工具" class="headerlink" title="安装压缩、解压缩工具"></a>安装压缩、解压缩工具</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install zip unzip gzip p7zip <span class="comment">#安装压缩与解压缩工具</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum remove zip unzip gzip p7zip <span class="comment">#卸载压缩与解压缩工具</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum unzip -0 cp936 xxx.zip<span class="comment">#解决使用unzip命令时中文乱码的问题</span></span></span><br></pre></td></tr></table></figure><h1 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install ibus ibus-<span class="keyword">table</span>-wubi*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;终端&quot;&gt;&lt;a href=&quot;#终端&quot; class=&quot;headerlink&quot; title=&quot;终端&quot;&gt;&lt;/a&gt;终端&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux修改密码</title>
    <link href="https://coderjeremy.github.io/2018/10/30/Linux%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <id>https://coderjeremy.github.io/2018/10/30/Linux修改密码/</id>
    <published>2018-10-30T12:26:52.000Z</published>
    <updated>2018-10-30T12:33:27.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改-重置普通用户密码"><a href="#修改-重置普通用户密码" class="headerlink" title="修改/重置普通用户密码"></a>修改/重置普通用户密码</h1><ol><li><code>passwd</code> #用于当前操作用户自行修改密码。注意：修改密码时，需要输入当前操作用户的当前密码。root 用户也可使用此命令修改自行修改密码。</li><li><code>passwd &lt;用户名&gt;</code> #此命令只能由 root 用户执行，当前用户是 root时，可更改任意其它用户的密码</li></ol><h1 id="修改-重置-root-用户密码"><a href="#修改-重置-root-用户密码" class="headerlink" title="修改/重置 root 用户密码"></a>修改/重置 root 用户密码</h1><h2 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h2><p>如果 root 用户密码忘记，需要重置 root 密码的话。可按如下步骤操作（前提，有条可以操作物理机开机重启）：</p><h3 id="第一种方法-："><a href="#第一种方法-：" class="headerlink" title="第一种方法 ："></a>第一种方法 ：</h3><ul><li>开机，随意按一个键，进入开机项选择状态，否则 5 秒钟后系统默认选择第一项自动启动。按方向键选中第一项，按 e 进入编辑状态。事实上，选择其它项也可以，只不过，第一项是默认开机项，一般是最新的内核启动</li></ul><img src="/2018/10/30/Linux修改密码/01.png"><ul><li>进入编辑模式后。注意，显示的内容有可能并不是全部的内容，可以按方向键上下来查看更多内容</li></ul><img src="/2018/10/30/Linux修改密码/02.png"><ul><li>按方向键下，一直到内容的尾部。找到 linux16 这一行，将 ro 更改成<code>rw init=/sysroot/bin/sh</code>，按 ctrl + x 启动。注意：修改属临时修改，仅本次生效，重启电脑，又会恢复到原来的内容</li></ul><img src="/2018/10/30/Linux修改密码/03.png"><ul><li>启动后，进入单用户纯文本命令模式，注意：命令提示符是<code>:/#</code></li><li>使用指令<code>chroot /sysroot</code>切换根目录。经测试，此句之前无须执行挂载指令<code>mount ‐o remount,rw /sysroot</code></li><li>使用指令 <code>passwd root</code> ，来重置 root 用户的密码。由于本机安装了中文语言包，而当前文本命令模式不支持中文，所以修改密码时的提示，全部显示成了方块。如果未安装中文语言包的话，提示应该是英文的。不过操作很简单，就是输入两次密码，正确输入即可。<br>注意1：不要输入过于简单的密码。注意2：更改<code>LANG=en_US.UTF-8</code>，依然是中文提示，且中文仍然会显示成方块。</li><li>使用<code>touch /.autorelabel</code>命令，会在 / 目录下创建一个 .autorelabel 文件，有这个文件存在，系统在重启时就会对整个文件系统进行 relabeling。</li><li>使用命令 exit 退出 chroot 状态，使用命令 reboot 重启，使用 root 新密码登录。如果使用 reboot 不能重启，可以加入 -f 参数， <code>reboot ‐f</code> 强制重启。</li></ul><img src="/2018/10/30/Linux修改密码/04.png"><ul><li>重启后，进入以下状态</li></ul><img src="/2018/10/30/Linux修改密码/05.png"><ul><li>等待一会，系统会再次重启。正常进入系统。</li></ul><h3 id="第二种方法-："><a href="#第二种方法-：" class="headerlink" title="第二种方法 ："></a>第二种方法 ：</h3><ul><li>同样是开机时，按 e 进入编辑状态。将 ro 更改为 rw ，将 LANG=zh_CN.UTF-8 更改为 LANG=en_US.UTF-8，并在末尾追加空格，init=/bin/sh，注意：一定是在末尾添加。</li></ul><img src="/2018/10/30/Linux修改密码/06.png"><ul><li>按 Ctrl + x 启动。启动后如下</li></ul><img src="/2018/10/30/Linux修改密码/07.png"><ul><li><p>执行如下指令，修改密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> passwd root</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /.autorelabel <span class="comment">#注意文件名称</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> /sbin/init <span class="comment">#重启即可</span></span></span><br></pre></td></tr></table></figure></li><li><p>注意：此种方式，修改 LANG=en_US.UTF-8，是可以显示英文的。注意：本方法命令行前缀是<code>sh‐4.2#</code></p></li></ul><img src="/2018/10/30/Linux修改密码/08.png"><ul><li>启动后进入以下状态</li></ul><img src="/2018/10/30/Linux修改密码/09.png"><h3 id="第三种方法："><a href="#第三种方法：" class="headerlink" title="第三种方法："></a>第三种方法：</h3><ul><li>按 e 编辑，添加<code>rd.break</code></li></ul><img src="/2018/10/30/Linux修改密码/10.png"><ul><li>启动后，如下状态：注意命令前缀<code>switch_root</code>，这是固定不变（不因不同的机器而变）的</li></ul><ul><li>依次输入以下指令，与第一种方法相同。注意指令前缀的变化<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount ‐o remount,rw /sysroot <span class="comment">#如果不加这一句，是没有效果的。但第一种方法经测试，无须加此句。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chroot /sysroot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> passwd root</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /.autorelabel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot <span class="comment">#重启</span></span></span><br></pre></td></tr></table></figure></li></ul><img src="/2018/10/30/Linux修改密码/12.png"><ul><li>两次重启后就会生效。注意：CentOS 6.x 版本和 7.x 版本，重置 root 密码的方法是不一样的。具体方法可查询网络。重置 root 用户密码是 Redhat RHCE 认证考试必须先完成的第一步操作，很明显，意味着这是最简单的必备技能。第二种方法相对简单一些。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修改-重置普通用户密码&quot;&gt;&lt;a href=&quot;#修改-重置普通用户密码&quot; class=&quot;headerlink&quot; title=&quot;修改/重置普通用户密码&quot;&gt;&lt;/a&gt;修改/重置普通用户密码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;passwd&lt;/code&gt; #用于当前操作用
      
    
    </summary>
    
      <category term="Linux" scheme="https://coderjeremy.github.io/categories/Linux/"/>
    
    
      <category term="Linxu" scheme="https://coderjeremy.github.io/tags/Linxu/"/>
    
      <category term="CentOs" scheme="https://coderjeremy.github.io/tags/CentOs/"/>
    
  </entry>
  
  <entry>
    <title>说点心情</title>
    <link href="https://coderjeremy.github.io/2018/10/24/1024%E8%AF%B4%E7%82%B9/"/>
    <id>https://coderjeremy.github.io/2018/10/24/1024说点/</id>
    <published>2018-10-24T06:09:43.000Z</published>
    <updated>2018-10-24T06:29:00.411Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>还有人知道今天给我过节<br><br>很开心有人记得我<br><br><img src="/2018/10/24/1024说点/1024.jpg"><br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;还有人知道今天给我过节&lt;br&gt;&lt;br&gt;很开心有人记得我&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/2018/10/24/1024说点/1024.jpg&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="闲聊" scheme="https://coderjeremy.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="心情" scheme="https://coderjeremy.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Quicksort快速排序算法</title>
    <link href="https://coderjeremy.github.io/2018/10/09/Quicksort%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://coderjeremy.github.io/2018/10/09/Quicksort快速排序算法/</id>
    <published>2018-10-09T12:04:05.000Z</published>
    <updated>2018-10-09T13:44:07.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><p>思想：二分法，分治法，递归</p><p>排序实例<br>6    1    2    7    9    3    4    5    10    8<br>6为基准，也就是temp<br>先从右找第一个比基准数小的，再从左找第一个比基准数大的，进行交换，这里必须从右边先找的原因是因为基准数定的是最左的数。</p><blockquote><p>如果选取最左边的数a[left]作为基准数，那么先从右边开始可保证i，j在相遇时，相遇数是小于基准数的，交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它</p></blockquote><p>找到7 和 5<br>6     1    2    <strong>7</strong>    9    3    4    <strong>5</strong>    10    8</p><hr><p>交换后得到<br>6    1    2    <strong>5</strong>    9    3    4    <strong>7</strong>    10    8</p><hr><p>依次类推，当得到 i == j 或 i &gt; j时，排序无法继续进行，此时情况如下<br>6    1    2    5    4    <strong>3</strong>    9    7    10    8</p><hr><p>此时交换基准数与<strong>3</strong><br><strong>3</strong>    1    2    5    4    <strong>6</strong>    9    7    10    8</p><hr><p>这样就保证了基准数6左边都比他小，右边都比他大<br>这时，再将3设为基准数，在3 1 2 5 4 中进行快速排序，在9 7 10 8中进行快速排序<br>也就是进行递归排序算法，最终就得到排序结果<br>1    2    3    4    5    6    7    8    9    10</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">int</span> temp = a[left];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= temp)<span class="comment">//a[j]&lt;temp跳出循环，找到第一个a[j]&lt;temp</span></span><br><span class="line">j--;<span class="comment">//从右向左找第一个小于x的数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= temp)<span class="comment">//a[i]&gt;temp跳出循环，找到第一个a[i]&gt;temp</span></span><br><span class="line">i++;<span class="comment">//从左向右找第一个大于x的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将基准数归位</span></span><br><span class="line">a[left] = a[i];</span><br><span class="line">a[i] = temp;</span><br><span class="line">QuickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">QuickSort(a, i + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试用例：</p><p>Input:<br>11<br>3 4 5 1 34 61 22 41 111 2 87</p><p>Output:<br>1 2 3 4 5 22 34 41 61 87 111</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序算法&quot;&gt;&lt;a href=&quot;#快速排序算法&quot; class=&quot;headerlink&quot; title=&quot;快速排序算法&quot;&gt;&lt;/a&gt;快速排序算法&lt;/h1&gt;&lt;p&gt;思想：二分法，分治法，递归&lt;/p&gt;
&lt;p&gt;排序实例&lt;br&gt;6    1    2    7    9    
      
    
    </summary>
    
      <category term="算法" scheme="https://coderjeremy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://coderjeremy.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="QuickSort" scheme="https://coderjeremy.github.io/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络物理层</title>
    <link href="https://coderjeremy.github.io/2018/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://coderjeremy.github.io/2018/09/25/计算机网络物理层/</id>
    <published>2018-09-25T07:56:16.000Z</published>
    <updated>2018-10-23T12:53:59.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h1><p>确定与传输媒体的接口有关的一些特性：</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><p>传输方式的转换</p><ul><li>数据在计算机中多采用<strong><em> 并行传输 </em></strong> 方式</li><li>数据在通信线路上的传输方式一般是<strong><em> 串行传输 </em></strong></li></ul><h1 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h1><h2 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h2><img src="/2018/09/25/计算机网络物理层/数据通信系统的模型.png" title="数据通信系统的模型"><h2 id="数据通信基本概念"><a href="#数据通信基本概念" class="headerlink" title="数据通信基本概念"></a>数据通信基本概念</h2><ul><li>模拟信号（连续信号） ：一般是正弦或余弦波形</li><li><p>数字信号（离散信号）：脉冲信号</p><blockquote><p>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote></li><li><p>模拟传输：模拟数据的传输，不关心传输信号的内容，只关心减少信号的衰减和噪声，长距离传输，采用信号放大器放大被衰减的信号，同时放大了噪声</p></li><li>数字传输（适合长距离传输）：数字数据0、1的传输，关心信号的内容，可以数字信号传输也可以模拟信号传输，长距离传输时，采用转发器，可以消除噪声的累积<h2 id="信道及其极限容量"><a href="#信道及其极限容量" class="headerlink" title="信道及其极限容量"></a>信道及其极限容量</h2></li><li>信道：数据传输的通道<ul><li>单向通信：单工，单向传输</li><li>双向交替通信：半双工，一方发，一方收，不能同时</li><li>双向同时通信：全双工，同时发送和接收信息，需要两条信道</li></ul></li><li>信道参数<ul><li>数据传输速率 = 带宽</li><li>载波频率：信道对应的频率</li><li>采样频率：模拟信号转化为数字信号时采样的速率</li><li>量化：对采样信号的数字化</li><li>噪声、信噪比：<strong> 信噪比（dB）= 10log<sub>10</sub>(S/N)（dB）</strong></li></ul></li></ul><blockquote><p><strong><em>Nyquist定理</em></strong>——计算机通信的基本定理<br>比特率 = log<sub>2</sub>V波特率<br>在无噪信道中，当带宽为H Hz，信号电平为V级：<br><strong> 数据传输速率 = 2Hlog<sub>2</sub>V (b/s) </strong><br>V：信号电平的级数，在二进制中，仅为0、1两级<br>采样定理：以每秒高于2H次的速率对线路采样是无意义的，因为高频分量已被滤波器过滤无法恢复</p><blockquote><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题<br>如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰</p></blockquote></blockquote><blockquote><p><strong><em>香农（Shannon)定理：</em></strong><br>在噪声信道中，当带宽为H Hz，信噪比为 S/N ：<br><strong>最大数据传输速率（b/s）= Hlog<sub>2</sub>（1+S/N）</strong></p><blockquote><p>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高<br>只要信息传输速率低于信道的极限信息传输速率，就可以找到某种办法实现无差错的传输<br>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用编码的方法<strong>让每一个码元携带更多比特的信息量</strong></p></blockquote></blockquote><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>基带传输：<br>​    - 基带信号：信号源产生的原始电信号，也叫基本频带信号<br>​    - 基带信号往往包含有较多低频成分，因此必须对基带信号进行调制<br>宽带传输<br>​    - 将基带信号进行调制后形成模拟信号，经过载波调制，然后采用频分复用技术实现宽带传输<br>​    - 带通信号（频带信号）：把基带信号经过载波调制，把信号的频率范围搬移到较高的频段<br>​    - 宽带传输：多个频带的带通信号在同一个物理媒体上传输<br>​    </p><ul><li><p><strong>数字数据在模拟信道上传输：数字信号——&gt;模拟信号</strong></p><ul><li>将数字数据调制成模拟信号进行传输，把0、1用波形表示</li><li>通常有三种基本的调制方式<ul><li>调幅ASK：用载波的两种不同的振幅来表示两个二进制</li><li>调频FSK：用载波附近的两种不同的频率来表示两个二级制</li><li>调相PSK：用载波的相位移动来表示两个二进制</li></ul></li><li>正交调相QPSK</li><li>正交调幅QAM</li></ul></li><li><p><strong>数字数据的数字信号传输</strong></p><ul><li>数字信号的编码：数字数据用离散信号表示，存在发送方和接收方的同步问题</li><li>常用的数字信号编码方式：<ul><li>不归零编码NRZ</li><li>曼切斯特编码——自同步编码方式</li><li>差分曼切斯特编码——自同步编码方式，抗干扰性强于曼切斯特编码，根据发送一个比特开始时有无跳变表示0或1</li></ul></li><li>编码方式的比较：<ul><li>不归零制编码的编码密度最高，接收端一次采样可得到一个bit ，即波特率等于比特率，但不能携带时钟</li><li>曼切斯特编码的编码密度最低，接收端二次采样才可得到一个bit ，即波特率是比特率的两倍，但每个bit中都有信号跳变，即携带了时钟</li><li>差分曼切斯特编码与曼切斯特编码基本相同</li></ul></li></ul></li><li><p><strong>模拟数据在数字信道上传输</strong></p><ul><li>模拟数据变成数字数据在数字信道上传递</li><li>采用脉冲编码调制（PCM–Pulse Code Modulation）技术</li><li>关键点：在接收端还原成模拟数据</li><li>PCM以Nyquist采样定理为基础<blockquote><p>采样定理 ：如果在规定的时间间隔内，以有效信号最高频率的二倍或二倍以上的速率对该信号进行采样，则这些采样值中包含了全部原始信号信息</p></blockquote></li></ul></li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><p>Frequency Division Multiplexing<br>前提：传输介质的可用带宽必须超过各路给定信号所需带宽的总和<br>频分复用的所有用户再同样的时间占用不同的带宽资源</p><h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><p>Time Division Multiplexing<br>每个信号按时间先后轮流交替地使用单一信道，多个数字信号再宏观上可以认为是同时进行传输<br>​    - 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。<br>​    - 每一个用户所占用的时隙是周期性地出现<br>​    - TDM信号也称为等时信号<br>​    - 时分复用地所有用户是在不同的时间占用同样的频带宽度</p><img src="/2018/09/25/计算机网络物理层/时分复用.png" title="时分复用"><p>TDM的同步和异步：<br>​    - 同步TDM:<br>​        - 时间片与输入装置一一对应，同步<br>​        - 如果某个时间片对应的输入装置无数据发送，则该时间片空闲<br>​        - 传输介质的传输速率不能低于各个输入信号的数据速率之和<br>​        - 同步TDM可能会造成线路资源的浪费<br><img src="/2018/09/25/计算机网络物理层/同步TDM.png" title="同步TDM"><br>​    - 异步TDM<br>​        - 时间片是按需动态分配的<br>​        - 时间片与输入装置之间没有对应关系，任何一个时间片都可以用于传输任何一路输入信号<br>​        - 在传输的数据单元中必须包含地址信息，以便寻址目的节点<br>​        - 传输介质的传输速率只要不低于各个输入信号的平均速率即可<br>​        - 异步TDM又称<strong>统计TDM(STDM)</strong></p><img src="/2018/09/25/计算机网络物理层/异步TDM.png" title="异步TDM"><h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><p>Wavelength Division Multiplexing<br>光的频分复用</p><h3 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h3><p>Code Division Multiplexing</p><h4 id="码分多址（Code-Division-Multiple-Access）"><a href="#码分多址（Code-Division-Multiple-Access）" class="headerlink" title="码分多址（Code Division Multiple Access）"></a>码分多址（Code Division Multiple Access）</h4><ul><li>每个用户可以CDMA在同样的时间使用同样的频带进行通信</li><li>抗干扰强，频谱类似白噪声，不易被发现</li><li>采用CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等</li></ul><h4 id="码片序列（chip-sequence）"><a href="#码片序列（chip-sequence）" class="headerlink" title="码片序列（chip sequence）"></a>码片序列（chip sequence）</h4><ul><li>每一个比特时间再划分为 m 个短的间隔，称为码片(chip)。<br>  通常m取值为64或128（在后面的原理性说明中，取为8）</li><li>每个站被指派一个唯一的 m bit 码片序列(chip sequence) 。<br>  如发送比特 1，则发送自己的 m bit 码片序列。<br>  如发送比特 0，则发送该码片序列的二进制反码。<br>  例如，S 站的 8 bit 码片序列是 00011011。<br>  发送比特 1 时，就发送序列 00011011，<br>  发送比特 0 时，就发送序列 11100100。<br>  为了方便，将码片0写为–1 ，将1写为+1<br>  S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</li><li>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。<br>在实用的系统中是使用伪随机码序列。</li></ul><h4 id="码片序列的正交关系"><a href="#码片序列的正交关系" class="headerlink" title="码片序列的正交关系"></a>码片序列的正交关系</h4><ul><li>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 </li><li>两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0<img src="/2018/09/25/计算机网络物理层/码片正交.png" title="码片正交"></li></ul><img src="/2018/09/25/计算机网络物理层/码片规格化.png" title="码片规格化"><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>物理媒体中间设备传递数据的技术</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>在数据传输前，必须建立一条端到端的通路，称为连接，该连接可能穿越多个交换局，而每个交换局都必须为之提供连接</li><li>一旦建立连接，整个通路将被独占，除信号传播的延时之外，数据传输无额外延时，数据中毋需包含目的地址<ul><li>服务质量好</li><li>线路的利用率较低</li><li>建立连接时间长，因连接建立时冲突概率高 </li></ul></li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul><li>无论数据传输过程要跨越多少个交换结点（通常是路由器），只要下一站不忙，该数据即送至下一站</li><li>数据的传输毋需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制<ul><li>线路的利用率较高</li><li>由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计－－拥塞</li><li>每个中间站点都必须有足够大的缓存，但由于报文大小不定，内存无法预留，所以缓存通常设置在硬盘中（进一步延时）</li></ul></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li>与报文交换相似，只是将报文分为若干个定长的分组（≤最大分组长度），每个分组为一个子报文<br>  可以为分组在内存预留空间</li><li>每个分组中必须包含目的地址，并采用存储-转发机制<ul><li>线路的利用率较高</li><li>由于采用store-forward机制，所以在数据传输过程中，除了信号传播的延时之外，还有存储和转发的延时，而且可能延时较大，且不可估计</li><li>每个中间站点必须有缓存，但由于报文大小固定，所以缓存通常在内存中设置<br>存储转发的速度较报文交换高</li><li>接收分组和发送分组的顺序可能不一致 ，因此在接收端需要缓存并且可能还需要重组，进而还原出原始报文</li></ul></li></ul><h3 id="虚电路交换"><a href="#虚电路交换" class="headerlink" title="虚电路交换"></a>虚电路交换</h3><ul><li>将电路交换的概念引入到分组交换<ul><li>信息传递依然采用分组（定义最大分组长度）</li><li>引入电路交换的连接建立过程</li><li>找到路径（但非独占路径上的链路），因而经过中间结点时的路由延时小，且保留了分组交换中线路利用率高的优点</li><li>发送端到接收端有一条确定的路径，因而接收顺序与发送顺序一致</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;物理层的主要任务&quot;&gt;&lt;a href=&quot;#物理层的主要任务&quot; class=&quot;headerlink&quot; title=&quot;物理层的主要任务&quot;&gt;&lt;/a&gt;物理层的主要任务&lt;/h1&gt;&lt;p&gt;确定与传输媒体的接口有关的一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机械特性&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://coderjeremy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="https://coderjeremy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="物理层" scheme="https://coderjeremy.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://coderjeremy.github.io/2018/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://coderjeremy.github.io/2018/09/18/计算机网络概述/</id>
    <published>2018-09-18T13:30:01.000Z</published>
    <updated>2018-09-25T08:07:50.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><h3 id="第一阶段：从单个网络ARPANET向互联网发展的过程"><a href="#第一阶段：从单个网络ARPANET向互联网发展的过程" class="headerlink" title="第一阶段：从单个网络ARPANET向互联网发展的过程"></a>第一阶段：从单个网络ARPANET向互联网发展的过程</h3><p>ARPANET：</p><ul><li>1969年美国国防部创建的第一个分组交换网</li><li>1983年TCP/IP协议成为ARPANET上的标准协议，因特网诞生</li><li>1990年关闭<h3 id="第二阶段：三级结构的因特网"><a href="#第二阶段：三级结构的因特网" class="headerlink" title="第二阶段：三级结构的因特网"></a>第二阶段：三级结构的因特网</h3>1985年美国国家科学基金会：NSFNET<br>三级计算机网络：</li></ul><ul><li>主干网</li><li>地区网</li><li>校园网（或企业网）<h3 id="第三阶段：多层次ISP结构因特网"><a href="#第三阶段：多层次ISP结构因特网" class="headerlink" title="第三阶段：多层次ISP结构因特网"></a>第三阶段：多层次ISP结构因特网</h3></li><li>第一层：服务面积最大(一般是国家范围)，拥有高速主干网</li><li>NAP </li><li>第二层：第一层ISP的用户</li><li>第三层：又称本地ISP，拥有本地范围的网络<blockquote><p>ISP: (Internet Service Provider) 互联网服务提供者（商）<br>NAP:网络接入点<strong>NAP</strong> (Network Access Point)：分散主干网流量，又称对等点（peering point）<br>IXP：（Internet eXchange Point）互联网交换点 ，允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组</p></blockquote></li></ul><h2 id="英特网的组成"><a href="#英特网的组成" class="headerlink" title="英特网的组成"></a>英特网的组成</h2><p>因特网的<strong>边缘部分</strong>：由所有连接在因特网上的<strong>主机</strong>组成（通信和资源共享）<br>因特网的<strong>核心部分</strong>：由大量网络和连接这些网络的<strong>路由器（router）</strong>组成，为边缘部分提供服务（连通性和交换）</p><blockquote><p>另一种分法：资源子网，通信子网</p></blockquote><hr><h3 id="边缘部分通信方式："><a href="#边缘部分通信方式：" class="headerlink" title="边缘部分通信方式："></a>边缘部分通信方式：</h3><ol><li>客户服务器方式（C/S）:Client/Server，都是指通信中所涉及的两个应用进程</li></ol><ul><li>客户程序特点：<ul><li>客户程序必须知道服务器程序的地址</li><li>不需要特殊的硬件和复杂的操作系统</li></ul></li><li>服务程序特点：<ul><li>可同时处理多个远地或本地客户的请求</li><li>系统启动后自动调用并一直不断的运行着</li><li>一般需要强大的硬件和高级的操作系统支持</li></ul></li></ul><ol start="2"><li>对等方式（P2P）:Peer to Peer，指两个主机在通信是并不区分哪一个是服务请求方还是服务提供方，本质上看仍是C/S方式，只是P2P中的每一个主机既是客户又是服务器</li></ol><h3 id="核心部分三种交换方式："><a href="#核心部分三种交换方式：" class="headerlink" title="核心部分三种交换方式："></a>核心部分三种交换方式：</h3><blockquote><p>路由器：实现分组交换的关键构建，转发收到的分组<br>交换（switching）按照某种方式动态地分配传输线路的资源</p><ol><li>电路交换：面向连接，三个阶段：建立–&gt;保持–&gt;释放<br> 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源<ul><li>通话前先拨号建立连接（经过一个或多个交换机）</li><li>通话过程中，通信双方一直占用所建立的连接</li><li>通话结束后，挂机释放连接</li></ul></li></ol></blockquote><ol start="2"><li><p>报文交换</p></li><li><p>分组交换</p><ul><li>在发送端，先把较长的报文划分成较短的固定长度的数据端</li><li>每一个数据段前面添加上首部构成分组</li><li>依次把各分组发送到接收端</li><li><p>接收端剥去首部，抽出数据部分，还原成报文</p><blockquote><p>每一个分组的首部都含有地址等控制信息<br>结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机</p></blockquote><p>路由器处理分组的过程：</p></li><li>把收到的分组先放入缓存；</li><li>查找转发表，找出到某个目的地址应从哪个端口转发；</li><li><p>把分组送到适当的端口转发出去</p><p>优点：</p></li><li>高效    动态分配传输带宽，对通信链路是逐段占用。 </li><li>灵活    以分组为传送单位和查找路由。</li><li>迅速    不必先建立连接就能向其他主机发送分组。</li><li><p>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。   </p><p>缺点：</p></li><li>分组在各结点存储转发时需要排队，这就会造成一定的时延。</li><li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</li></ul></li></ol><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>1.按照网络的作用分类：<br>​    - 广域网WAN（Wide Area Network）<br>​    - 城域网MAN (Metropolitan Area Network)<br>​    - 局域网LAN (Local Area Network)<br>​    - 个人区域网PAN (Personal Area Network)<br>2.按照网络的使用者分类：<br>​    - 公用网（public network）<br>​    - 专用网 (private network)<br>3.原来把用户接入到互联网的网络：接入网 AN(Access Network)</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol><li>速率<br> 数据的传送速率，也叫数据率或比特率，单位bit/s（比特每秒）</li><li>带宽<ul><li>某个信号具有频带宽度，信号的带宽是指该信号说包含的各种不同频率成分说占据的频率范围，单位赫兹HZ</li><li>计算机网络中，带宽用来表示网络中某通道传送数据的能力，单位bit/s</li></ul></li><li>吞吐量<br> 表示在单位时间内通过某个网络（或信道、接口）的实际数据量</li><li><p>时延</p><ul><li><p>发送时延<br>主机或路由器发送数据帧所需要的时间<br>​    发送时延 = 数据帧长度 / 发送速率</p></li><li><p>传播时延<br>电磁波在信道中传播一定的距离需要花费的时间<br>​    传播时延  = 信道长度  /  电磁波在信道上的传播速率</p></li><li><p>处理时延<br>主机或路由器在收到分组时需要花费时间处理</p></li><li><p>排队时延<br>分组在经过网络传输时，需要经过许多路由器，要在路由器中排队等待处理</p><blockquote><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></blockquote></li></ul></li><li><p>时延带宽积<br> 时延宽带积 = 传播时延 x 带宽 （以比特为单位的链路长度）</p></li><li>往返时间RTT（Round-Trip Time）<br> 发送时长 = 数据长度 / 发送速率<br> 有效数据率 = 数据长度 / （发送时间 + RTT）</li><li>利用率<br> 信道利用率和网络利用率，过高会产生非常大的时延</li></ol><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h3><ol><li>实体：<ul><li>表示任何可发送或接收信息的硬件或软件进程</li><li>对等实体peer entity</li></ul></li><li>协议（protocol）：<ul><li>控制两个对等实体进行通信的规则、标准或约定的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</li><li>网络协议的组成要素<ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul></li></ul></li><li><p>协议与服务：</p><ul><li>本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的</li><li>协议是”水平的“，协议是控制对等实体之间通信的规则</li><li>服务是”垂直的“，服务是由下层向上层通过层间接口提供的<blockquote><p>并非在一个层内完成的全部功能都称为服务，只有能够被高一层的实体看得见的功能才能称为服务<br>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语</p></blockquote></li></ul></li><li><p>服务访问点 SAP（Service Access Point）：</p><ul><li>同一系统相邻两层实体进行交互的地方称为SAP</li><li>服务数据单元SDU(Service Data Unit)</li></ul></li></ol><h3 id="OSI-RM体系结构"><a href="#OSI-RM体系结构" class="headerlink" title="OSI/RM体系结构"></a>OSI/RM体系结构</h3><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">第七层</td><td style="text-align:center">应用层(applicationg layer)</td><td style="text-align:left">约定请求消息和应答消息；包括所用应用方面的协议；不同系统之间的文件传输方式不同，但表示的形式必须一致</td></tr><tr><td style="text-align:center">第六层</td><td style="text-align:center">表示层(presentation layer)</td><td style="text-align:left">表示层关心的是语法和语义；对相关的数据的描述采用抽象的定义</td></tr><tr><td style="text-align:center">第五层</td><td style="text-align:center">会话层(session layer)</td><td style="text-align:left">建立有关会话的机制，是双向的还是单向对话或重新建立会话</td></tr><tr><td style="text-align:center">第四层</td><td style="text-align:center">传输层(transport layer)</td><td style="text-align:left">提供端到端的通路，应用到应用的通路</td></tr><tr><td style="text-align:center">第三层</td><td style="text-align:center">网络层(network layer)</td><td style="text-align:left">提供主机到主机的通路，其间可能存在多条通路，网络层将实现的功能包括<br>- 选择路由<br>- 拥塞控制<br>- 协议的转换<br>- 分段和重组<br>- 对用户的分组、字符等统计</td></tr><tr><td style="text-align:center">第二层</td><td style="text-align:center">数据连路层(data link layer)</td><td style="text-align:left">提供点到点的可靠传输，通常需把数据分成帧，并且保证帧的正确发送和接收<br>- 识别帧的标志<br>- 帧的发送和接收，需校验、确认<br>- 发送方在超时或收到否定性确认后，要重发<br>- 重复帧要丢弃<br>在共享网络中，需解决信道共享问题等——mac层</td></tr><tr><td style="text-align:center">第一层</td><td style="text-align:center">物理层(physical layer)</td><td style="text-align:left">与传输媒体的接口，完成传输媒体上的信号与二进制数据间的转换</td></tr></tbody></table><blockquote><p>会话层及以下关心的是信息的传输<br>表示层及以上关心的是信息的理解</p></blockquote><h3 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a>TCP/IP的体系结构</h3><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">第五层</td><td style="text-align:center">应用层</td><td style="text-align:left">通过应用进程间的交互来完成特定网络应用，包括HTTP,SMTP,FTP等</td></tr><tr><td style="text-align:center">第四层</td><td style="text-align:center">传输层</td><td style="text-align:left">负责向两台主机中进程之间的通信提供通用的数据传输服务<br>TCP（Transmisson Control Protocol）：面向连接的，数据传输的单位是报文段，提供可靠的交付<br>UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供尽最大努力交付</td></tr><tr><td style="text-align:center">第三层</td><td style="text-align:center">网络层</td><td style="text-align:left">为分组交换网上的不同主机提供通信服务<br>把传输层产生的报文段或用户数据报封装成分组或包进行传送<br>选择合适路由<br>网际协议IP和多路由选择协议</td></tr><tr><td style="text-align:center">第二层</td><td style="text-align:center">数据链路层</td><td style="text-align:left">将网络层交下来的IP数据包组装成帧，每一帧包括数据和必要的控制信息</td></tr><tr><td style="text-align:center">第一层</td><td style="text-align:center">物理层</td><td style="text-align:left">透明的传送比特流</td></tr></tbody></table><blockquote><p>传递信息所利用的一些物理媒体，如双绞线、同轴电缆等，并不在物理层协议之内而是在物理层协议之下，因此物理媒体也可当作第0层</p></blockquote><h3 id="数据传递过程"><a href="#数据传递过程" class="headerlink" title="数据传递过程"></a>数据传递过程</h3><blockquote><p>PDU(Protocol Data Unit)：对等层次间传送的数据单位</p></blockquote><p>主机1</p><ol start="5"><li>应用进程数据先传送到应用层,加上应用层首部，称为PDU</li><li>应用层PDU再传送到传输层，加上传输层首部，成为传输层报文</li><li>传输层报文再传送到网络层，加上网络层首部，成为IP数据报或分组</li><li>IP数据报再传送到数据链路层， 加上链路层首部和尾部，成为数据链路层帧</li><li>数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体</li></ol><p>电信号或光信号在物理媒体中传播从发送端物理层传送到接收端物理层</p><ol><li>物理层接收到比特流，上交给数据链路层</li><li>数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层</li><li>网络层剥去首部，取出数据部分上交给传输层</li><li>传输层剥去首部，取出数据部分上交给应用层</li><li>应用层剥去首部，取出应用程序数据上交给应用进程<br>主机2</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;因特网发展的三个阶段&quot;&gt;&lt;a href=&quot;#因特网发展的三个阶段&quot; class=&quot;headerlink&quot; title=&quot;因特网发展的三个阶段&quot;&gt;&lt;/a&gt;因特网发展的三个阶段&lt;/h2&gt;&lt;h3 id=&quot;第一阶段：从单个网络ARPANET向互联网发展的过程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://coderjeremy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="https://coderjeremy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>NexT 6 添加字数和阅读时间统计</title>
    <link href="https://coderjeremy.github.io/2018/09/14/NexT%206%20%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1/"/>
    <id>https://coderjeremy.github.io/2018/09/14/NexT 6 添加字数和阅读时间统计/</id>
    <published>2018-09-14T14:04:25.000Z</published>
    <updated>2018-09-14T14:13:07.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开hexo目录，运行git-bush，安装插件"><a href="#打开hexo目录，运行git-bush，安装插件" class="headerlink" title="打开hexo目录，运行git bush，安装插件"></a>打开hexo目录，运行git bush，安装插件</h2><p><code>$ npm install hexo-symbols-count-time --save</code></p><h2 id="修改博客配置文件，添加以下代码"><a href="#修改博客配置文件，添加以下代码" class="headerlink" title="修改博客配置文件，添加以下代码"></a>修改博客配置文件，添加以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码"><a href="#修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码" class="headerlink" title="修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码"></a>修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;打开hexo目录，运行git-bush，安装插件&quot;&gt;&lt;a href=&quot;#打开hexo目录，运行git-bush，安装插件&quot; class=&quot;headerlink&quot; title=&quot;打开hexo目录，运行git bush，安装插件&quot;&gt;&lt;/a&gt;打开hexo目录，运行git
      
    
    </summary>
    
      <category term="Hexo搭建" scheme="https://coderjeremy.github.io/categories/Hexo%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://coderjeremy.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://coderjeremy.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>如何给Hexo正确添加RSS订阅</title>
    <link href="https://coderjeremy.github.io/2018/09/09/hexo-rss/"/>
    <id>https://coderjeremy.github.io/2018/09/09/hexo-rss/</id>
    <published>2018-09-09T13:36:23.000Z</published>
    <updated>2018-09-14T14:01:03.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装feed插件"><a href="#安装feed插件" class="headerlink" title="安装feed插件"></a>安装feed插件</h1><ol><li>本地hexo目录下运行<code>git bash here</code></li><li>输入指令<code>npm install hexo-generator-feed</code></li><li>等待安装完成</li></ol><h1 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h1><ol><li><p>打开hexo目录下配置文件_config.yml，末尾添加以下配置</p><blockquote><pre><code># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20</code></pre></blockquote></li><li><p>打开主题配置文件_config.yml,搜索rss，添加配置</p></li></ol><p><code>rss: /atom.xml</code></p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p><code>hexo s</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装feed插件&quot;&gt;&lt;a href=&quot;#安装feed插件&quot; class=&quot;headerlink&quot; title=&quot;安装feed插件&quot;&gt;&lt;/a&gt;安装feed插件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本地hexo目录下运行&lt;code&gt;git bash here&lt;/code&gt;&lt;/l
      
    
    </summary>
    
      <category term="Hexo搭建" scheme="https://coderjeremy.github.io/categories/Hexo%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://coderjeremy.github.io/tags/Hexo/"/>
    
      <category term="rss" scheme="https://coderjeremy.github.io/tags/rss/"/>
    
  </entry>
  
</feed>
