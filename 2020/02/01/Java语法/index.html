<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

















  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "1af87200"
    });
  daovoice('update');
  </script>



  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PingFang SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.1',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  





  <meta name="description" content="Java初步字节 位（bit): 一个数字0或1 字节（Byte）: 8位=1字节，这是数据存储的最小单位 1KB = 1024 Byte,1MB = 1024 KB  命令提示符 MS-DOS(Microsoft Disk Operating System) 启动 ：win + R 切换盘符 ： [盘符]: 进入文件： cd [文件名] 退回上一层：cd .. 退回根目录：cd \ 显示文件列表">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语法">
<meta property="og:url" content="https://coderjeremy.github.io/2020/02/01/Java语法/index.html">
<meta property="og:site_name" content="Jeremy&#39;s Blog">
<meta property="og:description" content="Java初步字节 位（bit): 一个数字0或1 字节（Byte）: 8位=1字节，这是数据存储的最小单位 1KB = 1024 Byte,1MB = 1024 KB  命令提示符 MS-DOS(Microsoft Disk Operating System) 启动 ：win + R 切换盘符 ： [盘符]: 进入文件： cd [文件名] 退回上一层：cd .. 退回根目录：cd \ 显示文件列表">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-02-03T06:41:40.057Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java语法">
<meta name="twitter:description" content="Java初步字节 位（bit): 一个数字0或1 字节（Byte）: 8位=1字节，这是数据存储的最小单位 1KB = 1024 Byte,1MB = 1024 KB  命令提示符 MS-DOS(Microsoft Disk Operating System) 启动 ：win + R 切换盘符 ： [盘符]: 进入文件： cd [文件名] 退回上一层：cd .. 退回根目录：cd \ 显示文件列表">



  <link rel="alternate" href="/atom.xml" title="Jeremy's Blog" type="application/atom+xml" />




  <link rel="canonical" href="https://coderjeremy.github.io/2020/02/01/Java语法/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java语法 | Jeremy's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeremy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">艰险我奋进，困乏我多情</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-photo">
    <a href="/photo/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />摄影</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />日程表</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coderjeremy.github.io/2020/02/01/Java语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吴健伟_Jeremy">
      <meta itemprop="description" content="艰险我奋进，困乏我多情">
      <meta itemprop="image" content="/images/profilephoto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeremy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java语法
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-01 16:36:46" itemprop="dateCreated datePublished" datetime="2020-02-01T16:36:46+08:00">2020-02-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-03 14:41:40" itemprop="dateModified" datetime="2020-02-03T14:41:40+08:00">2020-02-03</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/Java语法/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/Java语法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/02/01/Java语法/" class="leancloud_visitors" data-flag-title="Java语法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
				 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">48k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">44 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java初步"><a href="#Java初步" class="headerlink" title="Java初步"></a>Java初步</h2><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><ul>
<li>位（bit): 一个数字0或1</li>
<li>字节（Byte）: 8位=1字节，这是数据存储的最小单位</li>
<li>1KB = 1024 Byte,1MB = 1024 KB</li>
</ul>
<h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><ul>
<li>MS-DOS(Microsoft Disk Operating System)</li>
<li>启动 ：win + R</li>
<li>切换盘符 ： [盘符]:</li>
<li>进入文件： cd [文件名]</li>
<li>退回上一层：cd ..</li>
<li>退回根目录：cd \</li>
<li>显示文件列表: dir</li>
<li>清空屏幕：cls</li>
<li>推出cmd : exit</li>
</ul>
<h3 id="JVM、JRE、JDK"><a href="#JVM、JRE、JDK" class="headerlink" title="JVM、JRE、JDK"></a>JVM、JRE、JDK</h3><ul>
<li>JVM : Java Virtual Machine,Java虚拟机，是Java程序的运行环境,系统不同，虚拟机版本不同</li>
<li>JRE : Java Runtime Environment, Java运行时环境，包含<code>JVM</code> 和 <code>核心类库</code> </li>
<li>JDK : Java Development Kit, Java开发工具包，包含<code>JRE</code> 和 <code>开发者工具</code></li>
<li>JDK &gt;&gt; JRE &gt;&gt; JVM</li>
</ul>
<h3 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h3><ul>
<li>新建变量：JAVA_HOME，值：jdk安装路径，直到bin的上一级</li>
<li>添加Path：%JAVA_HOME%\bin ,%自动匹配%</li>
</ul>
<hr>
<h2 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h2><h3 id="Jaava程序运行步骤"><a href="#Jaava程序运行步骤" class="headerlink" title="Jaava程序运行步骤"></a>Jaava程序运行步骤</h3><ul>
<li>java源程序–&gt;编译器–&gt;java字节码文件–&gt;JVM运行</li>
<li>javac.exe : 编译器</li>
<li>java.exe : 解释器 </li>
</ul>
<h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><ol>
<li>编写：编写HelloWorld.java</li>
<li>编译：打开CMD，找到程序所在目录，输入<code>javac HelloWorld.java</code>，生成：HelloWorld.class 文件</li>
<li>运行：输入 <code>java HelloWorld</code> ,无需后缀，指定类名</li>
</ol>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释 ： //</li>
<li>多行注释 ： /<em> </em>/</li>
</ul>
<h3 id="关键字、标识符"><a href="#关键字、标识符" class="headerlink" title="关键字、标识符"></a>关键字、标识符</h3><ul>
<li>关键字 : 完全小写的字母（public）</li>
<li>标识符 : ·在程序中，自己定义的内容，比如类的名字和变量的名<ul>
<li>命名规则: <ol>
<li>由 英文字母、0-9、$(美元符)、_（下划线）组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
</ol>
</li>
<li>命名规范:<ol>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰）</li>
<li>变量名规范：首字母小写，后面每个单词首字母大写（小驼峰）</li>
<li>方法名规范：同变量名</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行期间，固定不变的量</li>
<li>分类：<ol>
<li>字符串常量：双引号引用的部分,例如：”abc”,”123”</li>
<li>整数常量：直接写上数字，没有小数点,例如：100,200</li>
<li>浮点数常量：直接写上数字，有小数点，例如：2.5,-3.14</li>
<li>字符常量：单引号引起来的单个字符，例如：’A’,’中’（没有’’,’AB’，有’ ‘）</li>
<li>布尔常量：只有两种取值，true、false</li>
<li>空常量：null,代表没有任何数据</li>
</ol>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>程序运行期间，内容可以发生改变的量</li>
<li>创建一个变量并且使用的格式：<ul>
<li>数据类型 变量名称 //创建了一个变量</li>
<li>变量名称 = 数据值 //赋值交给左边的变量</li>
</ul>
</li>
<li>一步到位<ul>
<li>数据类型 变量名称 = 数据值；//创建一个变量的同时，立刻放入指定的数据值</li>
</ul>
</li>
<li>注意事项 ：<ul>
<li>如果创建多个变量，变量之间的名称不可以重复</li>
<li>对于float和long类型来说，字母f和L不要漏掉</li>
<li>如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围</li>
<li>没有进行赋值的变量，不能直接使用</li>
<li>变量使用不能超过作用域的范围<br>【作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止】</li>
</ul>
</li>
</ul>
<h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li>整数型 byte short int long</li>
<li>浮点型 float double</li>
<li>字符型 char</li>
<li>布尔型 boolean<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4></li>
<li>字符串</li>
<li>数组</li>
<li>类</li>
<li>接口</li>
<li>Lambda<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4></li>
<li>字符串不是基本类型，而是引用类型</li>
<li>浮点型可能只是一个近似值，并非精确的值</li>
<li>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节</li>
<li>浮点数当中默认类型是double,如果要用float，需要加上一个后缀F</li>
<li>整数 当中默认类型是int,如果要使用long，需要加上一个后缀L，推荐使用大写字母后缀</li>
</ul>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul>
<li><p>自动类型转换（隐式）</p>
<ol>
<li>特点：代码不需要进行特殊处理，自动完成。  </li>
<li>规则：数据范围从小到大，向上兼容</li>
</ol>
</li>
<li><p>强制类型转换（显式）</p>
<ol>
<li>特点: 代码需要进行特殊格式处理，不能自动完成</li>
<li>格式：范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据</li>
</ol>
</li>
<li><p>注意事项：</p>
<ol>
<li>强制类型转换一般不推荐使用，因为有可能发生精度损失(小数)、数据溢出(大数)</li>
<li>byte/short/char 这三种类型都可以发生数学运算，例如加法”+”。</li>
<li>byte/short/char 这三种类型在运算时，都会被首先提升为int类型，然后再计算。</li>
<li>boolean类型不能发生数据类型转换</li>
<li>对于byte/short/char 三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器会自动隐含地为我们补上一个(byte)(short)(char)。<ul>
<li>如果没有超过左侧范围，编译器自动补上强转。</li>
<li>如果超过左侧范围，编译器会直接报错。</li>
</ul>
</li>
<li>在给变量进行赋值时候，如果右侧地表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。</li>
</ol>
</li>
<li>编译器的常量优化 ： <code>short result = 5 + 8;</code>  等号右边全是常量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中相当于直接就是 <code>short result = 13;</code>右侧的常量结果数值，没有超过左侧范围，所以正确。这种成为<strong>“编译器的常量优化”</strong>。常量计算在编译时已经计算并赋值。一旦表达式右侧有变量参与，则无法进行这种优化。</li>
</ul>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><ul>
<li>ASCII : American Standard Code for Information Interchange 美国信息交换标准代码</li>
<li>Unicode : 万国码，也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是128开始包含有更多字符</li>
<li>‘0’ - ‘48’ , ‘A’ - 65 , ‘a’ - 97</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>进行特定操作的符号，例如：+</li>
<li>表达式：用运算符连起来的式子，例如：a + b</li>
<li>分类：<ul>
<li>算数运算符：+ 、 - 、  * 、 /  、 % 、 ++ 、 –</li>
<li>赋值运算符：= 、 += 、-= 、*= 、/= 、%=</li>
<li>比较运算符：== 、&lt; 、 &gt; 、 &lt;= 、 &gt;= 、 != </li>
<li>逻辑运算符：&amp;&amp; 、 || 、 !(取反)</li>
<li>三目运算符：数据类型 变量名称 = 布尔类型表达式 ? 结果1 : 结果2  （true为结果1，false为结果2）</li>
</ul>
</li>
</ul>
<h3 id="方法入门"><a href="#方法入门" class="headerlink" title="方法入门"></a>方法入门</h3><ul>
<li>定义：若干语句功能的集合，将一个功能抽取出来，形成一个单独的功能，提高代码复用，减少冗余</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修饰符 返回值类型 方法名(参数列表)&#123;</span></span><br><span class="line"><span class="comment">    方法体</span></span><br><span class="line"><span class="comment">    return ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是一个方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用: 方法不会自动运行，必须被调用</p>
</li>
<li>注意:<ul>
<li>方法定义的先后顺序无所谓</li>
<li>方法定义必须是挨着的，不能再一个方法的内部定义另外一个方法</li>
<li>方法必须被调用才会执行</li>
</ul>
</li>
</ul>
<h3 id="Java9-新特性"><a href="#Java9-新特性" class="headerlink" title="Java9 新特性"></a>Java9 新特性</h3><ul>
<li>JShell : 适合片段代码的测试</li>
<li>启动 ： cmd + JShell</li>
<li>退出 : /exit</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><ul>
<li>顺序结构：根据编写顺序，从上到下执行。</li>
</ul>
<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ul>
<li>if</li>
<li>if…else</li>
<li>if…else if…else</li>
</ul>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><ul>
<li>switch<ul>
<li>注意：多个case后面的数值不可以重复</li>
<li>switch小括号当中只能是下列数据类型<ul>
<li>基本数据类型 ： byte/short/char/int</li>
<li>引用数据类型 : String字符串、enum枚举</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>()&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体:n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>case的穿透性：如果case的后面不写break,将出现穿透现象，直接向后运行，直到遇到break;</li>
</ul>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul>
<li>for</li>
<li>while</li>
<li><p>do-while：无条件执行一次循环体，具有一定风险性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        循环体</span><br><span class="line">        步进表达式</span><br><span class="line">    &#125;<span class="keyword">while</span>(布尔表达式)</span><br></pre></td></tr></table></figure>
</li>
<li><p>区别：</p>
<ol>
<li>如果条件判断从来没有满足过，for和while将执行0次，do-while至少循环一次</li>
<li>for循环的变量在小括号当中定义，只有循环内可以使用</li>
</ol>
</li>
</ul>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>(自定义)自动补全快捷键:file-settings-keymap-dupulicate(创建副本)-main menu-code-completion-basic(ctrl+alt+?)</li>
<li>Alt+Enter : 导入包，自动修正代码</li>
<li>Ctrl+Y : 删除光标所在行</li>
<li>Ctrl+D : 复制光标所在行，插入光标位置下面</li>
<li>Ctrl+ALt+L : 格式化代码</li>
<li>Ctrl+/ : 单行注释</li>
<li>Ctrl+Shift+/ : 多行注释</li>
<li>Alt+Ins : 自动生成代码，toString,get,set方法</li>
<li>Alt+Shift+上下箭头 : 移动当前代码行<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4></li>
<li>Project</li>
<li>Module</li>
<li>Package</li>
<li>Class</li>
</ul>
<hr>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>若干语句功能的集合</li>
<li>参数:进入方法的数据</li>
<li><p>返回值: 从方法中出来的数据</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称(参数类型 参数名称,...)&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰符: public static…</p>
</li>
<li>返回值类型: void int </li>
<li>方法名称 : 方法名字，小驼峰</li>
<li>参数名称 : 进入方法的数据对应的变量名称</li>
<li>方法体 : 方法需要做的事</li>
<li>return : 停止当前方法，将返回值还给调用处</li>
<li>返回值 : 执行方法后得到的数据结果</li>
<li>注意 :<ul>
<li>return后面的”返回值“，必须和方法名称前面的返回值类型，保持对应</li>
</ul>
</li>
</ul>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><ol>
<li>单独调用: 方法名称(参数),返回值为void,只能单独调用</li>
<li>打印调用: System.out.println(方法名称(参数));</li>
<li>赋值调用: 数据类型 变量名称 = 方法名称(参数);</li>
</ol>
<h4 id="方法的重载（Overload）"><a href="#方法的重载（Overload）" class="headerlink" title="方法的重载（Overload）"></a>方法的重载（Overload）</h4><ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</li>
<li>参数列表: 个数不同，数据类型不同，顺序不同</li>
<li>重载方法调用 : JVM通过方法的参数列表，调用不同的方法。</li>
<li>注意 : <ul>
<li>与参数的名称无关 </li>
<li>与方法的返回值类型无关</li>
</ul>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>方法应该定义在类中，但是不能在方法中再定义方法，不能嵌套</li>
<li>方法定义的先后顺序无所谓</li>
<li>方法必须被调用才能执行</li>
<li>返回值类型必须和方法的返回值类型对应</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>存储数据长度固定的容器，保证多个数据的数据类型要一致</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数组是一种引用数据类型</li>
<li>数组当中的多个数据类型一致</li>
<li>数组的长度在程序运行期间不可改变 </li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>在内存中创建一个数组，并且向其中赋予一些默认值<ul>
<li>动态初始化:指定长度</li>
<li>静态初始化:指定内容</li>
</ul>
</li>
</ul>
<h5 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h5><ul>
<li><p><code>数据类型[] 数组名称 = new 数据类型[数组长度]</code></p>
</li>
<li><p>左侧数据类型:数组中保存的数据类型</p>
</li>
<li>左侧的中括号:表示这是一个数组</li>
<li>左侧数组名称:数组的名字</li>
<li>右侧的new : 代表创建数组的动作</li>
<li>右侧数据类型:必须和左边的数据类型保持一致</li>
<li><p>右侧中括号的长度:数组当中，到底可以保存多少个数据,是一个int数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值</p>
<ul>
<li>整数型:默认值0;</li>
<li>浮点型:默认值0.0;</li>
<li>字符型:’\u0000’;</li>
<li>布尔型:false;</li>
<li>引用型:null.</li>
</ul>
</li>
</ul>
<h5 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h5><ul>
<li><code>数据类型[] 数组名称 = new 数据类型[]{元素1, 元素2, 元素3...}</code></li>
<li><p>自动分配空间和容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 静态初始化也有默认值，只不过系统自动马上将默认值替换成大括号中具体值</p>
</li>
</ul>
<h4 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h4><ul>
<li>直接打印数组名称，得到的是数组对应的,内存地址哈希值</li>
<li>访问数组元素的格式: <code>数组名称 [索引值]</code></li>
</ul>
<h4 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h4><ul>
<li>栈(Stack):存放的都是方法中的局部变量。方法的运行一定要在栈中运行。<ul>
<li>局部变量:方法的参数，或者是方法{}内部的变量</li>
<li>作用域:一旦超出作用域，立刻从栈内存当中消失</li>
</ul>
</li>
<li>堆(Heap): new出来的东西，都在堆中。<ul>
<li>堆内存里面的东西都有一个地址值:16进制</li>
<li>堆内存里面的数据，都有默认值</li>
</ul>
</li>
<li>方法区(Method Area):存储.class相关信息，包含方法的信息</li>
<li>本地方法栈(Native Method Stack):与操作系统相关</li>
<li>寄存器(pc Register): 与CPU相关</li>
</ul>
<h4 id="数组的常见问题"><a href="#数组的常见问题" class="headerlink" title="数组的常见问题"></a>数组的常见问题</h4><ul>
<li>索引越界异常:如果访问数组元素的时候，索引编号不存在，将会发生数组索引越界异常:<code>ArrayIndexOutOfBoundsException</code></li>
<li>空指针:数组必须进行new初始化才能使用其中的元素。如果只是赋值了一个null,没有进行new创建，那么将会发生空指针异常:<code>NullPointerException</code></li>
</ul>
<h4 id="数组的常用操作"><a href="#数组的常用操作" class="headerlink" title="数组的常用操作"></a>数组的常用操作</h4><ul>
<li>获取数组长度: <code>数组名称.length</code>，数组一旦创建，程序运行期间，长度不可改变</li>
<li>数组的遍历: 数组名称.fori–&gt;自动补全遍历代码</li>
<li>数组作为方法参数: 传递地址值</li>
<li>数组作为方法返回值: 返回地址值，<code>public static int[] 方法名</code>，<code>return 数组名</code></li>
</ul>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul>
<li>方法的参数为基本类型时，传递的是数据值</li>
<li>方法的参数为引用类型时，传递的时地址值</li>
</ul>
<hr>
<h2 id="Java中级"><a href="#Java中级" class="headerlink" title="Java中级"></a>Java中级</h2><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><ul>
<li>面向过程: 当需要实现一个功能时，每一个步骤都需要具体描述出来，强调步骤</li>
<li>面向对象:当需要实现一个功能时，不关心具体步骤，强调过程<ul>
<li>封装</li>
<li>继承</li>
<li>多态<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4></li>
</ul>
</li>
<li>类:一组相关<strong>属性</strong>和<strong>行为</strong>的集合，可以看作是一类事物的模板，使用事物的属性特性和行为特征来描述该类事物。<ul>
<li>属性:该事物的状态信息</li>
<li>行为:该事物能够做什么</li>
</ul>
</li>
<li>对象:一类事物的具体体现。对象是类的一个<strong>实例</strong>,必然具备该类事物的属性和行为。</li>
<li>类与对象的关系:<ul>
<li>类是对象的模板，对象是类的实例</li>
<li>类是一类事物的描述，抽象</li>
<li>对象是一类事物的实例，具体</li>
</ul>
</li>
</ul>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><ul>
<li><p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员变量(属性):对应事物的属性(事物的状态信息)</li>
<li>成员方法(行为):对应事物的行为(事物能够做什么)<h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4></li>
</ul>
</li>
<li>通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用<ol>
<li>导包：指出所需要使用的类，在什么位置：<code>import 包名称.类名称</code></li>
<li>创建：<code>类名称 对象名 = new 类名称();</code></li>
<li>使用：<ul>
<li>使用成员变量：<code>对象名.成员变量名</code></li>
<li>使用成员方法：<code>对象名.成员方法名(参数)</code></li>
</ul>
</li>
</ol>
<ul>
<li>注意：<ul>
<li>当使用一个对象类型作为方法的<em>参数</em>时，传递的就是对象的地址值。</li>
<li>当使用一个对象类型作为方法的<em>返回值</em>时，返回值其实就是对象的地址值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h4><ul>
<li>定义的位置不一样<ul>
<li>局部变量：方法内部</li>
<li>成员变量：方法外部，直接写在类当中</li>
</ul>
</li>
<li>作用的范围不一样<ul>
<li>局部变量：只有方法当中才可以使用</li>
<li>成员变量：整个类可以使用</li>
</ul>
</li>
<li>默认值不一样<ul>
<li>局部变量：没有默认值，必须手动赋值</li>
<li>成员变量：如果没有进行赋值，会有默认值，规则和数组一样</li>
</ul>
</li>
<li>内存位置不一样<ul>
<li>局部变量；位于栈内存中</li>
<li>成员变量：位于堆内存中</li>
</ul>
</li>
<li>生存周期不一样<ul>
<li>局部变量：随着方法进栈儿诞生，随着方法出栈而消失</li>
<li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3></li>
</ul>
</li>
<li>封装性在Java当中的体现<ol>
<li>方法就是一种封装</li>
<li>关键字private也是一种封装</li>
</ol>
</li>
<li>封装就是将一些细节信息隐藏起来，对于外界不可见</li>
</ul>
<h4 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h4><ul>
<li><code>private</code>是一个权限修饰符，代表最小权限</li>
<li>可以修饰成员变量和成员方法</li>
<li>被<code>private</code>修饰后的成员变量和成员方法，只有在本类中访问，超过本类范围就不能被访问</li>
<li>通过设置<code>setXXX()</code>,<code>getXXX()</code>方法来实现外部访问</li>
</ul>
<h4 id="This"><a href="#This" class="headerlink" title="This"></a>This</h4><ul>
<li><code>this</code>代表所在类的当前对象的引用(地址值),即对象自己的引用</li>
<li>当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量</li>
<li>如果需要访问本类当中的成员变量，需要使用格式:<code>this.成员变量名</code></li>
<li>通过谁调用的方法，谁就是<code>this</code></li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。</li>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称(参数类型 参数名称)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ol>
<li>构造方法的名称必须和所在类名称完全一致 </li>
<li>构造方法不要写返回值类型，连void也不用写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果没有编写任何构造方法，编译器会默认添加一个无参，无方法体的构造方法</li>
<li>一旦编写了至少一个构造方法，那么编译器将不再默认添加</li>
<li>构造方法也可以进行重载（方法名相同，参数列表不同）</li>
</ol>
</li>
</ul>
<h3 id="标准类-JavaBean"><a href="#标准类-JavaBean" class="headerlink" title="标准类(JavaBean)"></a>标准类(JavaBean)</h3><ul>
<li>格式<ul>
<li>所有成员变量都要使用<code>private</code>关键字修饰</li>
<li>为每一个成员变量编写一对<code>Getter/Setter</code>方法(快捷键:Alt+insert/CODE-&gt;Generate生成器)</li>
<li>编写一个无参数的构造方法(快捷键：Alt+insert-&gt;Constuctor构造器)</li>
<li>编写一个全参数的构造方法</li>
</ul>
</li>
<li>这样的标准类也叫JavaBean</li>
<li>JavaBean：Java语言编写类的一种标准规范。</li>
</ul>
<hr>
<h2 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a>Java高级</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><ul>
<li>API: Application Programming Interface.应用程序编程接口。Java API时一本程序员的字典，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们通过查询API的方式，来学习Java提供的类</li>
<li>API使用步骤：<ol>
<li>打开帮助文档</li>
<li>点击显示，找到快速索引，看到输入框</li>
<li>输入需要查找的内容</li>
<li>看包，java.lang下的类不需要导包，其他需要</li>
<li>看类的解释和说明</li>
<li>学习构造方法</li>
<li>使用成员方法</li>
</ol>
</li>
</ul>
<h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><ul>
<li>功能：可以实现键盘输入数据，到程序中</li>
<li>引用类型一般使用步骤：<ol>
<li>导包: <code>import 包路径.类名称</code>，如果需要使用的目标类和当前类位于同一个包下，则可以省略导包语句不写，只有java.lang包下的内容不需要导包，其他包都需要import语句</li>
<li>创建: <code>类名称 对象名 = new 类名称()</code></li>
<li>使用: <code>对象名·成员方法名()</code></li>
</ol>
</li>
<li>导包：<code>import java.util.Scanner</code></li>
<li>创建：<code>Scanner sc = new Scanner(System.in)</code>，System.in表示从键盘进行输入</li>
<li>使用：<ul>
<li>获取键盘输入的一个int数字：<code>int num = sc.nextInt();</code> </li>
<li>获取键盘输入的一个字符串：<code>String str = sc.next();</code></li>
</ul>
</li>
</ul>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><ul>
<li>创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量</li>
<li>格式：<code>new 类名称(参数列表);</code>，左边没有变量值和赋值号。</li>
<li>应用场景：<ul>
<li>创建匿名对象直接调用方法，没有变量名</li>
<li>匿名对象只能使用唯一的一次，下次再用不得不创建一个新对象，造成浪费</li>
<li>匿名对象可以作为方法的参数和返回值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匿名对象 Anonymous</span></span><br><span class="line"><span class="comment"> * 做参数</span></span><br><span class="line"><span class="comment"> * 做返回值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        做参数</span></span><br><span class="line">        System.out.println(<span class="string">"输入的数字是："</span> + <span class="keyword">new</span> Scanner(System.in).nextInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        使用匿名对象作为参数</span></span><br><span class="line">        methodParam(<span class="keyword">new</span> Scanner(System.in));</span><br><span class="line"></span><br><span class="line"><span class="comment">//         匿名对象作为返回值</span></span><br><span class="line">        Scanner sc = methodReturn();</span><br><span class="line">        System.out.println(<span class="string">"第三次输入的是："</span>+sc.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名对象做参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodParam</span><span class="params">(Scanner sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> anInt = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入的第二个数字是:"</span> + anInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名对象做返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">methodReturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><ul>
<li>作用：产生随机数</li>
<li>使用步骤：<ul>
<li>查看类：导包，<code>import java.util.Random</code></li>
<li>查看构造方法：创建，<code>Random r = new Random()</code></li>
<li>查看成员方法：使用，<ul>
<li>获取一个随机的int数字：<code>int num = r.nextInt()</code></li>
<li>获取一个随机的int数字：(参数代表范围，左闭右开区间)，<code>int num = r.nextInt(3)</code>,实代表的范围是 [0,3)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h4><ul>
<li>ArrayList集合的长度是可以随便变化的</li>
<li>导包：<code>import java.util.ArrayList</code></li>
<li>创建：<code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code></li>
<li><p>使用：成员方法</p>
<ul>
<li><code>public boolean add()</code>：向集合当中添加元素，参数的类型和泛型一致</li>
<li><code>public E get(int index)</code>；从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</li>
<li><code>public E remove(int index)</code>：从集合中删除元素，参数是索引编号，返回值就是被删除掉的元素</li>
<li><code>public int size()</code>：获取集合的长度，返回值是集合中元素的个数</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>尖括号内的泛型只能是引用类型，不能是基本类型</li>
<li><p>如果向集合ArrayList当中存储基本类型数据，必须使用<em>基本类型</em>对应的<em>包装类</em></p>
<ul>
<li>基本类型 -&gt; 包装类</li>
<li>int -&gt; Integer</li>
<li>byte -&gt; Byte</li>
<li>short -&gt; Short</li>
<li>long -&gt; Long</li>
<li>float -&gt; Float</li>
<li>double -&gt; Double</li>
<li>char -&gt; Character</li>
<li>boolean -&gt; Boolean  </li>
</ul>
</li>
<li><p>从JDK1.5开始，支持自动装箱（基本类型-&gt;包装类型），自动拆箱（包装类型-&gt;基本类型）</p>
</li>
</ul>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p>特点：</p>
<ul>
<li>字符串的内容永不可变</li>
<li>字符串可以共享使用</li>
<li>字符串效果上相当于是char[ ]字符数组，但其底层原理是byte[ ]字节数组。</li>
</ul>
</li>
<li><p>创建字符串：</p>
<ul>
<li>三种构造方法<ol>
<li>public String()：创建一个空白字符串，不含任何内容</li>
<li>public String(char[] array)：根据字符数组的内容，来创建对应的字符串</li>
<li>public String(byte[] array)：根据字节数组的内容，来创建对应的字符串</li>
</ol>
</li>
<li>一种直接创建<ul>
<li><code>String str = &quot;Hello&quot;;</code> //右边直接用双引号</li>
<li>直接写上双引号，就是字符串对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><ul>
<li>对于常量类型来说，==判断的是值</li>
<li>对于引用类型来说，==判断的是地址值</li>
<li>双引号直接写的字符串在常量池当中，new的不在池当中</li>
</ul>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h6><ul>
<li><code>public boolean equals(Object obj);//参数可以是任何对象</code>，任何对象都能用object进行接受<ul>
<li>注意：<ul>
<li>任何对象都能用object进行接收</li>
<li>equals方法具有对称性，也就是<code>a.equals(b)</code>和<code>b.equals(a)</code>;</li>
<li>如果比较双方一个常量一个变量，推荐常量写在前面，推荐：<code>&quot;abc&quot;.equals(str)</code>,不推荐<code>str.equals(&quot;abc&quot;)</code>；防止str为null，产生空指针异常</li>
</ul>
</li>
</ul>
</li>
<li><code>public boolean equalsIgnoreCase(String str)</code>：忽略大小写进行内容比较</li>
</ul>
<h6 id="字符串获取"><a href="#字符串获取" class="headerlink" title="字符串获取"></a>字符串获取</h6><ul>
<li><code>public int length()</code>：获取字符串当中含有的字符个数，拿到字符串的长度</li>
<li><code>public String concat(String str)</code>：将当前字符串和参数字符串拼接成为返回值新的字符串（concatenate级联）</li>
<li><code>public char charAt(int index)</code>：获取指定索引位置的单个字符（索引从0开始）</li>
<li><code>public int indexOf(String str)</code>：查找<em>参数字符串</em>在原本字符串当中首次出现的索引位置，如果不存在，返回-1</li>
</ul>
<h6 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h6><ul>
<li><code>public String substring(int index)</code>：截取从参数位置一直到字符串末尾，返回新字符串</li>
<li><code>public String substring(int begin, int end)</code>：截取从begin开始，一直到end结束，中间的字符串，[begin, end)，包含左边，不含右边</li>
</ul>
<h6 id="字符串转换、替换"><a href="#字符串转换、替换" class="headerlink" title="字符串转换、替换"></a>字符串转换、替换</h6><ul>
<li><code>public char[] toCharArray()</code>：将当前字符串拆分成为字符数组作为返回值</li>
<li><code>public byte[] getBytes()</code>：获取当前字符串底层的字节数组</li>
<li><code>public String replace(CharSequence oldString, CharSequence newString)</code>：将所有出现的老字符串替换成为新的字符串,CharSequence意思就是说可以接受字符串类型。</li>
</ul>
<h6 id="字符串分割方法"><a href="#字符串分割方法" class="headerlink" title="字符串分割方法"></a>字符串分割方法</h6><ul>
<li><code>public String[] split(String regex)</code>：按照参数规则，将字符串切分为若干部分</li>
<li>注意：split方法的参数其实是一个正则表达式如果要切分<code>&quot;.&quot;</code>，必须写成<code>&quot;\\.&quot;</code></li>
</ul>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><ul>
<li><code>static</code>用来修饰成员变量和成员方法，被修饰的成员是<code>属于类</code>，而不是仅仅属于某个对象自己，凡是本类的对象，都共享同一内容。</li>
<li>一旦使用<code>static</code>修饰静态成员方法，那么这种方法就成为了静态方法，静态方法可以直接通过对象名进行调用，也可以直接通过类名称来调用；非静态方法必须通过创建类才能使用</li>
<li>有<code>static</code>，推荐使用类名称进行调用<ul>
<li>静态变量：类名称.静态变量</li>
<li>静态方法：类名称.静态方法()</li>
</ul>
</li>
<li>对于本类当中的静态方法，可以省略类名称，编译器会自动补全</li>
<li>注意：<ol>
<li>静态不能直接访问非静态，因为在内存当中先有静态内容，后有非静态内容</li>
<li>静态方法不能用<code>this</code>，因为this代表当前对象，通过谁调用方法，谁就是当前对象</li>
</ol>
</li>
</ul>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//静态代码块内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当第一次用到本类时，静态代码块执行唯一的一次</p>
</li>
<li>静态内容总是优先于非静态，所以静态代码块构造方法先执行</li>
<li>用途：用来一次性地对静态成员变量进行赋值</li>
</ul>
<h4 id="数组根据类：Arrays"><a href="#数组根据类：Arrays" class="headerlink" title="数组根据类：Arrays"></a>数组根据类：Arrays</h4><ul>
<li>作用：与数组相关的工具类，实现数组的常见操作，所有方法都是静态方法，使用非常方便</li>
<li>导包：<code>java.util.Arrays</code></li>
<li>使用：<ul>
<li><code>public static String toString()</code>；将参数数组变成字符串(按照默认格式；[元素1，元素2，元素3…])</li>
<li><code>public static void sort(数组)</code>：按照默认升序对数组的元素进行排序。<ul>
<li>如果是数值，sort默认升序</li>
<li>如果是字符串，sort默认按字母升序</li>
<li>如果是自定义类，那么这个自定义的类需要有Comparable或者Comparator接口的支持。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数学工具类：Math"><a href="#数学工具类：Math" class="headerlink" title="数学工具类：Math"></a>数学工具类：Math</h4><ul>
<li>与数学相关的工具类，里面提供了大量的静态方法，完成于数学运算相关的操作</li>
<li>导包；<code>java.util.Math</code></li>
<li>使用：<ul>
<li><code>public static double abs(double num)</code>：获取绝对值</li>
<li><code>public static double ceil(double num)</code>：向上取整</li>
<li><code>public static double floor(double num)</code>：向下取整</li>
<li><code>public static long round(double num)</code>：四舍五入</li>
<li><code>Math.PI</code>：圆周率常量</li>
</ul>
</li>
</ul>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>继承是多态的前提，如果没有继承，就没有多态</li>
<li>主要解决的问题：共性抽取</li>
<li>子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类的非私有的属性和行为</li>
<li>父类：基类、超类</li>
<li>子类；派生类<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4></li>
<li>子类与父类的关系：<code>is-a</code></li>
<li><p>父类：(一个普通的类定义)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 父类名称</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名称 <span class="keyword">extends</span> 父类名称</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li>父类无法使用子类成员变量</li>
<li>子类仅可以直接访问父类的非私有成员变量</li>
<li>成员变成重名：<ul>
<li>直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找</li>
<li>间接通过成员方法访问成员变量：方法属于谁就优先用谁，没有则向上找</li>
</ul>
</li>
<li>三种变量重名：<ul>
<li>局部变量：直接写成员变量名</li>
<li>本类的成员变量：this.成员变量名</li>
<li>父类的成员变量：super.成员变量名</li>
</ul>
</li>
</ul>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li>成员方法不重名：正常使用</li>
<li>成员方法重名：创建的对象是谁，优先用谁的方法</li>
<li>注意：无论是成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找子类</li>
</ul>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ul>
<li>重写(Override)【覆盖】：在继承关系当中，方法的名称一样，参数列表也一样</li>
<li>对比：<ul>
<li>重载：Overload：方法名称相同，参数列表不同</li>
<li>重写：Override：方法名称相同，参数列表也相同–覆盖</li>
</ul>
</li>
<li>特点：创建的是子类对象，则优先使用子类方法</li>
<li>注意：<ol>
<li>必须保证父子类之间的<strong>方法名称</strong>相同，<strong>参数列表</strong>也相同<blockquote>
<p>@Override // 写在方法前面，用来检测是不是有效的正确的覆盖重写（注解）</p>
<pre><code>// 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写   
</code></pre></blockquote>
</li>
</ol>
</li>
</ul>
<pre><code>2. 子类方法的返回值必须**小于等于**父类方法的返回值范围
    &gt; `java.lang.Object`类是所有类的公共最高父类，java.lang.String就是Object的子类

3. 子类方法的权限必须**大于等于**父类方法的权限修饰符
    &gt; public &gt; protected &gt; (default)(不写) &gt; private
</code></pre><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>继承关系中，父子类构造方法的访问特点；<ol>
<li>子类构造方法当中有一个默认隐含的<code>super()</code>调用，所以一定是先调用父类构造，后执行子类的构造</li>
<li>子类构造可以通过<code>super</code>关键字来调用父类重载构造</li>
<li><code>super</code>的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造</li>
</ol>
</li>
</ul>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ul>
<li>在子类的成员方法中，访问父类的成员变量：<code>super.变量名</code></li>
<li>在子类的成员方法中，访问父类的成员方法：<code>super.方法名</code></li>
<li>在子类的构造方法中，访问父类的构造方法：<code>super();</code></li>
</ul>
<h4 id="继承的特征"><a href="#继承的特征" class="headerlink" title="继承的特征"></a>继承的特征</h4><ul>
<li>Java语言是<code>单继承</code>的，一个类的直接父类只能有一个</li>
<li>Java语言可以<code>多级继承</code>（继承体系），顶层都是Object类</li>
<li>一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类 </li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>没有方法主体的方法称为抽象方法，包含抽象方法的类，必须是抽象类<ul>
<li>抽象类：包含抽象方法的类</li>
<li>抽象方法：没有方法体的方法，加上abstract关键字，去掉方法体，分号结束</li>
</ul>
</li>
</ul>
<h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><ul>
<li>抽象方法：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰符 abstract 返回值类型 方法名(参数列表);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>不能直接创建new抽象类对象</li>
<li>必须用子类继承抽象父类</li>
<li>子类必须覆盖重写抽象父类所有的抽象方法</li>
<li>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>，否则该子类也必须声明为抽象类，最终必须要有子类实现该父类的抽象方法，否则抽象父类到子类的创建全部失效，失去意义</li>
</ul>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><ul>
<li>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象</li>
<li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类一定是抽象类</li>
<li>抽象类的子类，必须重写抽象父类所有的抽象方法，否则，编译无法通过报错，除非该子类也是抽象类</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul>
<li>接口就是一种公共的规范标准</li>
<li>接口是一种引用数据类型（数组、类、接口）</li>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备注：换成关键字interface之后，编译生成的字节码文件仍然是：.java-&gt;.class</p>
</li>
</ul>
<h4 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h4><ul>
<li>java7：<ol>
<li>常量</li>
<li>抽象方法</li>
</ol>
</li>
<li>java8:<ol start="3">
<li>默认方法</li>
<li>静态方法</li>
</ol>
</li>
<li>java9<ol start="5">
<li>私有方法</li>
</ol>
</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>接口不能直接使用，必须有一个“实现类”来“实现”接口</p>
<ul>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>接口的实现类必须覆盖重写（实现）接口中<strong>所有</strong>的抽象方法（否则它必须是一个抽象类）</p>
<ul>
<li>实现：去掉abstract关键字，加上方法体和大括号</li>
</ul>
</li>
<li>创建实现类的对象，进行使用</li>
</ul>
<h4 id="接口的抽象方法"><a href="#接口的抽象方法" class="headerlink" title="接口的抽象方法"></a>接口的抽象方法</h4><ul>
<li>注意：<ol>
<li>接口当中的抽象方法，修饰符必须是两个固定关键字：<code>public abstract</code></li>
<li>这两个关键字修饰符，可以选择性省略</li>
<li>方法的三要素，可以随意定义</li>
</ol>
</li>
</ul>
<h4 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h4><ul>
<li>从Java8开始，可以使用默认方法，默认方法可以被实现类继承</li>
<li>作用：解决接口升级的问题（实现类可以重写默认方法）</li>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h4><ul>
<li>从Java8开始，接口当中允许定义静态方法</li>
<li>静态与.class文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：不能通过接口实现类的对象来调用当中的静态方法</p>
</li>
<li>正确用法：通过接口名称，直接调用其中的静态方法。</li>
<li>格式：<code>接口名称.静态方法名称(参数)</code></li>
</ul>
<h4 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h4><ul>
<li>我们需要抽取一个共有方法，用来解决多个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。</li>
<li><p>从Java9开始，接口当中允许定义私有方法</p>
<ol>
<li><p>普通私有方法：解决多个默认方法之间重复代码问题<br> 格式：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态私有方法：解决多个静态方法之间重复代码问题</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="接口的成员变量（常量）"><a href="#接口的成员变量（常量）" class="headerlink" title="接口的成员变量（常量）"></a>接口的成员变量（常量）</h4><ul>
<li>接口中可以定义“成员变量”，但是必须使用<code>public static final</code>三个关键字进行修饰。从效果上看，这其实就是接口的【常量】</li>
<li>格式：<br>  <code>public static final 数据类型 常量名称 = 数据值;</code></li>
<li>一旦使用<code>final</code>关键字进行修饰，说明不可改变</li>
<li>注意：<ul>
<li>接口当中的常量，可以省略<code>public static final</code></li>
<li>接口当中的常量，必须进行赋值，不能不赋值</li>
<li>接口中，常量的名称，使用完全大写的字母，用下划线进行分隔(shift+F6)</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>在java9+版本中，接口的内容可以有</p>
<ol>
<li><p>成员变量其实是常量，格式：<code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></p>
<ul>
<li>注意：<ul>
<li>常量必须进行赋值，而且一旦赋值不能改变</li>
<li>常量名称完全大写，用下划线进行分隔</li>
</ul>
</li>
</ul>
</li>
<li><p>接口中最重要的就是抽象方法，格式：<br> <code>[public] [abstract] 返回值类型 方法名称(参数列表)</code></p>
<ul>
<li>注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类</li>
</ul>
</li>
<li><p>从Java8开始，接口里允许定义默认方法，格式：<code>[public] default 返回值类型 方法名称(参数列表){方法体}</code></p>
<ul>
<li>注意：默认方法也可以被覆盖重写</li>
</ul>
</li>
<li><p>从Java8开始，接口里允许定义静态方法，格式：<code>[public] static 返回值类型 方法名称(参数列表){方法体}</code></p>
<ul>
<li>注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li>
</ul>
</li>
<li><p>从Java9开始，接口里允许定义私有方法，格式：</p>
<ul>
<li><code>private 返回值类型 方法名称(参数列表){方法体}</code></li>
<li><code>private static 返回值类型 方法名称(参数列表){方法体}</code><ul>
<li>注意：private方法只有接口自己才能调用，不能被实现类或别人使用</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><ul>
<li>接口不能有静态代码块</li>
<li>接口不能有构造方法</li>
<li><p>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口</p>
<ul>
<li>格式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">implements</span> 接口<span class="title">A</span>,接口<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p>
</li>
<li>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类</li>
<li>如果实现类所实现的多个接口，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</li>
<li>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法（父类&gt;&gt;接口）</li>
</ul>
<h4 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h4><ul>
<li>类与类之间是单继承的，直接父类只能有一个</li>
<li>类与接口之间是多实现的，一个类可以实现多个接口</li>
<li>接口与接口之间是多继承的</li>
<li>使用：关键字<code>extends</code></li>
<li>注意<ul>
<li>多个父接口当中的抽象方法如果有重复，没关系</li>
<li>多个父接口当中的默认方法如果有重复，那么子接口必须进行默认方法的覆盖重写，【而且要带着<code>default</code>关键字】</li>
<li>实现类重写接口默认方法，不需要保留<code>default</code>关键字</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>多态性：一个对象拥有多种形态</li>
<li>代码当中体现多态性：<code>【父类引用指向子类对象】</code><blockquote>
<ul>
<li>格式：</li>
<li>父类名称 对象名 = new 子类名称();</li>
<li>或者</li>
<li>接口名称 对象名 = new 实现类名();</li>
</ul>
</blockquote>
</li>
<li>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误，如果有，执行的是子类重写后方法</li>
</ul>
<h4 id="多态中的成员变量"><a href="#多态中的成员变量" class="headerlink" title="多态中的成员变量"></a>多态中的成员变量</h4><ul>
<li>直接通过对象名访问成员变量：看等号左边是谁，优先用谁，没有则向上找。</li>
<li>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</li>
</ul>
<h4 id="多态中的成员方法"><a href="#多态中的成员方法" class="headerlink" title="多态中的成员方法"></a>多态中的成员方法</h4><ul>
<li>new的是谁，就优先用谁，没有则向上找</li>
<li>注意：<ul>
<li>成员方法：编译看左，运行看右</li>
<li>成员变量：编译看左，运行看左</li>
</ul>
</li>
</ul>
<h4 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h4><ul>
<li>方法调用相同（编译时），用谁找谁（运行时），动态过程</li>
</ul>
<h4 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h4><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><ul>
<li>向上转型：多态本身是子类类型向父类类型向上转型的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型</li>
<li>格式：<code>父类名称 对象名 = new 子类名称();</code></li>
<li>注意：向上转型一定是安全的。从小范围–&gt;大范围</li>
<li>缺陷：无法调用子类特有的内容</li>
</ul>
<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><ul>
<li>向下转型：父类类型向子类类型向下转型的过程(还原)，这个过程是强制的</li>
<li>格式：<code>子类名称 对象名 = (子类名称)父类对象;</code></li>
<li>含义：将父类对象，还原成原本的子类对象</li>
<li>注意：<ol>
<li>要还原的对象必须是原来创建的对象，才能向下转型</li>
<li>要还原的对象如果不是原来创建的对象，而是其他对象，就会报错（运行异常，ClassCastException）</li>
</ol>
</li>
</ul>
<h5 id="instance-of关键字"><a href="#instance-of关键字" class="headerlink" title="instance of关键字"></a>instance of关键字</h5><ul>
<li>作用：返回一个boolean值，判断前面的对象能不能当作后面类型的实例</li>
<li>格式：<code>变量名 instance of 数据类型</code></li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>含义：代表最终、不可改变的</li>
<li>使用：<ol>
<li>修饰一个类，不能被继承</li>
<li>修饰一个方法，不能被重写</li>
<li>修饰一个局部变量，不能被重新赋值</li>
<li>修饰一个成员变量，不能被重新赋值</li>
</ol>
</li>
</ul>
<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名称()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：当前这个类不能有任何的子类（final类不能作为父类）</p>
</li>
<li>注意：final类的所有成员方法都无法进行覆盖重写</li>
</ul>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> 返回值 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：当前方法就是最终方法，不能再被覆盖重写</p>
</li>
<li>注意：对于类、方法来说，<code>abstract</code>关键字和<code>final</code>关键字不能同时使用，因为矛盾</li>
</ul>
<h4 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h4><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 数据类型 数据名 = 数据值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：当前局部变量，不能进行更改，一次赋值，终生不变 </p>
</li>
<li>注意：对于基本类型，不可变说的是变量当中的数据不可变；对于引用类型来说，不可变说的是变量当中的地址值不可变</li>
</ul>
<h4 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h4><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 数据类型 数据名 = 数据值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：当前成员变量，不能进行更改，但成员变量有默认值，用了final后必须进行手动赋值</p>
</li>
<li>注意：<ol>
<li>对于final的成员变量，要么使用直接赋值，要么使用构造方法赋值（二选一）</li>
<li>必须保证类当中所有重载构造方法，都最终会对final的成员变量进行赋值</li>
</ol>
</li>
</ul>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>同一个包</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>不同包子类</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li>定义：将一个类A定义在另一个类B里面，A被称为<code>内部类</code>，B被称为<code>外部类</code></li>
<li><p>成员内部类：定义在类中方法外的类</p>
</li>
<li><p>分类：</p>
<ol>
<li>成员内部类</li>
<li>局部内部类(包含匿名内部类)</li>
</ol>
</li>
<li>注意：内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和<code>$符号</code>。比如，Person$Heart.class</li>
</ul>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>定义在一个类内成员方法外的类</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称</span>&#123;</span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 内部类名称</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：</p>
<ol>
<li>直接：<code>外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称()</code></li>
<li>间接：在外部类的方法中，使用内部类：然后main只是调用外部类的方法</li>
</ol>
</li>
<li><p>注意；</p>
<ul>
<li>内用外，随意访问，外用内，需要内部类对象</li>
<li>同名变量访问：（重名）<code>外部类名称.this.外部类成员变量名</code></li>
</ul>
</li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul>
<li>定义在一个方法内部的类，“局部”：只有当前所属方法才能使用，出了方法无法使用</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称</span>&#123;</span><br><span class="line">    修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 局部内部类名称</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：方法内创建局部类对象，main直接调用外部类方法</p>
</li>
<li>注意：权限修饰符<ol>
<li>外部类：public/(default)</li>
<li>成员内部类：public / protected / (default) / private</li>
<li>局部内部类：无法使用修饰符</li>
</ol>
</li>
</ul>
<h5 id="局部内部类的final问题"><a href="#局部内部类的final问题" class="headerlink" title="局部内部类的final问题"></a>局部内部类的final问题</h5><ul>
<li>局部内部类，如果希望访问所在方法的局部变量，那么这份局部变量必须是<code>有效final的</code>(从Java8开始，只要局部变量事实不变，那么final关键字可以省略)</li>
<li>原因：<ol>
<li>new出来的对象在堆内存当中</li>
<li>局部变量是跟着方法走到，在栈内存中</li>
<li>方法运行结束之后，立刻出栈，局部变量就会立刻消失</li>
<li>new出来的对象会在堆中持续存在，直到垃圾回收消失</li>
</ol>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li><p>如果接口的实现类(或者是父类的子类)，只需要使用唯一的一次，那么这种情况就可以省略掉该类的定义，改用<code>匿名内部类</code></p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称()&#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对”new 接口名称(){…};”解析:</p>
<ol>
<li>new代表创建对象的动作</li>
<li>接口名称就是匿名内部类需要实现哪个接口</li>
<li>{…}这才是匿名内部类的内容</li>
</ol>
</li>
<li>注意：<ol>
<li>匿名内部类，在<strong>创建对象</strong>的时候，只能使用唯一一次，如果希望多次创建对象，而且内容一样，那么就必须使用单独的实现类</li>
<li>匿名对象，在<strong>调用方法</strong>的时候，只能调用一次，如果希望同一个对象，调用多次方法，必须要给对象取名</li>
<li>匿名内部类省略了<strong>实现类/子类</strong>，匿名对象省略了<strong>对象名称</strong></li>
<li>匿名内部类和匿名对象不是一回事</li>
</ol>
</li>
</ul>
<h3 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API-2"></a>常用API-2</h3><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><ul>
<li>类Object是类层次结构的根(父)类。每个类都使用Object作为超(父)类，所有对象（包括数组）都实现这个类的方法</li>
<li>导包：<code>java.lang.Object</code></li>
<li>使用<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象”相等”</li>
</ul>
</li>
</ul>
<h5 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h5><ul>
<li>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值</li>
<li>直接打印对象的名字，其实就是调用对象的toString</li>
<li>覆盖重写<ul>
<li>在IDEA中，可以使用alt+insert，点击toString()</li>
</ul>
</li>
<li>看一个类是否重写了toString,直接打印这个类的对象即可，如果没有重写toString方法，那么打印的是对象的地址值<h5 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h5></li>
<li>如果没有重写equals方法，默认比较对象的地址值，如果需要比较内容，需要覆盖重写</li>
<li>参数：<ol>
<li>Object obj：可以传递任意的对象</li>
<li>this ；调用的对象</li>
<li>obj ；参数</li>
</ol>
</li>
<li>基本数据类型：比较地址值</li>
<li>引用数据类型；比较对象的地址值</li>
<li>覆盖重写：<ul>
<li>问题：隐含一个多态，无法使用子类特有的内容（属性和方法）</li>
<li>解决：向下转型（强转）</li>
<li>alt+insert ,equals() and hashCode()</li>
</ul>
</li>
</ul>
<h5 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h5><ul>
<li>JDK7中添加的工具类，其中的方法是null-save(空指针安全)或null-tolerant(容忍空指针)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象</li>
<li>Objects.equals方法：防止出现空指针异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a==b)||(a!=<span class="keyword">null</span>&amp;&amp;a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><ul>
<li>表示特定的瞬间，精确到毫秒（千分之一秒  1000毫秒=1秒）</li>
<li>毫秒值的作用：可以对时间和日期进行计算（0毫秒：1970年1月1日 00:00:00）</li>
<li>中国属于东八区，会把时间+8小时</li>
<li>导包：<code>java.util.Date</code><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5></li>
<li>public Date()：获取当前系统的日期和时间</li>
<li>public Date(Long date):传递毫秒值，把毫秒值转换为Date日期<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5></li>
<li>public long getTime():把日期转换为毫秒值(相当于System.currentTimeMillis()方法)，返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数<h5 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h5></li>
<li>定义：日期/时间格式化子类的抽象类，可以实现日期和文不之间的转换（Date-&gt;String）</li>
<li>作用：格式化（日期-&gt;文本）、解析（文本-&gt;日期）</li>
<li>导包：<code>java.text.DateFormat</code></li>
<li>成员方法：<ol>
<li>String format(Date date)：按照指定的模式，把Date日期，格式化为符合模式的字符串</li>
<li>Date parse(String source)：把符合模式的字符串，解析(parse)为Date日期</li>
</ol>
</li>
<li><p>DateFormat是抽象类，无法之间创建对象使用，可以使用DateFormat的子类（SimpleDateFormat）</p>
<blockquote>
<p>parse方法声明了一个异常叫ParseException，如果字符串和构造方法的模式不一样，那么程序就会抛出此异常，调用一个抛出了异常的方法，就必须处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理</p>
</blockquote>
</li>
<li><p><code>SimpleDateFormat</code>:</p>
<ul>
<li><code>java.text.SimpleDateFormat extends DateFormat</code></li>
<li>构造方法：SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造</li>
<li>注意：模式中的字母不能更改，连接模式的符号可以改</li>
</ul>
</li>
</ul>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><ul>
<li>本身是抽象类，已知子类<code>GregorianCalendar</code>，提供了很多操作日历字段的方法(YEAR\MONTH\DAT_OF_MONTH\HOUR)</li>
<li>Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance()，此方法返回了Calendar类的子类对象</li>
<li>static Calendar getInstance() 使用默认时区和语言环境获得一个日历<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4></li>
<li><code>public int get(int field)</code>：返回给定日历字段的值</li>
<li><code>public void set(int field, int value)</code>；将给定的日历字段设置为给定值</li>
<li><code>public abstract void add(int field, int amount)</code>；根据日历的规则，为给定的日历字段添加或减去指定的时间量</li>
<li><code>public Date getTime()</code>；返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象</li>
<li>注意；int field；日历类的字段，可以使用Calendar类的静态成员变量获取</li>
</ul>
<h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><ul>
<li>导包：<code>java.lang.System</code></li>
<li>获取与系统相关的信息或系统级操作<h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h5></li>
<li><code>public static long currentTimeMillis()</code>；返回以毫秒为单位的当前时间</li>
<li><code>public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length)</code>；将数组中指定的数据拷贝到另一个数组中</li>
</ul>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><ul>
<li>字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），底层也是一个数组，但是没有final修饰，可以改成长度</li>
<li>在内存中始终是一个数组，占用空间少（byte[] value = new byte[16]），效率高，如果超出，自动扩容</li>
<li><code>java.lang.Builder</code><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5></li>
<li><code>StringBuilder()</code>；构造一个不带任何字符的字符串生成器，其初始容量为16个字符</li>
<li><code>StringBuilder(String str)</code>；构造一个字符串生成器，并初始化为指定的字符串内容<h5 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h5></li>
<li><code>public StringBuilder append(...)</code>；添加任意类型数据的字符串形式，并返回当前对象自身</li>
<li><code>public String toString()</code>；将当前StringBuilder对象转换为String对象<h5 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h5></li>
<li>String-&gt;StringBuilder；可以使用StringBuilder的构造方法</li>
<li>StringBuilder-&gt;String；可以使用StringBuilder的toString方法</li>
</ul>
<h4 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h4><ul>
<li>使用一个类，将基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类，我们可以使用类中的方法来操作这些基本类型的数据<h5 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h5></li>
<li><p>装箱；把基本类型的数据，包装到包装类中</p>
<ul>
<li>构造方法：<ol>
<li>Integer(int value)；构造一个新分配的Integer对象，它表示指定的int值</li>
<li>Integer(String s)；构造一个新分配的Integer对象，它表示String参数所指示的int值（注意：传递的字符串，必须是基本类型的字符串，否则会抛出异常‘100’正确，‘0’异常）</li>
</ol>
</li>
<li>静态方法<ol>
<li><code>static Integer valueOf(int i)</code>；返回一个表示指定的int值的Integer对象</li>
<li><code>static Integer valueOf(String s)</code>；返回保存指定的String的值的Integer对象</li>
</ol>
</li>
</ul>
</li>
<li><p>拆箱；在包装类中取出基本类型的数据</p>
<ul>
<li>成员方法；<code>int intvalue()</code>；以int类型返回该Integer值</li>
</ul>
</li>
</ul>
<h5 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h5><ul>
<li>基本类型的数据和包装类之间可以自动地相互转换（JDK1.5之后）</li>
</ul>
<h5 id="基本类型与字符串类型的转换"><a href="#基本类型与字符串类型的转换" class="headerlink" title="基本类型与字符串类型的转换"></a>基本类型与字符串类型的转换</h5><ul>
<li><p>基本类型-&gt;字符串；</p>
<ol>
<li>基本类型的值+””</li>
<li>包装类的静态方法toString(参数)，不是Object类的toString()方法，发生了重载</li>
<li>String类的静态方法valueOf(参数)</li>
</ol>
</li>
<li><p>字符串-&gt;基本类型；</p>
<ol>
<li>包装类的静态方法；parseXXX(“数值类型的字符串”)</li>
</ol>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>数组长度固定；集合长度可变</li>
<li>数组存储同一类型元素；集合只能存储对象，类型可以不一致</li>
</ul>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul>
<li><p>Collection接口；所有单列集合中共性的方法\所有的单列集合都可以使用共性的方法\没有索引的方法</p>
<ul>
<li><p>List接口；有序的集合（存储和取出元素顺序相同）\允许存储重复元素\有索引，可以使用普通的for循环遍历</p>
<ul>
<li>Vector集合</li>
<li>ArrayList集合</li>
<li>LinkedList集合</li>
</ul>
</li>
<li><p>Set接口；不允许存储重复元素\没有索引（不能使用普通的for循环遍历）</p>
<ul>
<li>TreeSet集合</li>
<li>HashSet集合<ul>
<li>LinkedHashSet集合(存取一致) </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h4><h5 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> ；清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>；把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>；判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>；判断当前集合是否为空。</li>
<li><code>public int size()</code>；返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>；把集合中的元素，存储到数组中。</li>
</ul>
<h4 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h4><ul>
<li>为了遍历集合中所有元素</li>
<li><code>java.util.Iterator</code></li>
</ul>
<h5 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h5><ul>
<li>迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
<li><p>常用方法；</p>
<ul>
<li><code>boolean hasNext()</code>；如果仍有元素可以迭代，返回true</li>
<li><code>E next()</code> ；返回迭代的下一个元素</li>
</ul>
</li>
<li><p>注意：Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象。Colletion接口中有一个方法，叫iterator()，返回的就是迭代器的实现类对象</p>
</li>
<li>使用步骤；<ol>
<li>使用集合中的方法<code>iterator()</code>获取迭代器的实现类对象，使用Iterator接口接收（多态），注意迭代器也有泛型，跟着集合走</li>
<li>使用Iterator接口中的方法hasNext判断还有没有下一个元素</li>
<li>使用Iterator接口中的方法next取出集合中的下一个元素</li>
</ol>
</li>
</ul>
<h5 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h5><ul>
<li>底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，jdk1.5之后</li>
<li><code>Collection&lt;E&gt;extends Iterable&lt;E&gt;</code>；所有的单列集合都可以使用增强for</li>
<li><p><code>public interface Iterable&lt;T&gt;</code>；实现这个接口允许对象成为”foreach”语句的目标</p>
</li>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合/数组的数据类型 变量名:集合名/数组名)&#123;</span><br><span class="line">    sout(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意；新for循环必须有被遍历的目标，目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现</p>
</li>
</ul>
<h4 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型(Generic)"></a>泛型(Generic)</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><ul>
<li>一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型</li>
<li>泛型可以看作是一个变量，用来接收数据类型</li>
<li>E e；Element元素</li>
<li>T t；Type类型</li>
<li>创建集合对象的时候，就会确定泛型的数据类型<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5></li>
<li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li>
<li>把运行期间异常<code>ClassCastException</code>，提升到了编译时期的编译失败</li>
<li>但是泛型是什么类型，只能存储什么类型的数据<h5 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h5></li>
<li><p>含有泛型的类</p>
<ul>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;泛型&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>含有泛型的方法</p>
<ul>
<li>格式；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line">修饰符 &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> &lt;泛型&gt; 返回值类型 方法名(泛型 参数名,...)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>含有泛型的接口</p>
<ul>
<li><p>格式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名&lt;泛型&gt;</span>&#123;</span><br><span class="line">    抽象方法(泛型 参数名,...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：</p>
<ol>
<li>定义类时确定泛型的类型</li>
<li>始终不确定泛型的类型，直到创建对象时，确定泛型的类型<h5 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h5></li>
</ol>
</li>
</ul>
</li>
<li>？；代表任意的数据类型</li>
<li>使用：<ul>
<li>不能创建对象使用</li>
<li>只能作为方法的<strong>参数</strong>使用</li>
</ul>
</li>
<li>注意：泛型不存在继承关系 Collection<object> list = new ArrayList<string>();这种是错误的。</string></object></li>
</ul>
<h5 id="泛型的上限限定"><a href="#泛型的上限限定" class="headerlink" title="泛型的上限限定"></a>泛型的上限限定</h5><ul>
<li><code>? extends E</code>；代表使用的泛型只能是E的子类/本身</li>
</ul>
<h5 id="泛型的下限限定"><a href="#泛型的下限限定" class="headerlink" title="泛型的下限限定"></a>泛型的下限限定</h5><ul>
<li><code>? super E</code>；代表使用的泛型只能是E类型的父类/本身</li>
</ul>
<h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><ul>
<li><code>java.util.List extends Collection</code></li>
<li>List接口继承Collection接口<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5></li>
<li>有序的集合，存储元素和取出元素的顺序是一致的</li>
<li>有索引，包含了一些带索引的方法</li>
<li>允许存储重复的元素<h5 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h5></li>
<li><code>public void add(int index, E element)</code>；将指定的元素，添加到该集合中的指定位置上</li>
<li><code>public E get(int index)</code>；返回集合中指定位置的元素</li>
<li><code>public E remove(int index)</code>；移除列表中指定位置的元素，返回的是被移除的元素</li>
<li><code>public E set(int index, E element)</code>；用指定元素替换集合中指定位置的元素，返回以前在指定位置的元素</li>
<li>注意：操作索引的时候，一定要防止索引越界异常<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5></li>
<li>ArrayList；List接口的数组实现，元素增删慢，查找快。此实现是不同步的（多线程）。</li>
<li>LinkedList；List接口的链表列表实现。元素添加快，查找慢。<ul>
<li>双向链表</li>
<li>含有大量操作首尾元素的方法，因此不要使用多态</li>
<li>常用方法：<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code> :返回此列表的第一个元素。</li>
<li><code>public E getLast()</code> :返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code> :移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code> :移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code> :从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code> :将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code> ：如果列表不包含元素，则返回true。</li>
</ul>
</li>
</ul>
</li>
<li>Vector；单线程，与ArrayList原理一样，已被ArrayList替代</li>
</ul>
<h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><ul>
<li><code>java.util.Set extends Collection</code></li>
<li>Set接口继承Collection接口<h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5></li>
<li><p>不允于存储重复的元素</p>
<blockquote>
<p>原理；add方法会调用元素的hashCode方法和equals方法，判断元素值是否重复(前提；存储的元素必须重写hashCode和equals方法)，哈希值不同，直接存入集合，哈希值相同，比较equals，true为相同值，不存入集合</p>
</blockquote>
</li>
<li><p>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</p>
<h5 id="子类-1"><a href="#子类-1" class="headerlink" title="子类"></a>子类</h5><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6></li>
<li>特点；<ol>
<li>由哈希表支持，不保证迭代顺序</li>
<li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li>
<li>底层是一个哈希表结构(查询速度快)</li>
</ol>
</li>
<li>哈希值；<ul>
<li>是一个十进制的整数，由系统随机给出(对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址)</li>
<li>在Object类中由一个方法，可以获取对象的哈希值；<code>int hashCode()</code></li>
<li>hashCode()；<code>public native int hashCode()</code>，native代表该方法调用的是本地操作系统的方法</li>
<li>String类的哈希值；String类重写了Object类的hashCode()方法（”重地和通话”哈希值相同）</li>
</ul>
</li>
<li>数据结构；<ul>
<li>哈希表；<ul>
<li>jdk1.8版本之前；哈希表= 数组+链表</li>
<li>jdk1.8版本之后；哈希表=数组+链表+红黑树（提高了查询速度）<ul>
<li>存储数据到集合中(先计算元素的哈希值)</li>
<li>把元素进行分组，相同哈希值链接到一起</li>
<li>哈希冲突：元素不同，哈希值相同</li>
<li>如果链表的长度超过8位，那么就会把链表转换为红黑树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>存储自定义类型元素<ul>
<li>重写hashCode和equals方法</li>
</ul>
</li>
</ul>
<h6 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h6><ul>
<li><code>java.util.LinkedHashSet extends HashSet</code>,继承父类HashSet</li>
<li>可预知迭代顺序的Set接口的哈希表和链接列表实现</li>
<li>底层是一个哈希表（数组+链表/红黑树）+链表；多了一条链表记录元素的存储顺序，保证元素有序</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li>JDK1.5之后出现的新特性</li>
<li>使用前提；当前方法的参数列表数据类型已经确定，但是参数的个数不确定，使用可变参数</li>
<li>格式；<code>修饰符 返回值类型 方法名(数据类型...变量名){}</code></li>
<li>原理；可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个,1,2…多个</li>
<li>注意；<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</li>
<li>终极写法；<code>(Object...obj)</code></li>
</ol>
</li>
</ul>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><ul>
<li><code>java.util.Collections</code>；集合工具类<h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5></li>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T...elements)</code>；往集合中添加一些元素</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>；打乱集合顺序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>；将集合中元素按照默认规则（升序）排序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list ,Comparetor&lt;? super T&gt;)</code>；将集合中元素按照指定规则排序</li>
<li>注意；<ul>
<li><code>sort(List&lt;T&gt; list)</code>被排序的集合里面存储的元素，必须实现Comparable接口，重写接口中的compareTo()定义排序规则</li>
<li>Comparable接口的排序规则；自己(this)-参数；升序</li>
</ul>
</li>
<li><code>Comparator</code>和<code>Comparable</code>的区别<ul>
<li>Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法</li>
<li>Comparator；找一个第三方的裁判</li>
<li>Comparator排序规则；o1-o2升序，o2-o1降序</li>
</ul>
</li>
</ul>
<h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><ul>
<li>java.util.Map&lt;k,v&gt;</li>
<li>特点；<ol>
<li>Map集合是一个双列集合，一个元素包含两个值(一个key,一个value)</li>
<li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li>
<li>Map集合中的元素，key是不允许重复的，value是可以重复的</li>
<li>Map集合中的元素，key和value是一一对应的</li>
</ol>
</li>
<li>和<code>Collection</code>的区别：<ol>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ol>
</li>
</ul>
<h5 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h5><ul>
<li><p><code>HashMap&lt;K,V&gt;</code>；</p>
<ol>
<li>HashMap底层是哈希表，查询速度快，元素的存储顺序不能保证一致</li>
<li>为了保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法</li>
<li>JDK1.8之前；数组+单向链表</li>
<li>JDK1.8之后；数组+单向链表/红黑树（链表的长度超过8时）</li>
</ol>
</li>
<li><p><code>LinkedHashMap&lt;K,V&gt;</code>；</p>
<ol>
<li>是HashMap的子类，底层是哈希表+链表</li>
<li>是一个有序的集合，存储元素和取出元素的顺序是一致的，需要重写hashCode()、equals()方法</li>
</ol>
</li>
<li><p>注意；Map接口中的集合都有两个泛型变量&lt;K,V&gt;，在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</li>
</ul>
<h5 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h5><ul>
<li><p><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</p>
<ul>
<li>返回值V:<ul>
<li>存储键值对的时候，key不重复，返回值V是null</li>
<li>存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</p>
<ul>
<li>返回值V:<ul>
<li>key存在，返回被删除的值</li>
<li>key不存在，返回null</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</p>
<ul>
<li>返回值V:<ul>
<li>key存在，返回对应value值</li>
<li>key不存在，返回null</li>
</ul>
</li>
</ul>
</li>
<li><p><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</p>
</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h5 id="Map遍历key找value方式"><a href="#Map遍历key找value方式" class="headerlink" title="Map遍历key找value方式"></a>Map遍历key找value方式</h5><ul>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keySet()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ul>
<h5 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h5><ul>
<li><code>Map.Entry&lt;K,V&gt;</code>；在Map接口中有一个内部接口<code>Entry</code></li>
<li>作用；当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键与值得映射关系）</li>
<li>Entry对象的常用方法；<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
</li>
</ul>
<h5 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h5><ul>
<li>Map集合保证Key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一</li>
</ul>
<h5 id="LinkedHashMap-lt-K-V-gt"><a href="#LinkedHashMap-lt-K-V-gt" class="headerlink" title="LinkedHashMap&lt;K,V&gt;"></a>LinkedHashMap&lt;K,V&gt;</h5><ul>
<li>LinkedHashMap&lt;K,V&gt;继承HashMap&lt;K,V&gt;</li>
<li>底层原理；哈希表+链表（记录顺序）</li>
</ul>
<h5 id="HashTable-lt-K-V-gt"><a href="#HashTable-lt-K-V-gt" class="headerlink" title="HashTable&lt;K,V&gt;"></a>HashTable&lt;K,V&gt;</h5><ul>
<li>底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢</li>
<li>HashTable不能存null值,null键</li>
<li>HashTable和Vector在jdk1.2之后被取代（HashMap,ArrayList）</li>
<li>HashTable的子类<code>Properties</code>依然在使用</li>
</ul>
<h4 id="JDK9对集合添加的优化"><a href="#JDK9对集合添加的优化" class="headerlink" title="JDK9对集合添加的优化"></a>JDK9对集合添加的优化</h4><ul>
<li>JDK9的新特性；<ul>
<li>List接口、Set接口、Map接口；增加了一个<code>静态方法of</code>，可以给集合一次性添加多个元素<ul>
<li>前提；集合中存储的元素的个数已经确定，不再改变</li>
</ul>
</li>
<li>注意；<ul>
<li>of方法值适用于List、Set、Map接口，不适用于接口的实现类</li>
<li>of方法的返回值是一个不能改变的集合，集合不能再使用add、put方法添加元素，会抛出异常</li>
<li>Set接口和Map接口再调用of方法的时候，不能有重复的元素，否则会抛出异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h4><ul>
<li>Debug调试程序；<ul>
<li>可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug</li>
</ul>
</li>
<li>使用方式；<ul>
<li>在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里）</li>
<li>右键，选择Debug执行程序</li>
</ul>
</li>
<li>执行程序；<ul>
<li>f8；逐行执行程序</li>
<li>f7；进入到方法中</li>
<li>shift+f8；跳出方法</li>
<li>f9；跳到下一个断点，如果没有下一个断点，那么就结束程序</li>
<li>ctrl+f2；退出Debug模式，停止程序</li>
<li>Console；切换到控制台</li>
</ul>
</li>
</ul>
<h3 id="异常与多线程"><a href="#异常与多线程" class="headerlink" title="异常与多线程"></a>异常与多线程</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>异常；程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止</li>
<li>异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象，Javac处理异常的方式是<code>中断处理</code><h5 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h5></li>
<li><code>Throwable</code>；<code>Java.lang.Throwable</code><ul>
<li><code>Error</code>；工程师无法处理，只能尽力避免</li>
<li><code>Exception</code>；编译期异常，由于使用不当导致，可以避免<ul>
<li><code>RuntimeException</code>；运行期异常,Java程序运行过程中出现的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ul>
<li>常用关键字；<code>try</code>,<code>catch</code>,<code>finally</code>,<code>throw</code>,<code>throws</code></li>
</ul>
<h6 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h6><ul>
<li>在指定的方法中抛出指定的异常</li>
<li>格式；<code>throw new xxxException(&quot;异常产生的原因&quot;)</code></li>
<li>注意；<ol>
<li>throw关键字必须写在方法内部</li>
<li>throw关键字后边new的对象必须是Exception或者Exception的子类对象</li>
<li>throw关键字抛出指定的异常对象，我们就必须处理这个异常对象</li>
<li>throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，(运行期异常)可以不处理，默认交给JVM处理（打印异常对象，中断程序）</li>
<li>throw关键字后边创建的是编译异常，我们就必须处理这个异常，要么<code>throw</code>,要么<code>try...catch</code></li>
</ol>
</li>
</ul>
<h6 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h6><ul>
<li>异常处理的第一种方式，交给别人处理</li>
<li>当方法内部抛出异常对象的时候，必须处理这个异常对象</li>
<li>可以使用<code>throws</code>关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理</li>
<li><p>格式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值 方法名(参数列表) <span class="keyword">throws</span> AAAException, BBBException...&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AAAException(<span class="string">"产生原因"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BBBException(<span class="string">"产生原因"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意；</p>
<ol>
<li><code>throws</code>关键字必须写在方法声明处</li>
<li><code>throws</code>关键字后边声明的异常必须是<code>Exception</code>或者是<code>Exception的子类</code></li>
<li>方法内部如果抛出了多个异常对象，那么<code>throws</code>后边必须也声明多个异常。（如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可）</li>
<li>调用了一个声明抛出异常的方法，我们就必须处理声明的异常。（要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM，要么<code>try...catch</code>自己处理异常）</li>
</ol>
</li>
</ul>
<h6 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h6><ul>
<li><p>格式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123; <span class="comment">//用来接收try中抛出的异常对象 </span></span><br><span class="line">    处理异常的代码（一般把异常信息记录到一个日志中）</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意；</p>
<ol>
<li>try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象</li>
<li>如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try…catch之后的代码</li>
<li>如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑</li>
</ol>
</li>
</ul>
<h5 id="Throwable常用方法"><a href="#Throwable常用方法" class="headerlink" title="Throwable常用方法"></a>Throwable常用方法</h5><ul>
<li><code>public void printStackTrace()</code>；打印异常的详细信息</li>
<li><code>public String getMessage()</code>；获取发生异常的原因</li>
<li><code>public String toString()</code>；获取异常的类型和异常描述信息（不用）</li>
</ul>
<h5 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h5><ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论是否出现异常都会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意；</p>
<ol>
<li><code>finally</code> 不能单独使用，必须和try一起使用</li>
<li><code>finally</code> 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源（IO）</li>
</ol>
</li>
</ul>
<h5 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h5><ul>
<li>多个异常使用捕获该如何处理<ol>
<li>多个异常分别处理</li>
<li>多个异常一次捕获，多次处理<blockquote>
<p>注意；一个try,多个catch,如果catch定义的异常变量，具有父子类的关系，子类的异常变量必须写在上面，否则会报错</p>
</blockquote>
</li>
<li>多个异常一次捕获（catch异常对象的父类），一次处理</li>
</ol>
</li>
<li>如果finally有return语句,永远返回finally中的结果,避免该情况</li>
<li>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</li>
<li>如果父类抛出了多个异常,子类重写父类方法时<ol>
<li>抛出和父类相同的异常</li>
<li>抛出父类异常的子类异常</li>
<li>不抛</li>
</ol>
</li>
<li>父类没有抛出异常，子类也不能抛出异常，如果出现异常，只能捕获处理，不可抛出</li>
</ul>
<h5 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h5><ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXException</span> <span class="keyword">extends</span> <span class="title">Exception</span>|<span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    添加一个空参数的构造方法</span><br><span class="line">    添加一个带异常信息的构造方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意；</p>
<ol>
<li>自定义异常类一般都是Exception结尾，说明该类是一个异常类</li>
<li>自定义异常类，必须的继承Exception或者RuntimeException</li>
<li>继承Exception；自定义的异常类是一个编译器异常，如果方法内抛出了编译器异常，必须处理这个异常，要么<strong>抛出</strong>要么<strong>捕获</strong></li>
<li>继承RuntimeException；自定义的异常类是一个运行期异常，无需处理，交给JVM（中断处理）</li>
</ol>
</li>
</ul>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h5><ul>
<li>并发；指两个或多个事件在同一个时间段内发生(交替执行)</li>
<li>并行；指两个或多个事件在同一时刻发(同时发生)<h5 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h5></li>
<li>进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li>
<li>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程<ul>
<li>线程调度；<ul>
<li>分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间</li>
<li>抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），<code>Java使用的是抢占式调度</code></li>
</ul>
</li>
<li>单线程程序：Java程序中只有一个线程</li>
<li>主线程：执行主（main）方法的线程<h5 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h5><h6 id="方式一：创建Thread类的子类"><a href="#方式一：创建Thread类的子类" class="headerlink" title="方式一：创建Thread类的子类"></a>方式一：创建Thread类的子类</h6></li>
</ul>
</li>
<li><code>java.lang.Thread</code>；描述线程的类，要实现多线程程序，必须继承Thread类</li>
<li>实现步骤：<ol>
<li>创建一个Thread子类</li>
<li>在Thread类的子类中重写Thread类中的<code>run</code>方法，设置线程任务（开启线程做什么）</li>
<li>创建Thread类的子类对象</li>
<li>调用Thread类中的方法<code>start()</code>方法，开启新的线程（开辟新的栈空间），执行<code>run</code>方法<h6 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h6></li>
</ol>
</li>
<li><code>java.lang.Runnable</code></li>
<li>实现步骤：<ol>
<li>创建一个<code>Runnable</code>接口的实现类</li>
<li>在实现类中重写<code>Runnable</code>接口的<code>run</code>方法，设置线程任务</li>
<li>创建一个<code>Runnable</code>接口的实现类对象</li>
<li>创建<code>Thread</code>类对象，构造方法中传递<code>Runnable</code>接口的实现类对象</li>
<li>调用<code>Thread</code>类中的<code>start</code>方法，开启新的线程执行<code>run</code>方法<h5 id="实现Runnable接口创建多线程的好处"><a href="#实现Runnable接口创建多线程的好处" class="headerlink" title="实现Runnable接口创建多线程的好处"></a>实现Runnable接口创建多线程的好处</h5></li>
</ol>
</li>
<li>避免了单继承的局限性<blockquote>
<p>一个类只能继承一个类，类继承了Thread类就不能继承其他的类，实现Runnable接口，还可以继承其他的类，实现其他的接口</p>
</blockquote>
</li>
<li>增强了程序的扩展性，降低了程序的耦合性（解耦）<blockquote>
<p>实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离(解耦)。实现类中，重写了run方法：用来设置线程任务；创建Thread类对象，调用start()方法：用来开启新线程</p>
</blockquote>
<h5 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h5></li>
<li>构造方法</li>
<li>常用方法<ul>
<li><code>public String getName()</code>；获取当前线程名称</li>
<li><code>public void start()</code>；导致此线程开始执行，Java虚拟机调用此线程的run方法</li>
<li><code>public void run()</code>；此线程要执行的任务在此处定义代码</li>
<li><code>public static Thread currentThread()</code>；返回当前正在执行的线程对象的引<br>用</li>
<li><code>public static void sleep(long millis)</code>；使当前正在执行的线程以指定的毫秒数暂停</li>
</ul>
</li>
<li>设置线程名称<ul>
<li>使用Thread类中的方法<code>void setName(String name)</code></li>
<li>创建一个带参数的构造方法，参数传递线程的名称，调用父类的带参构造方法（super(name)）,把线程名称传递给父类，让父类（Thread）给子线程改名字（<code>Thread(String name)</code>）</li>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。<h5 id="匿名内部类方式实现线程的创建"><a href="#匿名内部类方式实现线程的创建" class="headerlink" title="匿名内部类方式实现线程的创建"></a>匿名内部类方式实现线程的创建</h5></li>
</ul>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口（）&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    重写父类/接口中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 线程任务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><ul>
<li>当使用多线程访问同一资源的时候，多个线程对资源有写操作，就容易出现线程安全问题</li>
<li>Java提供了同步机制（Synchronized）解决<h5 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h5><h6 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h6></li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意；</p>
<ol>
<li>同步代码块中的锁对象，可以使用任意的对象</li>
<li>必须保证多个线程使用的锁对象是同一个</li>
<li>锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行，其他线程被阻塞（BLOCKED）</li>
<li>频繁的上锁、解锁会降低程序效率，但是提供程序安全性</li>
</ol>
</li>
</ul>
<h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h6><ul>
<li>使用<code>synchronized</code>修饰的方法，就叫同步方法</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> 返回值类型 方法名()&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法也会把方法内部打代码锁住</p>
<blockquote>
<p>同步锁是谁?对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
</li>
</ul>
<h6 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h6><ul>
<li><code>java.util.concurrent.locks.Lock</code></li>
<li>Lock 实现了比 synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象</li>
<li>创建对象<ul>
<li><code>Lock 锁名 = new ReentrantLock();</code></li>
</ul>
</li>
<li>常用方法；<ul>
<li><code>public void lock()</code> :加同步锁。</li>
<li><code>public void unlock()</code> :释放同步锁</li>
</ul>
</li>
</ul>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><ul>
<li><code>java.lang.Thread.State</code><h5 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h5>| <strong>线程状态</strong> | <strong>导致状态发生的条件</strong> |<br>|—|—|<br>|NEW(新建)|线程刚被创建，但是并未启动。还没调用start方法|<br>|Runnable(可运行)|线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于CPU|<br>|Blocked(锁阻塞)|当一个线程试图获取一个对象锁，而对象锁被其他的线程持有，则该线程进入Blocked状态；当线程持有锁时，该线程变成Runnable状态|<br>|Waiting(无限等待)|一个线程在等待另一个线程执行（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒|<br>|TimedWaiting(计时等待)|同waiting状态，有几个方法有超时参数，调用他们将进入TimeWaiting状态，这一状态将一致保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有：Thread.sleep(),Object.wait()|<br>|Teminated(被终止)|因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡|<h5 id="Timed-Waiting-计时等待"><a href="#Timed-Waiting-计时等待" class="headerlink" title="Timed Waiting 计时等待"></a>Timed Waiting 计时等待</h5></li>
<li>Thread.sleep(long m)；强制当前正在执行的线程休眠，线程进入Runnable/Blocked状态</li>
<li>锁对象.wait(long m)；在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程进入Runnable/Blocked状态</li>
<li>注意；sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。<h5 id="Blocked-锁阻塞"><a href="#Blocked-锁阻塞" class="headerlink" title="Blocked 锁阻塞"></a>Blocked 锁阻塞</h5></li>
<li>线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态<h5 id="Waiting-无限等待"><a href="#Waiting-无限等待" class="headerlink" title="Waiting 无限等待"></a>Waiting 无限等待</h5></li>
<li>等待唤醒<ul>
<li>只有锁对象才能调用<code>void wait()</code>和<code>void notify()</code>方法</li>
<li><code>void notifyAll()</code>；全部唤醒</li>
</ul>
</li>
</ul>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><h5 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h5><ul>
<li>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不同</li>
<li>多个线程并发执行，CPU默认随机切换线程，为了让他们有规律执行，需要进行协调通信</li>
<li>等待唤醒机制；使各个线程能有效利用资源<h5 id="等待唤醒机制-1"><a href="#等待唤醒机制-1" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h5></li>
<li>多个线程间的一种协作机制</li>
<li>wait/notify就是线程间的一种协作机制</li>
<li>等待唤醒中的方法：<ol>
<li>wait：线程不再活动，不再参与调度，进入wait set中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：选取所通知对象的 wait set中的一个线程释放</li>
<li>notifyAll；释放所通知对象的 wait set上的全部线程。</li>
</ol>
</li>
<li>注意：<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法</li>
</ol>
</li>
</ul>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li>线程池；可以容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源</li>
<li>优点；<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
</li>
</ul>
<h5 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h5><ul>
<li>jdk1.5之后提供</li>
<li><code>java.util.concurrent.Executors</code>；线程池的工厂类，用来生成线程池</li>
<li><p><code>Executors类</code>中的静态方法；</p>
<ul>
<li><p><code>static ExecutorService newFixedThreadPool(int nThreads)</code>创建一个可重用固定线程数的线程池</p>
<ul>
<li>参数；<code>int nThreads</code>；创建线程池中包含的线程数量</li>
<li>返回值；ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口接收)</li>
</ul>
</li>
<li><p><code>java.util.concurrent.ExecutorService</code>；线程池接口</p>
<ul>
<li>用来从线程池中获取线程，调用start()方法，执行线程任务</li>
<li>submit(Runnable task)提交一个Runnable任务用于执行</li>
</ul>
</li>
<li>关闭/销毁线程池的方法<ul>
<li>void shutdown()</li>
</ul>
</li>
</ul>
</li>
<li>线程池的使用步骤<ol>
<li>使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</li>
<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>
<li>调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
<li>调用ExecutorService中的方法shutdown销毁线程池（不建议执行）</li>
</ol>
</li>
</ul>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h5 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h5><ul>
<li>面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</li>
<li>函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程<h5 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h5></li>
<li>Java8</li>
<li>实现多线程：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名内部类实现多线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            线程任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式实现多线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;线程任务&#125;).start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Lambda表达式标准格式"><a href="#Lambda表达式标准格式" class="headerlink" title="Lambda表达式标准格式"></a>Lambda表达式标准格式</h5><ul>
<li>组成；<ol>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ol>
</li>
<li>格式；<ul>
<li><code>(参数列表)-&gt;{一些重写方法的代码}</code></li>
</ul>
</li>
<li>解释；<ul>
<li><code>()</code>；接口中抽象方法的参数列表，没有参数就空着，有参数就写处参数，多个参数用逗号分隔</li>
<li><code>-&gt;</code>；床底的意思，把参数传递给方法体{}</li>
<li><code>{}</code>；重写接口的抽象方法的方法体</li>
</ul>
</li>
</ul>
<h5 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h5><ul>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内有且仅有一个参，则小括号可以省略；</li>
<li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ul>
<h5 id="Lambda使用前提"><a href="#Lambda使用前提" class="headerlink" title="Lambda使用前提"></a>Lambda使用前提</h5><ul>
<li>使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一<br>时，才可以使用Lambda。</li>
</ul>
<ol start="2">
<li>使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为<strong>函数式接口</strong></p>
</blockquote>
</li>
</ol>
<h3 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h3><h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li><code>java.io.File</code>是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作</li>
<li>File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5></li>
<li><code>static String pathSeparator</code> ；与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 </li>
<li><code>static char pathSeparatorChar</code> ；与系统有关的路径分隔符。 </li>
<li><code>static String separator</code> ；与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 <blockquote>
<p>路径不要写死，win和分隔符不同<br>eg:<code>&quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a.txt&quot;</code></p>
</blockquote>
</li>
<li><code>static char separatorChar</code> ；与系统有关的默认名称分隔符。 <h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5></li>
<li>绝对路径；是一个完整的路径，以盘符开始的路径</li>
<li>相对路径；是一个简化的路径，相对指的是相对于当前项目的根目录</li>
<li>注意：<ol>
<li>路径不区分大小写</li>
<li>路径中的文件名称分隔符windows用的是反斜杠，但反斜杠是转义字符，所以两个反斜杠菜表示一个普通的反斜杠<h5 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h5></li>
</ol>
</li>
<li><code>public File(String pathname)</code> ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。<blockquote>
<p>String pathname：字符串的路径名称</p>
</blockquote>
</li>
<li><code>public File(String parent, String child)</code> ：从父路径名字符串和子路径名字符串创建新的File实例。<blockquote>
<p>String parent 父路径，String child 子路径</p>
</blockquote>
</li>
<li><code>public File(File parent, String child)</code> ：从父抽象路径名和子路径名字符串创建新的File实例。<blockquote>
<p>File parent 父路径是File类，可以使用一些方法，String child</p>
</blockquote>
</li>
<li><p>注意；</p>
<ul>
<li>路径可以是文件结尾，也可以是文件夹结尾</li>
<li>路径可以是相对路径，也可以是绝对路径</li>
<li>路径可以是不存在的</li>
<li>创建File对象，只是把字符串路径封装成File对象，不考虑路径的真实情况<h5 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h5></li>
</ul>
</li>
<li><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</li>
<li><code>public String getPath()</code> ：将此File转换为路径名字符串。</li>
<li><code>public String getName()</code> ：返回由此File表示的文件或目录的名称。</li>
<li><code>public long length()</code> ：返回由此File表示的文件的长度。不存在，返回0。<h5 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h5></li>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。<h5 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h5></li>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。<blockquote>
<ul>
<li>文件不存在，创建文件，返回true,文件存在，创建失败，返回false</li>
<li>创建文件的路径必须存在，否则会抛出异常（IOException）</li>
</ul>
</blockquote>
</li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。(单级)<blockquote>
<p>只会创建目录，与名称是否存在后缀无关</p>
</blockquote>
</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录（多级）</li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。<blockquote>
<ul>
<li>删除成功，返回true,文件夹中有内容，不会删除，返回flase，构造方法中路径不存在，返回false</li>
<li>delete方法是直接在硬盘删除文件/文件夹，不走回收站，需要谨慎</li>
</ul>
</blockquote>
<h5 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h5></li>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。<blockquote>
<ul>
<li>list方法和listFiles方法遍历的是构造方法中给出的目录</li>
<li>如果构造方法中给出的目录的路径不存在，会抛出空指针异常</li>
<li>如果构造方法中给出的路径不是一个目录，也会抛出空指针异常</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h5><h6 id="FileFilter"><a href="#FileFilter" class="headerlink" title="FileFilter"></a>FileFilter</h6><ul>
<li><code>java.io.FileFilter</code>接口；用于抽象路径名（File对象）的过滤器</li>
<li>作用；用来过滤文件（File对象）</li>
<li>抽象方法；用来过滤文件的方法<ul>
<li><code>boolean accept(File pathname)</code>；测试指定抽象路径名是否应该包含在某个路径名列表中<h6 id="FilenameFilter"><a href="#FilenameFilter" class="headerlink" title="FilenameFilter"></a>FilenameFilter</h6></li>
</ul>
</li>
<li><code>java.io.FilenameFilter</code>接口；实现此接口的类实例可用于过滤文件名</li>
<li>作用；用于过滤文件名</li>
<li>抽象方法；用来过滤文件的方法<ul>
<li><code>boolean accept(File dir, String name)</code>；测试指定文件是否应该包含在某一文件列表中<blockquote>
<p>参数；</p>
<ul>
<li>File dir；构造方法中传递的被遍历的目录</li>
<li>String name；使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>注意；两个过滤器接口没有实现类，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤规则</li>
</ul>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><h5 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h5><ul>
<li>数据流向：<ul>
<li>输入流 ：把数据从<strong>其他设备</strong>上读取到<strong>内存</strong>中的流。</li>
<li>输出流 ：把数据从<strong>内存</strong>中写出到<strong>其他设备</strong>上的流。</li>
</ul>
</li>
<li>数据类型；<ul>
<li>字节流 ：以字节为单位，读写数据的流。</li>
<li>字符流 ：以字符为单位，读写数据的流。<blockquote>
<p>1字符=2字节 1字节=8位</p>
</blockquote>
</li>
</ul>
</li>
<li><p>顶级父类：</p>
<p>  ||输入流|输出流|<br>  |—|—|—|<br>  |<strong>字节流</strong>|字节输入流<br><code>InputStream</code>|字节输出流<br><code>OutputStream</code>|<br>  |<strong>字符流</strong>|字符输入流<br><code>Reader</code>|字符输出流<br><code>Writer</code>|</p>
</li>
</ul>
<h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><h6 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h6><ul>
<li><code>java.io.OutputStream</code>；抽象类表示字节输出流的所有类的超类</li>
<li>常用方法；<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。<blockquote>
<p>注意；当完成流的操作时，必须调用此方法，释放系统资源</p>
</blockquote>
</li>
<li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li>
<li><code>public void write(byte[] b)</code> ：将 b.length字节从指定的字节数组写入此输出流（以二进制存入）。<blockquote>
<ul>
<li>如果写的第一个字节是正数（0-127）,那么显示的时候会查询ASCII表</li>
<li>如果写的第一个字节是负数，那第一个字节回合第二个字节，两个字节组成一个中文显示，查询系统默认码表（GBK）</li>
</ul>
</blockquote>
</li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。</li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
</li>
<li><code>FileOutputStream类</code>：<ul>
<li>构造方法：<ul>
<li><code>public FileOutputStream(File file)</code> ：创建文件输出流以写入由指定的 File对象表示的文件。</li>
<li><code>public FileOutputStream(String name)</code> ： 创建文件输出流以指定的名称写入文件。<blockquote>
<p>注意；当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
</blockquote>
<h6 id="写入数据的原理"><a href="#写入数据的原理" class="headerlink" title="写入数据的原理"></a>写入数据的原理</h6></li>
</ul>
</li>
</ul>
</li>
<li>内存–&gt;硬盘</li>
<li>Java抽象–&gt;JVM–&gt;OS–&gt;OS调用写数据的方法–&gt;把数据写入到文件中<h6 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h6></li>
<li><code>public FileOutputStream(File file, boolean append)</code> ： 创建文件输出流以写入由指定的 File对象表示的<br>文件。</li>
<li><code>public FileOutputStream(String name, boolean append)</code> ： 创建文件输出流以指定的名称写入文件<blockquote>
<p>boolean append:追加写开关</p>
<ul>
<li>true：创建对象不会覆盖原文件，继续在文件的末尾追加写数据</li>
<li>false；创建一个新文件，覆盖源文件</li>
</ul>
</blockquote>
<h6 id="换行写"><a href="#换行写" class="headerlink" title="换行写"></a>换行写</h6></li>
<li>Windows系统里，换行符号是<code>\r\n</code></li>
</ul>
<hr>
<h6 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h6><ul>
<li><code>java.io.InputStream</code>；抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中</li>
<li>常用方法；<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li>
<li><code>public abstract int read()</code> ： 从输入流读取数据的下一个<code>字节</code>。</li>
<li><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。<blockquote>
<ul>
<li>byte[]；起到缓冲作用，存储每次读取到的多个字节，一般定义为1024(1kb)或1024的整数倍</li>
<li>返回值int ；每次读取的有效字节个数</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><code>FileInputStream类</code><ul>
<li><code>java.io.FileInputStream</code>；从文件中读取字节</li>
<li>构造方法；<ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</li>
<li><code>FileInputStream(String name)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。<h6 id="读取数据的原理"><a href="#读取数据的原理" class="headerlink" title="读取数据的原理"></a>读取数据的原理</h6></li>
</ul>
</li>
</ul>
</li>
<li>硬盘-&gt;内存</li>
<li>java程序-&gt;JVM-&gt;OS-&gt;OS读取数据的方法-&gt;读取文件<h6 id="关于中文"><a href="#关于中文" class="headerlink" title="关于中文"></a>关于中文</h6></li>
<li>1个中文：<ul>
<li>GBK；占用2个字节</li>
<li>UTF-8；占用3个字节</li>
</ul>
</li>
</ul>
<h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><h6 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h6><ul>
<li><code>java.io.Writer</code>；</li>
<li>常用方法：<ul>
<li><code>void write(int c)</code> 写入单个字符。void write(char[] cbuf) 写入字符数组。- abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</li>
<li><code>void write(String str)</code> 写入字符串。</li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush()</code> 刷新该流的缓冲。void close() 关闭此流，但要先刷新它。</li>
</ul>
</li>
<li><code>FileWriter extends OutputStreamWriter extends Writer</code>；<ul>
<li>构造方法；<ul>
<li><code>FileWriter(File file)</code> ： 创建一个新的 FileWriter，给定要读取的File对象。</li>
<li><code>FileWriter(String fileName)</code> ： 创建一个新的 FileWriter，给定要读取的文件的名称</li>
</ul>
</li>
<li>使用步骤；<ol>
<li>创建FileWriter对象，构造方法中绑定要写入数据的目的地</li>
<li>使用FileWriter中的方法write，把数据写入到内存缓冲区中（字符转字节的过程）</li>
<li>使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中</li>
<li>释放资源(会先把内存缓冲区的数据刷新到文件中)</li>
</ol>
</li>
</ul>
</li>
</ul>
<h6 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h6><ul>
<li><code>java.io.Reader</code>；抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。</li>
<li>常用方法：<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li>
<li><code>public int read()</code> ： 从输入流读取一个字符。</li>
<li><code>public int read(char[] cbuf)</code> ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中</li>
</ul>
</li>
<li><p><code>FileReader类 extends InputStreamReader extends Reader</code>；</p>
<ul>
<li>构造方法：<ul>
<li><code>FileReader(File file)</code> ： 创建一个新的 FileReader ，给定要读取的File对象。</li>
<li><code>FileReader(String fileName)</code> ： 创建一个新的 FileReader ，给定要读取的文件的名称</li>
</ul>
</li>
<li>使用方法；<ol>
<li>创建FileReader对象，构造方法中绑定要读取的数据源</li>
<li>使用FileReader对象中的方法read读取文件</li>
<li>释放资源</li>
</ol>
</li>
</ul>
</li>
<li><p>flush和close</p>
<ul>
<li>flush ：刷新缓冲区，流对象可以继续使用。</li>
<li>close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
</li>
</ul>
<h6 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h6><ul>
<li>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流<h6 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h6></li>
<li><p>jdk1.7之前使用try…catch finally处理流中的异常</p>
<ul>
<li>格式；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能产生出异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    一定会执行的代码</span><br><span class="line">    (资源释放)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK7新特性：在try的后边可以增加一个(),在括号中可以定义流对象，那么这个流对象的作用域就在try中有效。try中的代码执行完毕，会自动把流对象释放，不用写finally</p>
<ul>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(定义流对象;定义流对象;...)&#123;</span><br><span class="line">    可能产生出异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK9新特性；try的前面可以定义流对象，try后边的()中可以直接引入流对象的每次（变量名），在try代码执行完毕只会，流对象可以自动释放，不用写finally</p>
<ul>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">try</span>(a,b)&#123;</span><br><span class="line">    可能产生出异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><ul>
<li><code>java.util.Properties extends Hashtable&lt;K,V&gt; implements Map&lt;K,V&gt;</code> </li>
<li><code>Properties</code>表示一个持久的属性集。<code>Properties</code>可保存在流中或从流中加载。</li>
<li><code>Properties</code>集合是一个唯一和IO流相结合的集合<ul>
<li>可以使用<code>Properties</code>集合中的方法<code>store</code>，把集合中的临时数据，持久化写入到硬盘中存储</li>
<li>可以使用<code>Properties</code>集合中的方法<code>load</code>，把硬盘中保存的文件（键值对），读取到集合中使用</li>
</ul>
</li>
<li>属性列表中每个键及其对应值都是一个字符串：<code>Properties</code>集合是一个双列集合，key和value默认都是字符串<h5 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h5></li>
<li>构造方法：<ul>
<li><code>public Properties()</code>；创建一个空的属性列表</li>
</ul>
</li>
<li>常用方法：<ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li>
<li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合</li>
</ul>
</li>
<li><p>与流相关的方法</p>
<ul>
<li><code>void store(OutputStream out, String comments)</code>；以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</li>
<li><p><code>void store(Writer writer, String comments)</code>；以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符。</p>
<blockquote>
<p>参数；</p>
<ul>
<li>OutputStream out；字节输入流，不能写入中文</li>
<li>Writer writer；字符输出流，可以写中文</li>
<li>String comments；注释，用来解释说明保存的文件是做什么的，不能使用中文，默认unicode编码，一般使用””空字符串</li>
</ul>
</blockquote>
</li>
<li><p><code>void load(InputStream inStream)</code> ；从输入流中读取属性void列表（键和元素对）。</p>
</li>
<li><code>void load(Reader reader)</code> ；按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。 <blockquote>
<p>注意；</p>
<ul>
<li>存储键值对的文件中，键与值默认的链接符号可以使用=，空格（其他符合）</li>
<li>存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取</li>
<li>存储键值对的文件中，键与默认值都是字符串，不用加引号</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><ul>
<li>字节缓冲流： <code>BufferedInputStream</code> ， <code>BufferedOutputStream</code></li>
<li>字符缓冲流： <code>BufferedReader</code> ，<code>BufferedWriter</code></li>
<li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>
</ul>
<h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><ul>
<li><p><code>BufferedOutputStream</code>；字节缓冲输出流</p>
<ul>
<li><code>java.io.BufferedOutputStream.extends.OutputStream</code></li>
<li>构造方法；<ul>
<li><code>public BufferedOutputStream(OutputStream out)</code>； 创建一个新的缓冲输出流，以将数据写入指定的底层输出流</li>
<li><code>public BufferedOutputStream(OutputStream out, int size)</code>；创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流</li>
</ul>
</li>
<li>使用方法；<ol>
<li>创建<code>FileOutputStream</code>对象，构造方法中绑定要输出的目的地</li>
<li>创建<code>BufferedOutputStream</code>对象，构造方法中传递<code>FileOutputStream</code>对象，提高<code>FileOutputStream</code>对象效率</li>
<li>使用<code>BufferedOutputStream</code>对象中的方法<code>write</code>，把数据写入到内部缓冲区中</li>
<li>使用<code>BufferedOutputStream</code>对象中的方法<code>flush</code>,把内部缓冲区中的数据，刷新到文件中</li>
<li>释放资源（会先调用flush方法刷新的数据，第4步可以省略）</li>
</ol>
</li>
</ul>
</li>
<li><p><code>BufferedInputStream</code>；字节缓冲输入流</p>
<ul>
<li><code>java.io.BufferedInputStream.extends.InputStream</code></li>
<li>构造方法；<ul>
<li><code>public BufferedInputStream(InputStream in)</code>； 创建一个新的缓冲输出流，以将数据写入指定的底层输出流</li>
<li><code>public BufferedInputStream(InputStream in, int size)</code>；创建具有指定缓冲区大小的<code>BufferedInputStream</code>并保存其参数，即输入流</li>
</ul>
</li>
<li>使用方法；<ol>
<li>创建<code>FileInputStream</code>对象，构造方法中绑定要读取的数据源</li>
<li>创建<code>BufferedInputStream</code>对象，构造方法中传递<code>FileInputStream</code>对象，提高<code>FileInputStream</code>对象效率</li>
<li>使用<code>BufferedInputStream</code>对象中的方法<code>read</code>，读取文件</li>
<li>释放资源（会先调用flush方法刷新的数据，第4步可以省略）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><ul>
<li><p><code>BufferedWriter</code>；字符缓冲输出流</p>
<ul>
<li><code>java.io.BufferedWriter.extends.Writer</code></li>
<li>构造方法；<ul>
<li><code>public BufferedWriter(Writer out)</code>； 创建一个使用默认大小输出缓冲区的缓冲字符输出流</li>
<li><code>public BufferedWriter(Writer out, int size)</code>；创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流</li>
</ul>
</li>
<li>特有的成员方法；<ul>
<li><code>void newLine()</code>；写入一个行分隔符。会根据不同的操作系统，获取不同的行分隔符</li>
</ul>
</li>
<li>使用方法；<ol>
<li>创建<code>FileWriter</code>对象，构造方法中绑定要输出的目的地</li>
<li>调用字符缓冲输出流的方法write，吧数据写入到内存缓冲区中</li>
<li>调用字符缓冲输出流中的方法flush，把内存缓冲区中的数据，刷新到文件中</li>
<li>释放资源</li>
</ol>
</li>
</ul>
</li>
<li><p><code>BufferedReader</code>；字符缓冲输入流</p>
<ul>
<li><code>java.io.BufferedReader.extends.Reader</code></li>
<li>构造方法；<ul>
<li><code>public BufferedReader(Reader in)</code>； 创建一个使用默认大小输入缓冲区的缓冲字符输入流</li>
<li><code>public BufferedReader(Reader in, int size)</code>；创建一个使用指定大小输入缓冲区字符输入流</li>
</ul>
</li>
<li>特有的成员方法；<ul>
<li><code>String readLine()</code>；读取一个文本行，读取一行数据<blockquote>
<ul>
<li>行的终止符号；通过下列字符之一即可认为某行已终止（换行：<code>\n</code>,回车；<code>\r</code>,或回车后直接跟着换行<code>\r\n</code>）</li>
<li>返回值；包含该行内容的字符串，不包含任何终止符，如果已到达流末尾，则返回null</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>使用方法；<ol>
<li>创建字符缓冲输入流对象，构造方法中传递字符输入流</li>
<li>使用字符缓冲输入流对象中的方法read/readLine读取文本</li>
<li>释放资源</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><ul>
<li>字符编码 Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。<h5 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h5></li>
<li>字符集 Charset ：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。<h5 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h5></li>
<li>字节–（解码）–&gt;字符</li>
<li><code>java.io.InputStreamReader extends Reader</code>；从字节流到字符流的桥梁，它读取字节，并使用指定的字符集将其解码为字符</li>
<li>构造方法；<ul>
<li><code>InputStreamReader(InputStream in)</code> : 创建一个使用默认字符集的字符流。- <code>InputStreamReader(InputStream in, String charsetName)</code> : 创建一个指定字符集的字符流。<h5 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h5></li>
</ul>
</li>
<li>字符–（编码）–&gt;字节</li>
<li><code>java.io.OutputStreamWriter extends Writer</code>；从字符流到字节流的桥梁，使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</li>
<li>构造方法；<ul>
<li><code>OutputStreamWriter(OutputStream out)</code> : 创建一个使用默认字符集的字符流。</li>
<li><code>OutputStreamWriter(OutputStream out, String charsetName)</code> : 创建一个指定字符集的字符流。</li>
</ul>
</li>
</ul>
<h4 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h4><ul>
<li>序列化；把对象以流的方式，写入到文件中保存，也叫写对象</li>
<li>反序列化；把文件中保存的对象，以流的方式读取出来，也叫读对象<h5 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h5></li>
<li>序列化。Java对象的原始数据类型写出到文件,实现对象的持久存储。</li>
<li>构造方法；<ul>
<li><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
</li>
<li>成员方法；<ul>
<li><code>void writerObject(Object obj)</code>；将指定的对象写入ObjectOutputStream<h5 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h5></li>
</ul>
</li>
<li>一个对象要想序列化，必须满足两个条件<ul>
<li>该类必须实现 <code>java.io.Serializable</code> 接口， <code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任<br>何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code>关键字修饰（静态也不能被序列化）。</li>
</ul>
</li>
</ul>
<h5 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h5><ul>
<li>反序列化。将之前使用ObjectOutputStream序列化的原始数据恢复为对象</li>
<li>构造方法；<ul>
<li><code>public ObjectInputStream(InputStream in)</code> ： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
</li>
<li>成员方法；<ul>
<li><code>Object readObject()</code>；从<code>ObjectInputStream</code>读取对象</li>
</ul>
</li>
</ul>
<h5 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h5><ul>
<li>类必须实现Serializable</li>
<li>必须存在类对应的.class文件，如果找不到该类的class文件，则抛出一个<br><code>ClassNotFoundException</code>异常。</li>
<li><code>InvalidClassException</code>；<ul>
<li>当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 InvalidClassException 异常。发生这个异常的原因如下：<ol>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li>
<li>该类包含未知数据类型</li>
<li>该类没有可访问的无参数构造方法</li>
</ol>
</li>
<li>Serializable 接口给需要序列化的类，提供了一个序列版本号。 <code>static final long serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配</li>
</ul>
</li>
</ul>
<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4>
      
    </div>

    

    
    
    
	
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Knowledge is priceless, thanks for your support ！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="吴健伟_Jeremy 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    吴健伟_Jeremy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://coderjeremy.github.io/2020/02/01/Java语法/" title="Java语法">https://coderjeremy.github.io/2020/02/01/Java语法/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>
      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" <i class="fa fa-tag"></i> Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/31/C-基础-02-语法/" rel="next" title="C#基础-02(语法)">
                <i class="fa fa-chevron-left"></i> C#基础-02(语法)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/05/Java网络编程/" rel="prev" title="Java网络编程">
                Java网络编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/profilephoto.jpg"
                alt="吴健伟_Jeremy" />
            
              <p class="site-author-name" itemprop="name">吴健伟_Jeremy</p>
              <p class="site-description motion-element" itemprop="description">艰险我奋进，困乏我多情</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/CoderJeremy" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/chinavae0514" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/Coder_Jeremy" target="_blank" title="CSDN"><i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://jeremywu.tuchong.com/" target="_blank" title="Tuchong"><i class="fa fa-fw fa-camera"></i>Tuchong</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java初步"><span class="nav-number">1.</span> <span class="nav-text">Java初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节"><span class="nav-number">1.1.</span> <span class="nav-text">字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令提示符"><span class="nav-number">1.2.</span> <span class="nav-text">命令提示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM、JRE、JDK"><span class="nav-number">1.3.</span> <span class="nav-text">JVM、JRE、JDK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java环境配置"><span class="nav-number">1.4.</span> <span class="nav-text">Java环境配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java入门"><span class="nav-number">2.</span> <span class="nav-text">Java入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Jaava程序运行步骤"><span class="nav-number">2.1.</span> <span class="nav-text">Jaava程序运行步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HelloWorld"><span class="nav-number">2.2.</span> <span class="nav-text">HelloWorld</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注释"><span class="nav-number">2.3.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字、标识符"><span class="nav-number">2.4.</span> <span class="nav-text">关键字、标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-number">2.5.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">2.6.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java数据类型"><span class="nav-number">2.7.</span> <span class="nav-text">Java数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据类型"><span class="nav-number">2.7.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用数据类型"><span class="nav-number">2.7.2.</span> <span class="nav-text">引用数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-number">2.7.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型转换"><span class="nav-number">2.8.</span> <span class="nav-text">数据类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII码"><span class="nav-number">2.9.</span> <span class="nav-text">ASCII码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">2.10.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法入门"><span class="nav-number">2.11.</span> <span class="nav-text">方法入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java9-新特性"><span class="nav-number">2.12.</span> <span class="nav-text">Java9 新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制"><span class="nav-number">2.13.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序"><span class="nav-number">2.13.1.</span> <span class="nav-text">顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断"><span class="nav-number">2.13.2.</span> <span class="nav-text">判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择"><span class="nav-number">2.13.3.</span> <span class="nav-text">选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环"><span class="nav-number">2.13.4.</span> <span class="nav-text">循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDEA"><span class="nav-number">2.14.</span> <span class="nav-text">IDEA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#快捷键"><span class="nav-number">2.14.1.</span> <span class="nav-text">快捷键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#项目结构"><span class="nav-number">2.14.2.</span> <span class="nav-text">项目结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础"><span class="nav-number">3.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">3.1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">3.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式"><span class="nav-number">3.1.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的调用"><span class="nav-number">3.1.3.</span> <span class="nav-text">方法的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的重载（Overload）"><span class="nav-number">3.1.4.</span> <span class="nav-text">方法的重载（Overload）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">3.1.5.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">3.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">3.2.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">3.2.3.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态初始化"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">动态初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态初始化"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">静态初始化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的访问"><span class="nav-number">3.2.4.</span> <span class="nav-text">数组的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的内存"><span class="nav-number">3.2.5.</span> <span class="nav-text">数组的内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的常见问题"><span class="nav-number">3.2.6.</span> <span class="nav-text">数组的常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的常用操作"><span class="nav-number">3.2.7.</span> <span class="nav-text">数组的常用操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意-1"><span class="nav-number">3.2.8.</span> <span class="nav-text">注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中级"><span class="nav-number">4.</span> <span class="nav-text">Java中级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象思想"><span class="nav-number">4.1.</span> <span class="nav-text">面向对象思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象"><span class="nav-number">4.2.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类和对象的关系"><span class="nav-number">4.2.1.</span> <span class="nav-text">类和对象的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的定义"><span class="nav-number">4.2.2.</span> <span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的使用"><span class="nav-number">4.2.3.</span> <span class="nav-text">对象的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量与局部变量的区别"><span class="nav-number">4.2.4.</span> <span class="nav-text">成员变量与局部变量的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装"><span class="nav-number">4.3.</span> <span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Private"><span class="nav-number">4.3.1.</span> <span class="nav-text">Private</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#This"><span class="nav-number">4.3.2.</span> <span class="nav-text">This</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">4.3.3.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准类-JavaBean"><span class="nav-number">4.4.</span> <span class="nav-text">标准类(JavaBean)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java高级"><span class="nav-number">5.</span> <span class="nav-text">Java高级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用API"><span class="nav-number">5.1.</span> <span class="nav-text">常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Scanner类"><span class="nav-number">5.1.1.</span> <span class="nav-text">Scanner类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名对象"><span class="nav-number">5.1.2.</span> <span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random类"><span class="nav-number">5.1.3.</span> <span class="nav-text">Random类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList类"><span class="nav-number">5.1.4.</span> <span class="nav-text">ArrayList类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">5.1.5.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串常量池"><span class="nav-number">5.1.5.1.</span> <span class="nav-text">字符串常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常用方法"><span class="nav-number">5.1.5.2.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#字符串比较"><span class="nav-number">5.1.5.2.1.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字符串获取"><span class="nav-number">5.1.5.2.2.</span> <span class="nav-text">字符串获取</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字符串截取"><span class="nav-number">5.1.5.2.3.</span> <span class="nav-text">字符串截取</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字符串转换、替换"><span class="nav-number">5.1.5.2.4.</span> <span class="nav-text">字符串转换、替换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字符串分割方法"><span class="nav-number">5.1.5.2.5.</span> <span class="nav-text">字符串分割方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static关键字"><span class="nav-number">5.1.6.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态代码块"><span class="nav-number">5.1.7.</span> <span class="nav-text">静态代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组根据类：Arrays"><span class="nav-number">5.1.8.</span> <span class="nav-text">数组根据类：Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数学工具类：Math"><span class="nav-number">5.1.9.</span> <span class="nav-text">数学工具类：Math</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">5.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#成员变量"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员方法"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">成员方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法重写"><span class="nav-number">5.2.4.</span> <span class="nav-text">方法重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-1"><span class="nav-number">5.2.5.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super关键字"><span class="nav-number">5.2.6.</span> <span class="nav-text">super关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的特征"><span class="nav-number">5.2.7.</span> <span class="nav-text">继承的特征</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">5.3.</span> <span class="nav-text">抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式-2"><span class="nav-number">5.3.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-number">5.3.3.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意-2"><span class="nav-number">5.3.4.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">5.4.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-3"><span class="nav-number">5.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java版本"><span class="nav-number">5.4.2.</span> <span class="nav-text">java版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-1"><span class="nav-number">5.4.3.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的抽象方法"><span class="nav-number">5.4.4.</span> <span class="nav-text">接口的抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的默认方法"><span class="nav-number">5.4.5.</span> <span class="nav-text">接口的默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的静态方法"><span class="nav-number">5.4.6.</span> <span class="nav-text">接口的静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的私有方法"><span class="nav-number">5.4.7.</span> <span class="nav-text">接口的私有方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的成员变量（常量）"><span class="nav-number">5.4.8.</span> <span class="nav-text">接口的成员变量（常量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">5.4.9.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意-3"><span class="nav-number">5.4.10.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的多继承"><span class="nav-number">5.4.11.</span> <span class="nav-text">接口的多继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">5.5.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">5.5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态中的成员变量"><span class="nav-number">5.5.2.</span> <span class="nav-text">多态中的成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态中的成员方法"><span class="nav-number">5.5.3.</span> <span class="nav-text">多态中的成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态的优点"><span class="nav-number">5.5.4.</span> <span class="nav-text">多态的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用类型转换"><span class="nav-number">5.5.5.</span> <span class="nav-text">引用类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#向上转型"><span class="nav-number">5.5.5.1.</span> <span class="nav-text">向上转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向下转型"><span class="nav-number">5.5.5.2.</span> <span class="nav-text">向下转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#instance-of关键字"><span class="nav-number">5.5.5.3.</span> <span class="nav-text">instance of关键字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final关键字"><span class="nav-number">5.6.</span> <span class="nav-text">final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰类"><span class="nav-number">5.6.1.</span> <span class="nav-text">修饰类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰方法"><span class="nav-number">5.6.2.</span> <span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰局部变量"><span class="nav-number">5.6.3.</span> <span class="nav-text">修饰局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰成员变量"><span class="nav-number">5.6.4.</span> <span class="nav-text">修饰成员变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限修饰符"><span class="nav-number">5.7.</span> <span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">5.8.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成员内部类"><span class="nav-number">5.8.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部内部类"><span class="nav-number">5.8.2.</span> <span class="nav-text">局部内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#局部内部类的final问题"><span class="nav-number">5.8.2.1.</span> <span class="nav-text">局部内部类的final问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名内部类"><span class="nav-number">5.8.3.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用API-2"><span class="nav-number">5.9.</span> <span class="nav-text">常用API-2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object类"><span class="nav-number">5.9.1.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#toString方法"><span class="nav-number">5.9.1.1.</span> <span class="nav-text">toString方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#equals方法"><span class="nav-number">5.9.1.2.</span> <span class="nav-text">equals方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Objects类"><span class="nav-number">5.9.1.3.</span> <span class="nav-text">Objects类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date类"><span class="nav-number">5.9.2.</span> <span class="nav-text">Date类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法-2"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员方法-1"><span class="nav-number">5.9.2.2.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DateFormat类"><span class="nav-number">5.9.2.3.</span> <span class="nav-text">DateFormat类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Calendar类"><span class="nav-number">5.9.3.</span> <span class="nav-text">Calendar类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法-1"><span class="nav-number">5.9.4.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System类"><span class="nav-number">5.9.5.</span> <span class="nav-text">System类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用方法-2"><span class="nav-number">5.9.5.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilder类"><span class="nav-number">5.9.6.</span> <span class="nav-text">StringBuilder类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法-3"><span class="nav-number">5.9.6.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员方法-2"><span class="nav-number">5.9.6.2.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意-4"><span class="nav-number">5.9.6.3.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本类型包装类"><span class="nav-number">5.9.7.</span> <span class="nav-text">基本类型包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#装箱与拆箱"><span class="nav-number">5.9.7.1.</span> <span class="nav-text">装箱与拆箱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自动装箱与自动拆箱"><span class="nav-number">5.9.7.2.</span> <span class="nav-text">自动装箱与自动拆箱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基本类型与字符串类型的转换"><span class="nav-number">5.9.7.3.</span> <span class="nav-text">基本类型与字符串类型的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">5.10.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-1"><span class="nav-number">5.10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#框架"><span class="nav-number">5.10.2.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection集合"><span class="nav-number">5.10.3.</span> <span class="nav-text">Collection集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用方法-3"><span class="nav-number">5.10.3.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator迭代器"><span class="nav-number">5.10.4.</span> <span class="nav-text">Iterator迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Iterator接口"><span class="nav-number">5.10.4.1.</span> <span class="nav-text">Iterator接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增强for循环"><span class="nav-number">5.10.4.2.</span> <span class="nav-text">增强for循环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型-Generic"><span class="nav-number">5.10.5.</span> <span class="nav-text">泛型(Generic)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-2"><span class="nav-number">5.10.5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优点"><span class="nav-number">5.10.5.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定义与使用"><span class="nav-number">5.10.5.3.</span> <span class="nav-text">定义与使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#泛型通配符"><span class="nav-number">5.10.5.4.</span> <span class="nav-text">泛型通配符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#泛型的上限限定"><span class="nav-number">5.10.5.5.</span> <span class="nav-text">泛型的上限限定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#泛型的下限限定"><span class="nav-number">5.10.5.6.</span> <span class="nav-text">泛型的下限限定</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List集合"><span class="nav-number">5.10.6.</span> <span class="nav-text">List集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#特点-2"><span class="nav-number">5.10.6.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常用方法-4"><span class="nav-number">5.10.6.2.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子类"><span class="nav-number">5.10.6.3.</span> <span class="nav-text">子类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set集合"><span class="nav-number">5.10.7.</span> <span class="nav-text">Set集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#特点-3"><span class="nav-number">5.10.7.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子类-1"><span class="nav-number">5.10.7.2.</span> <span class="nav-text">子类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HashSet"><span class="nav-number">5.10.7.2.1.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">5.10.7.2.2.</span> <span class="nav-text">LinkedHashSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变参数"><span class="nav-number">5.10.8.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collections工具类"><span class="nav-number">5.10.9.</span> <span class="nav-text">Collections工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用方法-5"><span class="nav-number">5.10.9.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map集合"><span class="nav-number">5.10.10.</span> <span class="nav-text">Map集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Map常用子类"><span class="nav-number">5.10.10.1.</span> <span class="nav-text">Map常用子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map常用方法"><span class="nav-number">5.10.10.2.</span> <span class="nav-text">Map常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map遍历key找value方式"><span class="nav-number">5.10.10.3.</span> <span class="nav-text">Map遍历key找value方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Entry键值对对象"><span class="nav-number">5.10.10.4.</span> <span class="nav-text">Entry键值对对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap存储自定义类型键值"><span class="nav-number">5.10.10.5.</span> <span class="nav-text">HashMap存储自定义类型键值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashMap-lt-K-V-gt"><span class="nav-number">5.10.10.6.</span> <span class="nav-text">LinkedHashMap&lt;K,V&gt;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashTable-lt-K-V-gt"><span class="nav-number">5.10.10.7.</span> <span class="nav-text">HashTable&lt;K,V&gt;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK9对集合添加的优化"><span class="nav-number">5.10.11.</span> <span class="nav-text">JDK9对集合添加的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Debug调试"><span class="nav-number">5.10.12.</span> <span class="nav-text">Debug调试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常与多线程"><span class="nav-number">5.11.</span> <span class="nav-text">异常与多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常"><span class="nav-number">5.11.1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异常体系"><span class="nav-number">5.11.1.1.</span> <span class="nav-text">异常体系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异常处理"><span class="nav-number">5.11.1.2.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#throw"><span class="nav-number">5.11.1.2.1.</span> <span class="nav-text">throw</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#声明异常throws"><span class="nav-number">5.11.1.2.2.</span> <span class="nav-text">声明异常throws</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#捕获异常try…catch"><span class="nav-number">5.11.1.2.3.</span> <span class="nav-text">捕获异常try…catch</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Throwable常用方法"><span class="nav-number">5.11.1.3.</span> <span class="nav-text">Throwable常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finally代码块"><span class="nav-number">5.11.1.4.</span> <span class="nav-text">finally代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异常的注意事项"><span class="nav-number">5.11.1.5.</span> <span class="nav-text">异常的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义异常类"><span class="nav-number">5.11.1.6.</span> <span class="nav-text">自定义异常类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程"><span class="nav-number">5.11.2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#并发与并行"><span class="nav-number">5.11.2.1.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程与进程"><span class="nav-number">5.11.2.2.</span> <span class="nav-text">线程与进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建线程类"><span class="nav-number">5.11.2.3.</span> <span class="nav-text">创建线程类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#方式一：创建Thread类的子类"><span class="nav-number">5.11.2.3.1.</span> <span class="nav-text">方式一：创建Thread类的子类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方式二：实现Runnable接口"><span class="nav-number">5.11.2.3.2.</span> <span class="nav-text">方式二：实现Runnable接口</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现Runnable接口创建多线程的好处"><span class="nav-number">5.11.2.4.</span> <span class="nav-text">实现Runnable接口创建多线程的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread类"><span class="nav-number">5.11.2.5.</span> <span class="nav-text">Thread类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#匿名内部类方式实现线程的创建"><span class="nav-number">5.11.2.6.</span> <span class="nav-text">匿名内部类方式实现线程的创建</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全"><span class="nav-number">5.11.3.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程同步"><span class="nav-number">5.11.3.1.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程同步机制"><span class="nav-number">5.11.3.2.</span> <span class="nav-text">线程同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#同步代码块"><span class="nav-number">5.11.3.2.1.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#同步方法"><span class="nav-number">5.11.3.2.2.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Lock锁"><span class="nav-number">5.11.3.2.3.</span> <span class="nav-text">Lock锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程状态"><span class="nav-number">5.11.4.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#六种状态"><span class="nav-number">5.11.4.1.</span> <span class="nav-text">六种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timed-Waiting-计时等待"><span class="nav-number">5.11.4.2.</span> <span class="nav-text">Timed Waiting 计时等待</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Blocked-锁阻塞"><span class="nav-number">5.11.4.3.</span> <span class="nav-text">Blocked 锁阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Waiting-无限等待"><span class="nav-number">5.11.4.4.</span> <span class="nav-text">Waiting 无限等待</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#等待唤醒机制"><span class="nav-number">5.11.5.</span> <span class="nav-text">等待唤醒机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程间通信"><span class="nav-number">5.11.5.1.</span> <span class="nav-text">线程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#等待唤醒机制-1"><span class="nav-number">5.11.5.2.</span> <span class="nav-text">等待唤醒机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池"><span class="nav-number">5.11.6.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程池的使用"><span class="nav-number">5.11.6.1.</span> <span class="nav-text">线程池的使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">5.11.7.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数式编程思想"><span class="nav-number">5.11.7.1.</span> <span class="nav-text">函数式编程思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda"><span class="nav-number">5.11.7.2.</span> <span class="nav-text">Lambda</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda表达式标准格式"><span class="nav-number">5.11.7.3.</span> <span class="nav-text">Lambda表达式标准格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda省略格式"><span class="nav-number">5.11.7.4.</span> <span class="nav-text">Lambda省略格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda使用前提"><span class="nav-number">5.11.7.5.</span> <span class="nav-text">Lambda使用前提</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File类与IO流"><span class="nav-number">5.12.</span> <span class="nav-text">File类与IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File类"><span class="nav-number">5.12.1.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-3"><span class="nav-number">5.12.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法"><span class="nav-number">5.12.1.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#路径"><span class="nav-number">5.12.1.3.</span> <span class="nav-text">路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法-4"><span class="nav-number">5.12.1.4.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取功能的方法"><span class="nav-number">5.12.1.5.</span> <span class="nav-text">获取功能的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#判断功能的方法"><span class="nav-number">5.12.1.6.</span> <span class="nav-text">判断功能的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建删除功能的方法"><span class="nav-number">5.12.1.7.</span> <span class="nav-text">创建删除功能的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目录的遍历"><span class="nav-number">5.12.1.8.</span> <span class="nav-text">目录的遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件过滤器"><span class="nav-number">5.12.1.9.</span> <span class="nav-text">文件过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#FileFilter"><span class="nav-number">5.12.1.9.1.</span> <span class="nav-text">FileFilter</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FilenameFilter"><span class="nav-number">5.12.1.9.2.</span> <span class="nav-text">FilenameFilter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO流"><span class="nav-number">5.12.2.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IO分类"><span class="nav-number">5.12.2.1.</span> <span class="nav-text">IO分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字节流"><span class="nav-number">5.12.2.2.</span> <span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#字节输出流"><span class="nav-number">5.12.2.2.1.</span> <span class="nav-text">字节输出流</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#写入数据的原理"><span class="nav-number">5.12.2.2.2.</span> <span class="nav-text">写入数据的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#数据追加续写"><span class="nav-number">5.12.2.2.3.</span> <span class="nav-text">数据追加续写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#换行写"><span class="nav-number">5.12.2.2.4.</span> <span class="nav-text">换行写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字节输入流"><span class="nav-number">5.12.2.2.5.</span> <span class="nav-text">字节输入流</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#读取数据的原理"><span class="nav-number">5.12.2.2.6.</span> <span class="nav-text">读取数据的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#关于中文"><span class="nav-number">5.12.2.2.7.</span> <span class="nav-text">关于中文</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符流"><span class="nav-number">5.12.2.3.</span> <span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#字符输出流"><span class="nav-number">5.12.2.3.1.</span> <span class="nav-text">字符输出流</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字符输入流"><span class="nav-number">5.12.2.3.2.</span> <span class="nav-text">字符输入流</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#注意-5"><span class="nav-number">5.12.2.3.3.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IO异常处理"><span class="nav-number">5.12.2.3.4.</span> <span class="nav-text">IO异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性集"><span class="nav-number">5.12.3.</span> <span class="nav-text">属性集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-4"><span class="nav-number">5.12.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Properties类"><span class="nav-number">5.12.3.2.</span> <span class="nav-text">Properties类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲流"><span class="nav-number">5.12.4.</span> <span class="nav-text">缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字节缓冲流"><span class="nav-number">5.12.4.1.</span> <span class="nav-text">字节缓冲流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符缓冲流"><span class="nav-number">5.12.4.2.</span> <span class="nav-text">字符缓冲流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转换流"><span class="nav-number">5.12.5.</span> <span class="nav-text">转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符编码"><span class="nav-number">5.12.5.1.</span> <span class="nav-text">字符编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符集"><span class="nav-number">5.12.5.2.</span> <span class="nav-text">字符集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InputStreamReader类"><span class="nav-number">5.12.5.3.</span> <span class="nav-text">InputStreamReader类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OutputStreamWriter类"><span class="nav-number">5.12.5.4.</span> <span class="nav-text">OutputStreamWriter类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化流"><span class="nav-number">5.12.6.</span> <span class="nav-text">序列化流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectOutputStream类"><span class="nav-number">5.12.6.1.</span> <span class="nav-text">ObjectOutputStream类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#序列化操作"><span class="nav-number">5.12.6.2.</span> <span class="nav-text">序列化操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectInputStream类"><span class="nav-number">5.12.6.3.</span> <span class="nav-text">ObjectInputStream类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反序列化操作"><span class="nav-number">5.12.6.4.</span> <span class="nav-text">反序列化操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打印流"><span class="nav-number">5.12.7.</span> <span class="nav-text">打印流</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
	<i class="fa fa-pencil"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴健伟_Jeremy</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">113k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">1:43</span>
  
</div>













        



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500649602");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66059553";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
      <div>
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bbcbc036fce79a3" async = "async" ></script>
</div>

      </div>
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  





  
  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'BWd1hKwUCCvYPlEQVsx0DMi2-gzGzoHsz',
        appKey: 'Gm6wrsDlLqQaKvCc43GiFLYN',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text(counter.time + 1);
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "BWd1hKwUCCvYPlEQVsx0DMi2-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "BWd1hKwUCCvYPlEQVsx0DMi2-gzGzoHsz",
                'X-LC-Key': "Gm6wrsDlLqQaKvCc43GiFLYN",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  
</body>
</html>
